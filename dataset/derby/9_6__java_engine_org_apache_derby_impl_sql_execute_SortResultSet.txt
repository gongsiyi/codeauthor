2:eac0369: /*
7:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.SortResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:d868eed: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.store.access.SortObserver;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.access.SortController;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:d868eed: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * Takes a source result set, sends it to the sorter,
1:eac0369:  * and returns the results.  If distinct is true, removes
1:eac0369:  * all but one copy of duplicate rows using DistinctAggregator,
1:eac0369:  * which really doesn't aggregate anything at all -- the sorter
1:eac0369:  * assumes that the presence of an aggregator means that
1:eac0369:  * it should return a single row for each set with identical
1:eac0369:  * ordering columns.
1:eac0369:  * <p>
1:eac0369:  * If aggregate is true, then it feeds any number of aggregates
1:eac0369:  * to the sorter.  Each aggregate is an instance of GenericAggregator
1:eac0369:  * which knows which Aggregator to call to perform the
1:eac0369:  * aggregation.
1:eac0369:  * <p>
1:eac0369:  * Brief background on the sorter and aggregates: the sorter
1:eac0369:  * has some rudimentary knowledge about aggregates.  If
1:eac0369:  * it is passed aggregates, it will eliminate duplicates
1:eac0369:  * on the ordering columns.  In the process it will call the
1:eac0369:  * aggregator on each row that is discarded.
1:eac0369:  * <p> 
1:eac0369:  * Note that a DISTINCT on the SELECT list and an aggregate cannot 
1:eac0369:  * be processed by the same SortResultSet(), if there are both
1:eac0369:  * aggregates (distinct or otherwise) and a DISTINCT on the select
1:eac0369:  * list, then 2 separate SortResultSets are required (the DISTINCT
1:eac0369:  * is a sort on the output of the sort with the aggregation). 
1:eac0369:  * <p>
1:eac0369:  * Currently, all rows are fed through the sorter.  This is
1:eac0369:  * true even if there is no sorting needed.  In this case
1:eac0369:  * we feed every row in and just pull every row out (this is
1:eac0369:  * an obvious area for a performance improvement).  We'll
1:eac0369:  * need to know if the rows are sorted before we can make
1:eac0369:  * any optimizations in this area.
1:eac0369:  * <p>
1:eac0369:  * <B>CLONING</B>: Cloning and sorts are an important topic.
1:eac0369:  * Currently we do a lot of cloning.  We clone the following: <UL>
1:eac0369:  * <LI> every row that is inserted into the sorter.  We
1:eac0369:  * need to clone the rows because the source result set might
1:eac0369:  * be reusing rows, and we need to be able to accumulate the
1:eac0369:  * entire result set in the sorter. </LI>
1:eac0369:  * <p>
1:eac0369:  * There are two cloning APIs: cloning by the sorter on
1:eac0369:  * rows that are not discarded as duplicates or cloning
1:eac0369:  * in the SortResultSet prior to inserting into the sorter.
1:eac0369:  * If we have any aggregates at all we always clone prior
1:eac0369:  * to inserting into the sorter.  We need to do this 
1:eac0369:  * because we have to set up the aggregators before passing
1:eac0369:  * them into the sorter.  When we don't have aggregates
1:eac0369:  * we let the sorter to the cloning to avoid unnecessary
1:eac0369:  * clones on duplicate rows that are going to be discarded
1:eac0369:  * anyway.
1:eac0369:  *
1:eac0369:  */
1:f77f36d: class SortResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet 
3:eac0369: {
1:eac0369: 
1:eac0369: 	/* Run time statistics variables */
1:eac0369: 	public int rowsInput;
1:eac0369: 	public int rowsReturned;
1:eac0369: 	public boolean distinct;
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:eac0369:     public NoPutResultSet source;
1:eac0369: 	private ColumnOrdering[] order;
1:eac0369: 	private ColumnOrdering[] savedOrder;
1:eac0369: 	private SortObserver observer;
1:eac0369: 	private ExecRow sortTemplateRow;
1:eac0369: 	public	boolean isInSortedOrder;				// true if source results in sorted order
1:eac0369: 	private	NoPutResultSet	originalSource; // used for run time stats only
1:eac0369: 	private int maxRowSize;
1:eac0369: 
1:eac0369: 	// set in open and not modified thereafter
1:eac0369:     private ScanController scanController;
1:eac0369: 
1:eac0369: 	// argument to getNextRowFromRS()
1:eac0369: 
1:eac0369: 	private ExecRow sortResultRow;
1:eac0369: 
1:eac0369: 	// In order distincts
1:eac0369: 	private ExecRow currSortedRow;
1:eac0369: 	private boolean nextCalled;
1:eac0369: 	private int numColumns;
1:eac0369: 
1:eac0369: 	// used to track and close sorts
1:eac0369: 	private long genericSortId;
1:eac0369: 	private boolean dropGenericSort;
1:eac0369: 
1:eac0369: 	// remember whether or not any sort was performed
1:eac0369: 	private boolean sorted;
1:eac0369: 
1:eac0369: 	// RTS
1:eac0369: 	public Properties sortProperties = new Properties();
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * Constructor
1:eac0369: 	 *
1:eac0369: 	 * @param	s			input result set
1:eac0369: 	 * @param	distinct	if this is a DISTINCT select list.  
1:eac0369: 	 *		Also set to true for a GROUP BY w/o aggretates
1:eac0369: 	 * @param	isInSortedOrder	true if the source results are in sorted order
1:eac0369: 	 * @param	orderingItem	indicates the number of the
1:eac0369: 	 *		SavedObject off of the PreparedStatement that holds the
1:eac0369: 	 *		ColumOrdering array used by this routine
1:eac0369: 	 * @param	a				activation
1:d868eed:      * @param   ra              saved object that generates an empty row
1:eac0369: 	 * @param	maxRowSize		approx row size, passed to sorter
1:eac0369: 	 * @param	resultSetNumber	The resultSetNumber for this result set
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:eac0369:     public SortResultSet(NoPutResultSet s,
1:eac0369: 					boolean distinct,
1:eac0369: 					boolean isInSortedOrder,
1:eac0369: 					int	orderingItem,
1:eac0369: 					Activation a,
1:d868eed: 					int ra,
1:eac0369: 					int maxRowSize,
1:eac0369: 					int resultSetNumber,
1:eac0369: 				    double optimizerEstimatedRowCount,
1:f77f36d: 				    double optimizerEstimatedCost) throws StandardException 
1:eac0369: 	{
1:eac0369: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
1:eac0369: 		this.distinct = distinct;
1:eac0369: 		this.isInSortedOrder = isInSortedOrder;
1:eac0369:         source = s;
1:eac0369:         originalSource = s;
1:eac0369: 		this.maxRowSize = maxRowSize;
1:d868eed: 
1:d868eed:         ExecPreparedStatement ps = a.getPreparedStatement();
1:d868eed: 
1:d868eed: 		sortTemplateRow = ((ExecRowBuilder) ps.getSavedObject(ra))
1:d868eed:                                 .build(a.getExecutionFactory());
1:d868eed: 
1:473d692:         order = ((FormatableArrayHolder) ps.getSavedObject(orderingItem))
1:473d692:                 .getArray(ColumnOrdering[].class);
1:eac0369: 
1:eac0369: 		/* NOTE: We need to save order to another variable
1:eac0369: 		 * in the constructor and reset it on every open.
1:eac0369: 		 * This is important because order can get reset in the
1:eac0369: 		 * guts of execution below.  Subsequent sorts could get
1:eac0369: 		 * the wrong result without this logic.
1:eac0369: 		 */
1:eac0369: 		savedOrder = order;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Create a sort observer that are retained by the
1:eac0369: 		** sort.
1:eac0369: 		*/
1:eac0369: 		observer = new BasicSortObserver(true, distinct, sortTemplateRow, true);
1:eac0369: 
1:7008b63: 		recordConstructorTime();
3:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Open the scan.  Load the sorter and prepare to get
1:eac0369: 	 * rows from it.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException 
1:eac0369: 	{
1:7ac7a9c: 		nextCalled = false;
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		// REVISIT: through the direct DB API, this needs to be an
1:eac0369: 		// error, not an ASSERT; users can open twice. Only through JDBC
1:eac0369: 		// is access to open controlled and ensured valid.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 	    	SanityManager.ASSERT( ! isOpen, "SortResultSet already open");
1:eac0369: 
1:eac0369: 		/* NOTE: We need to save order to another variable
1:eac0369: 		 * in the constructor and reset it on every open.
1:eac0369: 		 * This is important because order can get reset in the
1:eac0369: 		 * guts of execution below.  Subsequent sorts could get
1:eac0369: 		 * the wrong result without this logic.
1:eac0369: 		 */
1:eac0369: 		order = savedOrder;
1:eac0369: 
1:eac0369: 		sortResultRow = sortTemplateRow.getClone();
1:eac0369: 
1:eac0369:         source.openCore();
1:eac0369: 
1:0a6a846: 		try {
1:0a6a846: 			/* If this is an in-order distinct then we do not need the sorter.
1:0a6a846: 			 * (We filter out the duplicate rows ourselves.)  We save a clone
1:0a6a846: 			 * of the first row so that subsequent next()s do not overwrite the
1:0a6a846: 			 * saved row.
1:0a6a846: 			 */
1:0a6a846: 			if (isInSortedOrder && distinct)
1:eac0369: 			{
1:0a6a846: 				currSortedRow = getNextRowFromRS();
1:0a6a846: 
1:0a6a846: 				if (currSortedRow != null)
1:0a6a846: 				{
1:0a6a846: 					currSortedRow = (ExecRow) currSortedRow.getClone();
1:0a6a846: 				}
1:eac0369: 			}
1:0a6a846: 			else
1:0a6a846: 			{
1:0a6a846: 				/*
1:0a6a846: 				** Load up the sorter.
1:0a6a846: 				*/
1:0a6a846: 				scanController = loadSorter();
1:0a6a846: 				sorted = true;
1:0a6a846: 			}
1:0a6a846: 		} catch (StandardException e) {
1:0a6a846: 			// DERBY-4330 Result set tree must be atomically open or
1:0a6a846: 			// closed for reuse to work (after DERBY-827).
1:0a6a846: 			isOpen = true; // to make close do its thing:
1:0a6a846: 			try { close(); } catch (StandardException ee) {}
1:0a6a846: 			throw e;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	    isOpen = true;
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Load up the sorter.  Feed it every row from the
1:eac0369: 	 * source scan.  When done, close
1:eac0369: 	 * the source scan and open the sort.  Return the sort
1:eac0369: 	 * scan controller.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 *
1:eac0369: 	 * @return	the sort controller
1:eac0369:  	 */
1:eac0369: 	private ScanController loadSorter()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		SortController 			sorter;
1:eac0369: 		long 					sortId;
1:eac0369: 		ExecRow 				sourceRow;
1:eac0369: 		ExecRow					inputRow;
1:eac0369: 		boolean					inOrder = (order.length == 0 || isInSortedOrder);
1:eac0369: 		int						inputRowCountEstimate = (int) optimizerEstimatedRowCount;
1:eac0369: 
1:eac0369: 		// find the language context and
1:eac0369:         // Get the current transaction controller
1:eac0369: 		TransactionController tc = getTransactionController();
1:eac0369: 		sortId = tc.createSort((Properties)null, 
1:eac0369: 						sortTemplateRow.getRowArray(),
1:eac0369: 						order,
1:eac0369: 						observer,
1:eac0369: 						inOrder,
1:eac0369: 						inputRowCountEstimate, // est rows
1:eac0369: 					 	maxRowSize			// est rowsize 
1:eac0369: 						);
1:eac0369: 		sorter = tc.openSort(sortId);
1:eac0369: 		genericSortId = sortId;
1:eac0369: 		dropGenericSort = true;
1:eac0369: 	
1:eac0369: 		/* The sorter is responsible for doing the cloning */
1:eac0369: 		while ((inputRow = getNextRowFromRS()) != null) 
1:eac0369: 		{
1:eac0369: 			/* The sorter is responsible for doing the cloning */
1:eac0369: 			sorter.insert(inputRow.getRowArray());
1:eac0369: 		}
1:eac0369: 		source.close();
1:eac0369: 		sortProperties = sorter.getSortInfo().getAllSortInfo(sortProperties);
1:8417890: 		sorter.completedInserts();
1:eac0369: 
1:eac0369: 		return tc.openSortScan(sortId, activation.getResultSetHoldability());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the next row.  
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1:eac0369: 	 *
1:eac0369: 	 * @return the next row in the result
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException 
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 		if (!isOpen)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		// In order distinct
2:eac0369: 		if (isInSortedOrder && distinct)
1:eac0369: 		{
1:eac0369: 			// No rows, no work to do
1:eac0369: 			if (currSortedRow == null)
1:eac0369: 			{
1:eac0369: 				nextTime += getElapsedMillis(beginTime);
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* If this is the 1st next, then simply return the 1st row
1:eac0369: 			 * (which we got on the open()).
1:eac0369: 			 */
1:eac0369: 			if (! nextCalled)
1:eac0369: 			{
1:eac0369: 				nextCalled = true;
1:eac0369: 				numColumns = currSortedRow.getRowArray().length;
1:eac0369: 				nextTime += getElapsedMillis(beginTime);
1:eac0369: 				rowsReturned++;
1:eac0369: 				setCurrentRow(currSortedRow);
1:eac0369: 				return currSortedRow;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		    ExecRow sortResult = getNextRowFromRS();
1:eac0369: 
1:eac0369: 			/* Drain and throw away rows until we find a new distinct row. */
1:eac0369: 			while (sortResult != null)
1:eac0369: 			{
1:eac0369: 				/* We found a new row.  Update the current row and return this one. */
1:eac0369: 				if (! filterRow(currSortedRow, sortResult))
1:eac0369: 				{
1:eac0369: 					/* Save a clone of the new row so that it doesn't get overwritten */
1:eac0369: 					currSortedRow = (ExecRow) sortResult.getClone();
1:eac0369: 					setCurrentRow(currSortedRow);
1:eac0369: 					nextTime += getElapsedMillis(beginTime);
1:eac0369: 					rowsReturned++;
1:eac0369: 					return currSortedRow;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// Get the next row
1:eac0369: 				sortResult = getNextRowFromRS();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// We've drained the source, so no more rows to return
1:eac0369: 			currSortedRow = null;
1:eac0369: 			nextTime += getElapsedMillis(beginTime);
1:eac0369: 			return null;
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 		    ExecRow sortResult = getNextRowFromRS();
1:eac0369: 
1:eac0369: 			if (sortResult != null)
1:eac0369: 			{
1:eac0369: 				setCurrentRow(sortResult);
1:eac0369: 				rowsReturned++;
1:eac0369: 			}
1:eac0369: 			nextTime += getElapsedMillis(beginTime);
1:eac0369: 		    return sortResult;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Filter out the new row if it has the same contents as
1:eac0369: 	 * the current row.  (This allows us to process in-order
1:eac0369: 	 * distincts without a sorter.)
1:eac0369: 	 *
1:eac0369: 	 * @param currRow	The current row.
1:eac0369: 	 * @param newRow	The new row.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not to filter out the new row.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to get row location
1:eac0369: 	 */
1:eac0369: 	private boolean filterRow(ExecRow currRow, ExecRow newRow)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		for (int index = 1; index <= numColumns; index++)
1:eac0369: 		{
1:eac0369: 			DataValueDescriptor currOrderable = currRow.getColumn(index);
1:eac0369: 			DataValueDescriptor newOrderable = newRow.getColumn(index);
1:eac0369: 			if (! (currOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if ( isOpen )
1:eac0369: 	    {
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 		    clearCurrentRow();
1:eac0369: 
1:eac0369: 			sortResultRow = null;
1:eac0369: 			closeSource();
1:eac0369: 
1:eac0369: 			if (dropGenericSort)
1:eac0369: 			{
1:eac0369: 				getTransactionController().dropSort(genericSortId);
1:eac0369: 				dropGenericSort = false;
1:eac0369: 			}
1:eac0369: 			super.close();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of SortResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 
1:eac0369: 		isOpen = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	finish() throws StandardException
1:eac0369: 	{
1:eac0369: 		source.finish();
1:eac0369: 		finishAndRTS();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + 
1:eac0369: 						closeTime;
1:eac0369: 
1:eac0369: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime - originalSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row location from
1:eac0369: 	 * the last fetch done. If the cursor is closed,
1:eac0369: 	 * a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 * @exception StandardException thrown on failure to get row location
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isOpen) return null;
1:eac0369: 
1:eac0369: 		// REVISIT: could we reuse the same rowlocation object
1:eac0369: 		// across several calls?
1:eac0369: 		RowLocation rl;
1:eac0369: 		rl = scanController.newRowLocationTemplate();
1:eac0369: 		scanController.fetchLocation(rl);
1:eac0369: 		return rl;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row from the last fetch done. 
1:eac0369: 	 * If the cursor is closed, a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned;
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isOpen, "SortResultSet expected to be open");
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			DISTINCT assumes the currentRow is good, since it
1:eac0369: 			is the only one with access to its sort scan result
1:eac0369: 		 */
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// SCAN ABSTRACTION UTILITIES
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Get the next output row for processing
1:eac0369: 	 */
1:eac0369: 	private ExecRow getNextRowFromRS()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return (scanController == null) ?
1:eac0369: 			getRowFromResultSet() :
1:eac0369: 			getRowFromSorter();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a row from the input result set.  
1:eac0369: 	 */	
1:eac0369: 	private ExecRow getRowFromResultSet()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow				sourceRow;
1:eac0369: 
1:eac0369: 		if ((sourceRow = source.getNextRowCore()) != null)
1:eac0369: 		{
1:eac0369: 			rowsInput++;
1:eac0369: 		}
1:eac0369: 
1:354870e: 		return sourceRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a row from the sorter.  Side effects:
1:eac0369: 	 * sets currentRow.
1:eac0369: 	 */
1:eac0369: 	private ExecRow getRowFromSorter()
1:eac0369: 		throws StandardException
1:eac0369: 	{
2:eac0369: 		ExecRow			inputRow = null;	
1:eac0369: 		
1:eac0369: 		if (scanController.next())
1:eac0369: 		{
1:eac0369: 			// REMIND: HACKALERT we are assuming that result will
1:eac0369: 			// point to what sortResult is manipulating when
1:eac0369: 			// we complete the fetch.
1:eac0369: 			currentRow = sortResultRow;
1:eac0369: 
1:eac0369: 			inputRow = sortResultRow;
1:eac0369: 
1:eac0369: 			scanController.fetch(inputRow.getRowArray());
1:eac0369: 		}
2:eac0369: 		return inputRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Close the source of whatever we have been scanning.
1:eac0369: 	 */
1:eac0369: 	private void closeSource() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (scanController == null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** NOTE: do not null out source, we
1:eac0369: 			** may be opened again, in which case
1:eac0369: 			** we will open source again.
1:eac0369: 			*/
1:eac0369: 			source.close();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			scanController.close();
1:eac0369: 			scanController = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:473d692
/////////////////////////////////////////////////////////////////////////
1:         order = ((FormatableArrayHolder) ps.getSavedObject(orderingItem))
1:                 .getArray(ColumnOrdering[].class);
commit:d868eed
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param   ra              saved object that generates an empty row
/////////////////////////////////////////////////////////////////////////
1: 					int ra,
/////////////////////////////////////////////////////////////////////////
1: 
1:         ExecPreparedStatement ps = a.getPreparedStatement();
1: 
1: 		sortTemplateRow = ((ExecRowBuilder) ps.getSavedObject(ra))
1:                                 .build(a.getExecutionFactory());
1: 
0: 					((FormatableArrayHolder) ps.getSavedObject(orderingItem))
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0a6a846
/////////////////////////////////////////////////////////////////////////
1: 		try {
1: 			/* If this is an in-order distinct then we do not need the sorter.
1: 			 * (We filter out the duplicate rows ourselves.)  We save a clone
1: 			 * of the first row so that subsequent next()s do not overwrite the
1: 			 * saved row.
1: 			 */
1: 			if (isInSortedOrder && distinct)
1: 				currSortedRow = getNextRowFromRS();
1: 
1: 				if (currSortedRow != null)
1: 				{
1: 					currSortedRow = (ExecRow) currSortedRow.getClone();
1: 				}
1: 			else
1: 			{
1: 				/*
1: 				** Load up the sorter.
1: 				*/
1: 				scanController = loadSorter();
1: 				sorted = true;
1: 			}
1: 		} catch (StandardException e) {
1: 			// DERBY-4330 Result set tree must be atomically open or
1: 			// closed for reuse to work (after DERBY-827).
1: 			isOpen = true; // to make close do its thing:
1: 			try { close(); } catch (StandardException ee) {}
1: 			throw e;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:354870e
/////////////////////////////////////////////////////////////////////////
1: 		return sourceRow;
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		recordConstructorTime();
commit:8417890
/////////////////////////////////////////////////////////////////////////
1: 		sorter.completedInserts();
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class SortResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				    double optimizerEstimatedCost) throws StandardException 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.SortResultSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
0: import org.apache.derby.iapi.services.io.Formatable;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: 
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.store.access.SortObserver;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.access.SortController;
1: import org.apache.derby.iapi.store.access.ScanController;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1: 
1: import java.util.Properties;
0: import java.util.Vector;
0: import java.util.Enumeration;
1: 
1: /**
1:  * Takes a source result set, sends it to the sorter,
1:  * and returns the results.  If distinct is true, removes
1:  * all but one copy of duplicate rows using DistinctAggregator,
1:  * which really doesn't aggregate anything at all -- the sorter
1:  * assumes that the presence of an aggregator means that
1:  * it should return a single row for each set with identical
1:  * ordering columns.
1:  * <p>
1:  * If aggregate is true, then it feeds any number of aggregates
1:  * to the sorter.  Each aggregate is an instance of GenericAggregator
1:  * which knows which Aggregator to call to perform the
1:  * aggregation.
1:  * <p>
1:  * Brief background on the sorter and aggregates: the sorter
1:  * has some rudimentary knowledge about aggregates.  If
1:  * it is passed aggregates, it will eliminate duplicates
1:  * on the ordering columns.  In the process it will call the
1:  * aggregator on each row that is discarded.
1:  * <p> 
1:  * Note that a DISTINCT on the SELECT list and an aggregate cannot 
1:  * be processed by the same SortResultSet(), if there are both
1:  * aggregates (distinct or otherwise) and a DISTINCT on the select
1:  * list, then 2 separate SortResultSets are required (the DISTINCT
1:  * is a sort on the output of the sort with the aggregation). 
1:  * <p>
1:  * Currently, all rows are fed through the sorter.  This is
1:  * true even if there is no sorting needed.  In this case
1:  * we feed every row in and just pull every row out (this is
1:  * an obvious area for a performance improvement).  We'll
1:  * need to know if the rows are sorted before we can make
1:  * any optimizations in this area.
1:  * <p>
1:  * <B>CLONING</B>: Cloning and sorts are an important topic.
1:  * Currently we do a lot of cloning.  We clone the following: <UL>
1:  * <LI> every row that is inserted into the sorter.  We
1:  * need to clone the rows because the source result set might
1:  * be reusing rows, and we need to be able to accumulate the
1:  * entire result set in the sorter. </LI>
1:  * <p>
1:  * There are two cloning APIs: cloning by the sorter on
1:  * rows that are not discarded as duplicates or cloning
1:  * in the SortResultSet prior to inserting into the sorter.
1:  * If we have any aggregates at all we always clone prior
1:  * to inserting into the sorter.  We need to do this 
1:  * because we have to set up the aggregators before passing
1:  * them into the sorter.  When we don't have aggregates
1:  * we let the sorter to the cloning to avoid unnecessary
1:  * clones on duplicate rows that are going to be discarded
1:  * anyway.
1:  *
0:  * @author ames, rewrite for aggregates by jamie, aggregate removal by jerry
1:  */
0: public class SortResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/* Run time statistics variables */
1: 	public int rowsInput;
1: 	public int rowsReturned;
1: 	public boolean distinct;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
1:     public NoPutResultSet source;
0:     private GeneratedMethod closeCleanup;
0: 	private GeneratedMethod rowAllocator;
1: 	private ColumnOrdering[] order;
1: 	private ColumnOrdering[] savedOrder;
1: 	private SortObserver observer;
1: 	private ExecRow sortTemplateRow;
1: 	public	boolean isInSortedOrder;				// true if source results in sorted order
1: 	private	NoPutResultSet	originalSource; // used for run time stats only
1: 	private int maxRowSize;
1: 
1: 	// set in open and not modified thereafter
1:     private ScanController scanController;
1: 
1: 	// argument to getNextRowFromRS()
1: 
1: 	private ExecRow sortResultRow;
1: 
1: 	// In order distincts
1: 	private ExecRow currSortedRow;
1: 	private boolean nextCalled;
1: 	private int numColumns;
1: 
1: 	// used to track and close sorts
1: 	private long genericSortId;
1: 	private boolean dropGenericSort;
1: 
1: 	// remember whether or not any sort was performed
1: 	private boolean sorted;
1: 
1: 	// RTS
1: 	public Properties sortProperties = new Properties();
1: 
1:     /**
1: 	 * Constructor
1: 	 *
1: 	 * @param	s			input result set
1: 	 * @param	distinct	if this is a DISTINCT select list.  
1: 	 *		Also set to true for a GROUP BY w/o aggretates
1: 	 * @param	isInSortedOrder	true if the source results are in sorted order
1: 	 * @param	orderingItem	indicates the number of the
1: 	 *		SavedObject off of the PreparedStatement that holds the
1: 	 *		ColumOrdering array used by this routine
1: 	 * @param	a				activation
0: 	 * @param	ra				generated method to build an empty
0: 	 *	 	output row 
1: 	 * @param	maxRowSize		approx row size, passed to sorter
1: 	 * @param	resultSetNumber	The resultSetNumber for this result set
1: 	 *
1: 	 * @exception StandardException Thrown on error
1: 	 */
1:     public SortResultSet(NoPutResultSet s,
1: 					boolean distinct,
1: 					boolean isInSortedOrder,
1: 					int	orderingItem,
1: 					Activation a,
0: 					GeneratedMethod ra,
1: 					int maxRowSize,
1: 					int resultSetNumber,
1: 				    double optimizerEstimatedRowCount,
0: 				    double optimizerEstimatedCost,
0: 					GeneratedMethod c) throws StandardException 
1: 	{
1: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
1: 		this.distinct = distinct;
1: 		this.isInSortedOrder = isInSortedOrder;
1:         source = s;
1:         originalSource = s;
0: 		rowAllocator = ra;
1: 		this.maxRowSize = maxRowSize;
0:         closeCleanup = c;
0: 		sortTemplateRow = (ExecRow) rowAllocator.invoke(activation);
0: 		order = (ColumnOrdering[])
0: 					((FormatableArrayHolder)
0: 						(a.getPreparedStatement().getSavedObject(orderingItem)))
0: 					.getArray(ColumnOrdering.class);
1: 
1: 		/* NOTE: We need to save order to another variable
1: 		 * in the constructor and reset it on every open.
1: 		 * This is important because order can get reset in the
1: 		 * guts of execution below.  Subsequent sorts could get
1: 		 * the wrong result without this logic.
1: 		 */
1: 		savedOrder = order;
1: 
1: 		/*
1: 		** Create a sort observer that are retained by the
1: 		** sort.
1: 		*/
1: 		observer = new BasicSortObserver(true, distinct, sortTemplateRow, true);
1: 
0: 		constructorTime += getElapsedMillis(beginTime);
1:     }
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Open the scan.  Load the sorter and prepare to get
1: 	 * rows from it.
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	openCore() throws StandardException 
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		// REVISIT: through the direct DB API, this needs to be an
1: 		// error, not an ASSERT; users can open twice. Only through JDBC
1: 		// is access to open controlled and ensured valid.
1: 		if (SanityManager.DEBUG)
1: 	    	SanityManager.ASSERT( ! isOpen, "SortResultSet already open");
1: 
1: 		/* NOTE: We need to save order to another variable
1: 		 * in the constructor and reset it on every open.
1: 		 * This is important because order can get reset in the
1: 		 * guts of execution below.  Subsequent sorts could get
1: 		 * the wrong result without this logic.
1: 		 */
1: 		order = savedOrder;
1: 
1: 		sortResultRow = sortTemplateRow.getClone();
1: 
1:         source.openCore();
1: 
0: 		/* If this is an in-order distinct then we do not need the sorter.
0: 		 * (We filter out the duplicate rows ourselves.)
0: 		 * We save a clone of the first row so that subsequent next()s
0: 		 * do not overwrite the saved row.
1: 		 */
1: 		if (isInSortedOrder && distinct)
1: 		{
0: 			currSortedRow = getNextRowFromRS();
0: 			if (currSortedRow != null)
1: 			{
0: 				currSortedRow = (ExecRow) currSortedRow.getClone();
1: 			}
1: 		}
1: 		else
1: 		{
1: 			/*
0: 			** Load up the sorter.
1: 			*/
0: 			scanController = loadSorter();
0: 			sorted = true;
1: 		}
1: 
1: 	    isOpen = true;
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * Load up the sorter.  Feed it every row from the
1: 	 * source scan.  When done, close
1: 	 * the source scan and open the sort.  Return the sort
1: 	 * scan controller.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 *
1: 	 * @return	the sort controller
1:  	 */
1: 	private ScanController loadSorter()
1: 		throws StandardException
1: 	{
1: 		SortController 			sorter;
1: 		long 					sortId;
1: 		ExecRow 				sourceRow;
1: 		ExecRow					inputRow;
1: 		boolean					inOrder = (order.length == 0 || isInSortedOrder);
1: 		int						inputRowCountEstimate = (int) optimizerEstimatedRowCount;
1: 
1: 		// find the language context and
1:         // Get the current transaction controller
1: 		TransactionController tc = getTransactionController();
1: 		sortId = tc.createSort((Properties)null, 
1: 						sortTemplateRow.getRowArray(),
1: 						order,
1: 						observer,
1: 						inOrder,
1: 						inputRowCountEstimate, // est rows
1: 					 	maxRowSize			// est rowsize 
1: 						);
1: 		sorter = tc.openSort(sortId);
1: 		genericSortId = sortId;
1: 		dropGenericSort = true;
1: 	
1: 		/* The sorter is responsible for doing the cloning */
1: 		while ((inputRow = getNextRowFromRS()) != null) 
1: 		{
1: 			/* The sorter is responsible for doing the cloning */
1: 			sorter.insert(inputRow.getRowArray());
1: 		}
1: 		source.close();
1: 		sortProperties = sorter.getSortInfo().getAllSortInfo(sortProperties);
0: 		sorter.close();
1: 
1: 		return tc.openSortScan(sortId, activation.getResultSetHoldability());
1: 	}
1: 
1: 
1: 	/**
1: 	 * Return the next row.  
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1: 	 *
1: 	 * @return the next row in the result
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException 
1: 	{
1: 		if (!isOpen)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		// In order distinct
1: 		if (isInSortedOrder && distinct)
1: 		{
1: 			// No rows, no work to do
1: 			if (currSortedRow == null)
1: 			{
1: 				nextTime += getElapsedMillis(beginTime);
1: 				return null;
1: 			}
1: 
1: 			/* If this is the 1st next, then simply return the 1st row
1: 			 * (which we got on the open()).
1: 			 */
1: 			if (! nextCalled)
1: 			{
1: 				nextCalled = true;
1: 				numColumns = currSortedRow.getRowArray().length;
1: 				nextTime += getElapsedMillis(beginTime);
1: 				rowsReturned++;
1: 				setCurrentRow(currSortedRow);
1: 				return currSortedRow;
1: 			}
1: 
1: 		    ExecRow sortResult = getNextRowFromRS();
1: 
1: 			/* Drain and throw away rows until we find a new distinct row. */
1: 			while (sortResult != null)
1: 			{
1: 				/* We found a new row.  Update the current row and return this one. */
1: 				if (! filterRow(currSortedRow, sortResult))
1: 				{
1: 					/* Save a clone of the new row so that it doesn't get overwritten */
1: 					currSortedRow = (ExecRow) sortResult.getClone();
1: 					setCurrentRow(currSortedRow);
1: 					nextTime += getElapsedMillis(beginTime);
1: 					rowsReturned++;
1: 					return currSortedRow;
1: 				}
1: 
1: 				// Get the next row
1: 				sortResult = getNextRowFromRS();
1: 			}
1: 
1: 			// We've drained the source, so no more rows to return
1: 			currSortedRow = null;
1: 			nextTime += getElapsedMillis(beginTime);
1: 			return null;
1: 		}
1: 		else
1: 		{
1: 		    ExecRow sortResult = getNextRowFromRS();
1: 
1: 			if (sortResult != null)
1: 			{
1: 				setCurrentRow(sortResult);
1: 				rowsReturned++;
1: 			}
1: 			nextTime += getElapsedMillis(beginTime);
1: 		    return sortResult;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Filter out the new row if it has the same contents as
1: 	 * the current row.  (This allows us to process in-order
1: 	 * distincts without a sorter.)
1: 	 *
1: 	 * @param currRow	The current row.
1: 	 * @param newRow	The new row.
1: 	 *
1: 	 * @return	Whether or not to filter out the new row.
1: 	 *
1: 	 * @exception StandardException thrown on failure to get row location
1: 	 */
1: 	private boolean filterRow(ExecRow currRow, ExecRow newRow)
1: 		throws StandardException
1: 	{
1: 		for (int index = 1; index <= numColumns; index++)
1: 		{
1: 			DataValueDescriptor currOrderable = currRow.getColumn(index);
1: 			DataValueDescriptor newOrderable = newRow.getColumn(index);
1: 			if (! (currOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if ( isOpen )
1: 	    {
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 		    clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			}
1: 
0: 			currentRow = null;
1: 			sortResultRow = null;
1: 			closeSource();
1: 
1: 			if (dropGenericSort)
1: 			{
1: 				getTransactionController().dropSort(genericSortId);
1: 				dropGenericSort = false;
1: 			}
1: 			super.close();
1: 		}
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of SortResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 
1: 		isOpen = false;
1: 	}
1: 
1: 	public void	finish() throws StandardException
1: 	{
1: 		source.finish();
1: 		finishAndRTS();
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + 
1: 						closeTime;
1: 
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - originalSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * This result set has its row location from
1: 	 * the last fetch done. If the cursor is closed,
1: 	 * a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 * @exception StandardException thrown on failure to get row location
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException
1: 	{
1: 		if (! isOpen) return null;
1: 
1: 		// REVISIT: could we reuse the same rowlocation object
1: 		// across several calls?
1: 		RowLocation rl;
1: 		rl = scanController.newRowLocationTemplate();
1: 		scanController.fetchLocation(rl);
1: 		return rl;
1: 	}
1: 
1: 	/**
1: 	 * This result set has its row from the last fetch done. 
1: 	 * If the cursor is closed, a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned;
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() throws StandardException 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isOpen, "SortResultSet expected to be open");
1: 
1: 		/*
1: 			DISTINCT assumes the currentRow is good, since it
1: 			is the only one with access to its sort scan result
1: 		 */
1: 		return currentRow;
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// SCAN ABSTRACTION UTILITIES
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Get the next output row for processing
1: 	 */
1: 	private ExecRow getNextRowFromRS()
1: 		throws StandardException
1: 	{
1: 		return (scanController == null) ?
1: 			getRowFromResultSet() :
1: 			getRowFromSorter();
1: 	}
1: 
1: 	/**
1: 	 * Get a row from the input result set.  
1: 	 */	
1: 	private ExecRow getRowFromResultSet()
1: 		throws StandardException
1: 	{
1: 		ExecRow				sourceRow;
1: 		ExecRow			inputRow = null;	
1: 
1: 		if ((sourceRow = source.getNextRowCore()) != null)
1: 		{
1: 			rowsInput++;
0: 			inputRow = sourceRow;
1: 		}
1: 
1: 		return inputRow;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get a row from the sorter.  Side effects:
1: 	 * sets currentRow.
1: 	 */
1: 	private ExecRow getRowFromSorter()
1: 		throws StandardException
1: 	{
1: 		ExecRow			inputRow = null;	
1: 		
1: 		if (scanController.next())
1: 		{
1: 			// REMIND: HACKALERT we are assuming that result will
1: 			// point to what sortResult is manipulating when
1: 			// we complete the fetch.
1: 			currentRow = sortResultRow;
1: 
1: 			inputRow = sortResultRow;
1: 
1: 			scanController.fetch(inputRow.getRowArray());
1: 		}
1: 		return inputRow;
1: 	}
1: 
1: 	/**
1: 	 * Close the source of whatever we have been scanning.
1: 	 */
1: 	private void closeSource() throws StandardException
1: 	{
1: 		if (scanController == null)
1: 		{
1: 			/*
1: 			** NOTE: do not null out source, we
1: 			** may be opened again, in which case
1: 			** we will open source again.
1: 			*/
1: 			source.close();
1: 		}
1: 		else
1: 		{
1: 			scanController.close();
1: 			scanController = null;
1: 		}
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:7ac7a9c
/////////////////////////////////////////////////////////////////////////
1: 		nextCalled = false;
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.store.access.SortObserver;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.SortController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: 
0: import java.util.Properties;
0: import java.util.Vector;
0: import java.util.Enumeration;
0: 
0: /**
0:  * Takes a source result set, sends it to the sorter,
0:  * and returns the results.  If distinct is true, removes
0:  * all but one copy of duplicate rows using DistinctAggregator,
0:  * which really doesn't aggregate anything at all -- the sorter
0:  * assumes that the presence of an aggregator means that
0:  * it should return a single row for each set with identical
0:  * ordering columns.
0:  * <p>
0:  * If aggregate is true, then it feeds any number of aggregates
0:  * to the sorter.  Each aggregate is an instance of GenericAggregator
0:  * which knows which Aggregator to call to perform the
0:  * aggregation.
0:  * <p>
0:  * Brief background on the sorter and aggregates: the sorter
0:  * has some rudimentary knowledge about aggregates.  If
0:  * it is passed aggregates, it will eliminate duplicates
0:  * on the ordering columns.  In the process it will call the
0:  * aggregator on each row that is discarded.
0:  * <p> 
0:  * Note that a DISTINCT on the SELECT list and an aggregate cannot 
0:  * be processed by the same SortResultSet(), if there are both
0:  * aggregates (distinct or otherwise) and a DISTINCT on the select
0:  * list, then 2 separate SortResultSets are required (the DISTINCT
0:  * is a sort on the output of the sort with the aggregation). 
0:  * <p>
0:  * Currently, all rows are fed through the sorter.  This is
0:  * true even if there is no sorting needed.  In this case
0:  * we feed every row in and just pull every row out (this is
0:  * an obvious area for a performance improvement).  We'll
0:  * need to know if the rows are sorted before we can make
0:  * any optimizations in this area.
0:  * <p>
0:  * <B>CLONING</B>: Cloning and sorts are an important topic.
0:  * Currently we do a lot of cloning.  We clone the following: <UL>
0:  * <LI> every row that is inserted into the sorter.  We
0:  * need to clone the rows because the source result set might
0:  * be reusing rows, and we need to be able to accumulate the
0:  * entire result set in the sorter. </LI>
0:  * <p>
0:  * There are two cloning APIs: cloning by the sorter on
0:  * rows that are not discarded as duplicates or cloning
0:  * in the SortResultSet prior to inserting into the sorter.
0:  * If we have any aggregates at all we always clone prior
0:  * to inserting into the sorter.  We need to do this 
0:  * because we have to set up the aggregators before passing
0:  * them into the sorter.  When we don't have aggregates
0:  * we let the sorter to the cloning to avoid unnecessary
0:  * clones on duplicate rows that are going to be discarded
0:  * anyway.
0:  *
0:  * @author ames, rewrite for aggregates by jamie, aggregate removal by jerry
0:  */
0: public class SortResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/* Run time statistics variables */
0: 	public int rowsInput;
0: 	public int rowsReturned;
0: 	public boolean distinct;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0:     public NoPutResultSet source;
0:     private GeneratedMethod closeCleanup;
0: 	private GeneratedMethod rowAllocator;
0: 	private ColumnOrdering[] order;
0: 	private ColumnOrdering[] savedOrder;
0: 	private SortObserver observer;
0: 	private ExecRow sortTemplateRow;
0: 	public	boolean isInSortedOrder;				// true if source results in sorted order
0: 	private	NoPutResultSet	originalSource; // used for run time stats only
0: 	private int maxRowSize;
0: 
0: 	// set in open and not modified thereafter
0:     private ScanController scanController;
0: 
0: 	// argument to getNextRowFromRS()
0: 
0: 	private ExecRow sortResultRow;
0: 
0: 	// In order distincts
0: 	private ExecRow currSortedRow;
0: 	private boolean nextCalled;
0: 	private int numColumns;
0: 
0: 	// used to track and close sorts
0: 	private long genericSortId;
0: 	private boolean dropGenericSort;
0: 
0: 	// remember whether or not any sort was performed
0: 	private boolean sorted;
0: 
0: 	// RTS
0: 	public Properties sortProperties = new Properties();
0: 
0:     /**
0: 	 * Constructor
0: 	 *
0: 	 * @param	s			input result set
0: 	 * @param	distinct	if this is a DISTINCT select list.  
0: 	 *		Also set to true for a GROUP BY w/o aggretates
0: 	 * @param	isInSortedOrder	true if the source results are in sorted order
0: 	 * @param	orderingItem	indicates the number of the
0: 	 *		SavedObject off of the PreparedStatement that holds the
0: 	 *		ColumOrdering array used by this routine
0: 	 * @param	a				activation
0: 	 * @param	ra				generated method to build an empty
0: 	 *	 	output row 
0: 	 * @param	maxRowSize		approx row size, passed to sorter
0: 	 * @param	resultSetNumber	The resultSetNumber for this result set
0: 	 *
0: 	 * @exception StandardException Thrown on error
0: 	 */
0:     public SortResultSet(NoPutResultSet s,
0: 					boolean distinct,
0: 					boolean isInSortedOrder,
0: 					int	orderingItem,
0: 					Activation a,
0: 					GeneratedMethod ra,
0: 					int maxRowSize,
0: 					int resultSetNumber,
0: 				    double optimizerEstimatedRowCount,
0: 				    double optimizerEstimatedCost,
0: 					GeneratedMethod c) throws StandardException 
0: 	{
0: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
0: 		this.distinct = distinct;
0: 		this.isInSortedOrder = isInSortedOrder;
0:         source = s;
0:         originalSource = s;
0: 		rowAllocator = ra;
0: 		this.maxRowSize = maxRowSize;
0:         closeCleanup = c;
0: 		sortTemplateRow = (ExecRow) rowAllocator.invoke(activation);
0: 		order = (ColumnOrdering[])
0: 					((FormatableArrayHolder)
0: 						(a.getPreparedStatement().getSavedObject(orderingItem)))
0: 					.getArray(ColumnOrdering.class);
0: 
0: 		/* NOTE: We need to save order to another variable
0: 		 * in the constructor and reset it on every open.
0: 		 * This is important because order can get reset in the
0: 		 * guts of execution below.  Subsequent sorts could get
0: 		 * the wrong result without this logic.
0: 		 */
0: 		savedOrder = order;
0: 
0: 		/*
0: 		** Create a sort observer that are retained by the
0: 		** sort.
0: 		*/
0: 		observer = new BasicSortObserver(true, distinct, sortTemplateRow, true);
0: 
0: 		constructorTime += getElapsedMillis(beginTime);
0:     }
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Open the scan.  Load the sorter and prepare to get
0: 	 * rows from it.
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	openCore() throws StandardException 
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		// REVISIT: through the direct DB API, this needs to be an
0: 		// error, not an ASSERT; users can open twice. Only through JDBC
0: 		// is access to open controlled and ensured valid.
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT( ! isOpen, "SortResultSet already open");
0: 
0: 		/* NOTE: We need to save order to another variable
0: 		 * in the constructor and reset it on every open.
0: 		 * This is important because order can get reset in the
0: 		 * guts of execution below.  Subsequent sorts could get
0: 		 * the wrong result without this logic.
0: 		 */
0: 		order = savedOrder;
0: 
0: 		sortResultRow = sortTemplateRow.getClone();
0: 
0:         source.openCore();
0: 
0: 		/* If this is an in-order distinct then we do not need the sorter.
0: 		 * (We filter out the duplicate rows ourselves.)
0: 		 * We save a clone of the first row so that subsequent next()s
0: 		 * do not overwrite the saved row.
0: 		 */
0: 		if (isInSortedOrder && distinct)
0: 		{
0: 			currSortedRow = getNextRowFromRS();
0: 			if (currSortedRow != null)
0: 			{
0: 				currSortedRow = (ExecRow) currSortedRow.getClone();
0: 			}
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** Load up the sorter.
0: 			*/
0: 			scanController = loadSorter();
0: 			sorted = true;
0: 		}
0: 
0: 	    isOpen = true;
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * Load up the sorter.  Feed it every row from the
0: 	 * source scan.  When done, close
0: 	 * the source scan and open the sort.  Return the sort
0: 	 * scan controller.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 *
0: 	 * @return	the sort controller
0:  	 */
0: 	private ScanController loadSorter()
0: 		throws StandardException
0: 	{
0: 		SortController 			sorter;
0: 		long 					sortId;
0: 		ExecRow 				sourceRow;
0: 		ExecRow					inputRow;
0: 		boolean					inOrder = (order.length == 0 || isInSortedOrder);
0: 		int						inputRowCountEstimate = (int) optimizerEstimatedRowCount;
0: 
0: 		// find the language context and
0:         // Get the current transaction controller
0: 		TransactionController tc = getTransactionController();
0: 		sortId = tc.createSort((Properties)null, 
0: 						sortTemplateRow.getRowArray(),
0: 						order,
0: 						observer,
0: 						inOrder,
0: 						inputRowCountEstimate, // est rows
0: 					 	maxRowSize			// est rowsize 
0: 						);
0: 		sorter = tc.openSort(sortId);
0: 		genericSortId = sortId;
0: 		dropGenericSort = true;
0: 	
0: 		/* The sorter is responsible for doing the cloning */
0: 		while ((inputRow = getNextRowFromRS()) != null) 
0: 		{
0: 			/* The sorter is responsible for doing the cloning */
0: 			sorter.insert(inputRow.getRowArray());
0: 		}
0: 		source.close();
0: 		sortProperties = sorter.getSortInfo().getAllSortInfo(sortProperties);
0: 		sorter.close();
0: 
0: 		return tc.openSortScan(sortId, activation.getResultSetHoldability());
0: 	}
0: 
0: 
0: 	/**
0: 	 * Return the next row.  
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
0: 	 *
0: 	 * @return the next row in the result
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException 
0: 	{
0: 		if (!isOpen)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		// In order distinct
0: 		if (isInSortedOrder && distinct)
0: 		{
0: 			// No rows, no work to do
0: 			if (currSortedRow == null)
0: 			{
0: 				nextTime += getElapsedMillis(beginTime);
0: 				return null;
0: 			}
0: 
0: 			/* If this is the 1st next, then simply return the 1st row
0: 			 * (which we got on the open()).
0: 			 */
0: 			if (! nextCalled)
0: 			{
0: 				nextCalled = true;
0: 				numColumns = currSortedRow.getRowArray().length;
0: 				nextTime += getElapsedMillis(beginTime);
0: 				rowsReturned++;
0: 				setCurrentRow(currSortedRow);
0: 				return currSortedRow;
0: 			}
0: 
0: 		    ExecRow sortResult = getNextRowFromRS();
0: 
0: 			/* Drain and throw away rows until we find a new distinct row. */
0: 			while (sortResult != null)
0: 			{
0: 				/* We found a new row.  Update the current row and return this one. */
0: 				if (! filterRow(currSortedRow, sortResult))
0: 				{
0: 					/* Save a clone of the new row so that it doesn't get overwritten */
0: 					currSortedRow = (ExecRow) sortResult.getClone();
0: 					setCurrentRow(currSortedRow);
0: 					nextTime += getElapsedMillis(beginTime);
0: 					rowsReturned++;
0: 					return currSortedRow;
0: 				}
0: 
0: 				// Get the next row
0: 				sortResult = getNextRowFromRS();
0: 			}
0: 
0: 			// We've drained the source, so no more rows to return
0: 			currSortedRow = null;
0: 			nextTime += getElapsedMillis(beginTime);
0: 			return null;
0: 		}
0: 		else
0: 		{
0: 		    ExecRow sortResult = getNextRowFromRS();
0: 
0: 			if (sortResult != null)
0: 			{
0: 				setCurrentRow(sortResult);
0: 				rowsReturned++;
0: 			}
0: 			nextTime += getElapsedMillis(beginTime);
0: 		    return sortResult;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Filter out the new row if it has the same contents as
0: 	 * the current row.  (This allows us to process in-order
0: 	 * distincts without a sorter.)
0: 	 *
0: 	 * @param currRow	The current row.
0: 	 * @param newRow	The new row.
0: 	 *
0: 	 * @return	Whether or not to filter out the new row.
0: 	 *
0: 	 * @exception StandardException thrown on failure to get row location
0: 	 */
0: 	private boolean filterRow(ExecRow currRow, ExecRow newRow)
0: 		throws StandardException
0: 	{
0: 		for (int index = 1; index <= numColumns; index++)
0: 		{
0: 			DataValueDescriptor currOrderable = currRow.getColumn(index);
0: 			DataValueDescriptor newOrderable = newRow.getColumn(index);
0: 			if (! (currOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if ( isOpen )
0: 	    {
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 		    clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			}
0: 
0: 			currentRow = null;
0: 			sortResultRow = null;
0: 			closeSource();
0: 
0: 			if (dropGenericSort)
0: 			{
0: 				getTransactionController().dropSort(genericSortId);
0: 				dropGenericSort = false;
0: 			}
0: 			super.close();
0: 		}
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of SortResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 
0: 		isOpen = false;
0: 	}
0: 
0: 	public void	finish() throws StandardException
0: 	{
0: 		source.finish();
0: 		finishAndRTS();
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + 
0: 						closeTime;
0: 
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - originalSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * This result set has its row location from
0: 	 * the last fetch done. If the cursor is closed,
0: 	 * a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 * @exception StandardException thrown on failure to get row location
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException
0: 	{
0: 		if (! isOpen) return null;
0: 
0: 		// REVISIT: could we reuse the same rowlocation object
0: 		// across several calls?
0: 		RowLocation rl;
0: 		rl = scanController.newRowLocationTemplate();
0: 		scanController.fetchLocation(rl);
0: 		return rl;
0: 	}
0: 
0: 	/**
0: 	 * This result set has its row from the last fetch done. 
0: 	 * If the cursor is closed, a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned;
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() throws StandardException 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isOpen, "SortResultSet expected to be open");
0: 
0: 		/*
0: 			DISTINCT assumes the currentRow is good, since it
0: 			is the only one with access to its sort scan result
0: 		 */
0: 		return currentRow;
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// SCAN ABSTRACTION UTILITIES
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Get the next output row for processing
0: 	 */
0: 	private ExecRow getNextRowFromRS()
0: 		throws StandardException
0: 	{
0: 		return (scanController == null) ?
0: 			getRowFromResultSet() :
0: 			getRowFromSorter();
0: 	}
0: 
0: 	/**
0: 	 * Get a row from the input result set.  
0: 	 */	
0: 	private ExecRow getRowFromResultSet()
0: 		throws StandardException
0: 	{
0: 		ExecRow				sourceRow;
0: 		ExecRow			inputRow = null;	
0: 
0: 		if ((sourceRow = source.getNextRowCore()) != null)
0: 		{
0: 			rowsInput++;
0: 			inputRow = sourceRow;
0: 		}
0: 
0: 		return inputRow;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get a row from the sorter.  Side effects:
0: 	 * sets currentRow.
0: 	 */
0: 	private ExecRow getRowFromSorter()
0: 		throws StandardException
0: 	{
0: 		ExecRow			inputRow = null;	
0: 		
0: 		if (scanController.next())
0: 		{
0: 			// REMIND: HACKALERT we are assuming that result will
0: 			// point to what sortResult is manipulating when
0: 			// we complete the fetch.
0: 			currentRow = sortResultRow;
0: 
0: 			inputRow = sortResultRow;
0: 
0: 			scanController.fetch(inputRow.getRowArray());
0: 		}
0: 		return inputRow;
0: 	}
0: 
0: 	/**
0: 	 * Close the source of whatever we have been scanning.
0: 	 */
0: 	private void closeSource() throws StandardException
0: 	{
0: 		if (scanController == null)
0: 		{
0: 			/*
0: 			** NOTE: do not null out source, we
0: 			** may be opened again, in which case
0: 			** we will open source again.
0: 			*/
0: 			source.close();
0: 		}
0: 		else
0: 		{
0: 			scanController.close();
0: 			scanController = null;
0: 		}
0: 	}
0: }
============================================================================