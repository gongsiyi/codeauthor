1:7f17ba1: /*
8:7f17ba1: 
1:7f17ba1: Derby - Class org.apache.derby.vti.XmlVTI
1:7f17ba1: 
1:7f17ba1: Licensed to the Apache Software Foundation (ASF) under one or more
1:7f17ba1: contributor license agreements.  See the NOTICE file distributed with
1:7f17ba1: this work for additional information regarding copyright ownership.
1:7f17ba1: The ASF licenses this file to You under the Apache License, Version 2.0
1:7f17ba1: (the "License"); you may not use this file except in compliance with
1:7f17ba1: the License.  You may obtain a copy of the License at
1:7f17ba1: 
1:7f17ba1: http://www.apache.org/licenses/LICENSE-2.0
1:7f17ba1: 
1:7f17ba1: Unless required by applicable law or agreed to in writing, software
1:7f17ba1: distributed under the License is distributed on an "AS IS" BASIS,
1:7f17ba1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7f17ba1: See the License for the specific language governing permissions and
1:7f17ba1: limitations under the License.
1:7f17ba1: 
1:7f17ba1: */
1:7f17ba1: 
1:7f17ba1: package org.apache.derby.vti;
1:7f17ba1: 
1:3397f9f: import java.io.File;
1:3397f9f: import java.io.FileInputStream;
1:d08ab9b: import java.io.InputStream;
1:23e89eb: import java.io.IOException;
1:d08ab9b: import java.net.URL;
1:23e89eb: import java.security.AccessController;
1:23e89eb: import java.security.PrivilegedAction;
1:23643e8: import java.sql.ResultSetMetaData;
1:23643e8: import java.sql.SQLException;
1:7f17ba1: import java.text.DateFormat;
1:7f17ba1: import java.text.ParseException;
1:23643e8: import java.util.ArrayList;
1:23643e8: import javax.xml.parsers.DocumentBuilder;
1:23643e8: import javax.xml.parsers.DocumentBuilderFactory;
1:7643f96: import javax.xml.XMLConstants;
1:23643e8: import org.w3c.dom.Document;
1:23643e8: import org.w3c.dom.Element;
1:23643e8: import org.w3c.dom.Node;
1:23643e8: import org.w3c.dom.NodeList;
1:7ed0ef0: import org.xml.sax.ErrorHandler;
1:23e89eb: import org.xml.sax.SAXException;
1:7ed0ef0: import org.xml.sax.SAXParseException;
1:7f17ba1: 
1:7f17ba1: /**
1:7f17ba1:  * <p>
1:7f17ba1:  * This is a VTI designed to read XML files which are structured like row sets.
1:7643f96:  * <p>
1:7643f96:  * XML files parsed by this VTI are always processed with external entity
1:7643f96:  * expansion disabled and secure parser processing enabled.
1:7643f96:  * <p>
1:7643f96:  * There are two invocation formats provided by this VTI.
1:7643f96:  * <p>
1:23643e8:  * One form of this VTI takes the following arguments. This form is useful when
1:23643e8:  * all of the columns in the row can be constructed from data nested INSIDE the row Element.
1:7f17ba1:  * </p>
1:7f17ba1:  *
1:7f17ba1:  * <ul>
1:3397f9f:  * <li>xmlResourceName - The name of an xml file.</li>
1:7f17ba1:  * <li>rowTag - The tag of the element which contains the row-structured content.</li>
1:7f17ba1:  * <li>childTags - The attributes and descendant elements inside the row element which should be treated as columns.</li>
1:7f17ba1:  * </ul>
1:7f17ba1:  *
1:7f17ba1:  * <p>
1:23643e8:  * Here is a sample declaration of this first form of the XmlVTI:
1:7f17ba1:  * </p>
1:7f17ba1:  *
1:7f17ba1:  * <pre>
1:7f17ba1:  * create function findbugs( xmlResourceName varchar( 32672 ), rowTag varchar( 32672 ), childTags varchar( 32672 )... )
1:7f17ba1:  * returns table
1:7f17ba1:  * (
1:7f17ba1:  *      className   varchar( 32672 ),
1:7f17ba1:  *      bugCount    int
1:7f17ba1:  * )
1:7f17ba1:  * language java parameter style derby_jdbc_result_set no sql
1:7f17ba1:  * external name 'org.apache.derby.vti.XmlVTI.xmlVTI';
1:7f17ba1:  * </pre>
1:7f17ba1:  *
1:7f17ba1:  * <p>
1:7f17ba1:  * ...and here is a sample invocation:
1:7f17ba1:  * </p>
1:7f17ba1:  *
1:7f17ba1:  * <pre>
1:7f17ba1:  * create view findbugs as
1:7f17ba1:  * select *
1:7f17ba1:  * from table
1:7f17ba1:  * (
1:7f17ba1:  *      findbugs
1:7f17ba1:  *      (
1:3397f9f:  *          'findbugs.xml',
1:7f17ba1:  *          'ClassStats',
1:7f17ba1:  *          'class', 'bugs'
1:7f17ba1:  *      )
1:7f17ba1:  *  ) v;
1:7f17ba1:  * 
1:7f17ba1:  * select * from findbugs where bugCount != 0;
1:7f17ba1:  * </pre>
1:23643e8:  *
1:23643e8:  * <p>
1:23643e8:  * A second form of this VTI takes the following arguments. This form is useful when
1:23643e8:  * some of the columns in the row are "inherited" from outer elements inside which the
1:23643e8:  * row element nests:
1:23643e8:  * </p>
1:23643e8:  *
1:23643e8:  * <ul>
1:3397f9f:  * <li>xmlResourceName - The name of an xml file.</li>
1:23643e8:  * <li>rowTag - The tag of the element which contains the row-structured content.</li>
1:23643e8:  * <li>parentTags - Attributes and elements (to be treated as columns) from outer elements in which the rowTag is nested.</li>
1:23643e8:  * <li>childTags - Attributes and elements (to be treated as columns) inside the row element.</li>
1:23643e8:  * </ul>
1:23643e8:  *
1:23643e8:  *
1:23643e8:  * <p>
1:23643e8:  * Here is a sample declaration of this second form of the XmlVTI. Using the second form
1:23643e8:  * involves declaring an ArrayList type and a factory method too:
1:23643e8:  * </p>
1:23643e8:  *
1:23643e8:  * <pre>
1:23643e8:  * create type ArrayList external name 'java.util.ArrayList' language java;
1:23643e8:  * 
1:23643e8:  * create function asList( cell varchar( 32672 ) ... ) returns ArrayList
1:23643e8:  * language java parameter style derby no sql
1:23643e8:  * external name 'org.apache.derby.vti.XmlVTI.asList';
1:23643e8:  * 
1:23643e8:  * create function optTrace
1:23643e8:  * (
1:23643e8:  *     xmlResourceName varchar( 32672 ),
1:23643e8:  *     rowTag varchar( 32672 ),
1:23643e8:  *     parentTags ArrayList,
1:23643e8:  *     childTags ArrayList
1:23643e8:  * )
1:23643e8:  * returns table
1:23643e8:  * (
1:23643e8:  *     stmtID    int,
1:23643e8:  *     queryID   int,
1:23643e8:  *     complete  boolean,
1:23643e8:  *     summary   varchar( 32672 ),
1:23643e8:  *     type        varchar( 50 ),
1:23643e8:  *     estimatedCost        double,
1:23643e8:  *     estimatedRowCount    int
1:23643e8:  * )
1:23643e8:  * language java parameter style derby_jdbc_result_set no sql
1:23643e8:  * external name 'org.apache.derby.vti.XmlVTI.xmlVTI';
1:23643e8:  * 
1:23643e8:  * create view optTrace as
1:23643e8:  *        select *
1:23643e8:  *        from table
1:23643e8:  *        (
1:23643e8:  *             optTrace
1:23643e8:  *             (
1:3397f9f:  *                 '/Users/me/derby/mainline/z.xml',
1:23643e8:  *                 'planCost',
1:23643e8:  *                 asList( 'stmtID', 'queryID', 'complete' ),
1:23643e8:  *                 asList( 'summary', 'type', 'estimatedCost', 'estimatedRowCount' )
1:23643e8:  *             )
1:23643e8:  *         ) v
1:23643e8:  * ;
1:23643e8:  * 
1:23643e8:  * select * from optTrace
1:23643e8:  * where stmtID = 6 and complete
1:6f55de1:  * order by estimatedCost;
1:6f55de1:  * </pre>
1:7f17ba1:  */
1:7f17ba1: public  class   XmlVTI  extends StringColumnVTI
1:23e89eb: {
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1:     //
1:7f17ba1:     // CONSTANTS
1:7f17ba1:     //
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1: 
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1:     //
1:7f17ba1:     // STATE
1:7f17ba1:     //
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1: 
1:7f17ba1:     private String      _rowTag;
1:d08ab9b:     private InputStream _xmlResource;
1:7f17ba1: 
1:7f17ba1:     private int             _rowIdx = -1;
1:7f17ba1:     private int             _rowCount = -1;
1:7f17ba1:     private String[]    _currentRow;
1:7f17ba1:     
1:7f17ba1:     private DocumentBuilder _builder;
1:7f17ba1:     private NodeList    _rawRows;
1:7f17ba1: 
1:23643e8:     //
1:23643e8:     // The first n column names are attribute/element tags from parent
1:23643e8:     // elements. The trailing column names are attribute/element tags from
1:23643e8:     // the row element or its children.
1:23643e8:     //
1:23643e8:     private int     _firstChildTagIdx;  // first attribute/element to be found in the row or below
1:23643e8: 
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1:     //
1:7f17ba1:     // CONSTRUCTORS
1:7f17ba1:     //
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1: 
1:7f17ba1:     /**
1:7f17ba1:      * <p>
1:699ab55:      * Build an XmlVTI.
1:7f17ba1:      * </p>
1:699ab55:      *
1:699ab55:      * @param   xmlResource The xml source as an InputStream.
1:699ab55:      * @param   rowTag  The tag of the master row Element.
1:699ab55:      * @param   firstChildTagIdx    The first (0-based) tag from columnTags which is a child tag.
1:699ab55:      * @param   columnTags  The tags which supply column data; all of the tag positions less than firstChildTagIdx come from Elements which are outer to the rowTag element; the remaining tags, starting at firstChildTagIdx, are tags of attributes or Elements inside the rowTag Element.
1:7f17ba1:      */
1:d08ab9b:     public  XmlVTI( InputStream xmlResource, String rowTag, int firstChildTagIdx, String... columnTags )
1:23e89eb:     {
1:23643e8:         super( columnTags );
1:7f17ba1: 
1:d08ab9b:         _xmlResource = xmlResource;
1:7f17ba1:         _rowTag = rowTag;
1:23643e8:         _firstChildTagIdx = firstChildTagIdx;
7:7f17ba1:     }
1:7f17ba1:     
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1:     //
1:23643e8:     // ENTRY POINTS (SQL FUNCTIONS)
1:7f17ba1:     //
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:23643e8: 
1:d08ab9b:     /** This is the static method for creating functions from a file name and child tags */
1:d08ab9b:     public  static  XmlVTI  xmlVTI( String fileName, String rowTag, String... childTags )
1:d08ab9b:         throws Exception
1:23643e8:     {
1:d08ab9b:         return xmlVTI( fileName, rowTag, null, asList( childTags ) );
1:23643e8:     }
1:7f17ba1:     
1:d08ab9b:     /** This is the static method for creating functions from an url and child tags */
1:d08ab9b:     public  static  XmlVTI  xmlVTIFromURL( String urlString, String rowTag, String... childTags )
1:d08ab9b:         throws Exception
6:7f17ba1:     {
1:d08ab9b:         return xmlVTIFromURL( urlString, rowTag, null, asList( childTags ) );
1:d08ab9b:     }
1:d08ab9b:     
1:d08ab9b:     /** This is the static method for creating functions from a file name and both parent and child tags */
1:d08ab9b:     public  static  XmlVTI  xmlVTI
1:d08ab9b:         ( final String fileName, String rowTag, ArrayList<String> parentTags, ArrayList<String> childTags )
1:d08ab9b:         throws Exception
1:d08ab9b:     {
1:d08ab9b:         FileInputStream fis = AccessController.doPrivileged
1:d08ab9b:             (
1:d08ab9b:              new PrivilegedAction<FileInputStream>()
1:d08ab9b:              {
1:d08ab9b:                  public FileInputStream run()
1:d08ab9b:                  {
1:d08ab9b:                      try {
1:d08ab9b:                          return new FileInputStream( new File( fileName ) );
1:d08ab9b:                      }
1:d08ab9b:                      catch (IOException ioe) { throw new IllegalArgumentException( ioe.getMessage(), ioe ); }
1:d08ab9b:                  }  
1:d08ab9b:              }
1:d08ab9b:            );
1:d08ab9b:         return xmlVTI( fis, rowTag, parentTags, childTags );
1:d08ab9b:     }
1:d08ab9b: 
1:d08ab9b:     /** This is the static method for creating functions from an URL and both parent and child tags */
1:d08ab9b:     public  static  XmlVTI  xmlVTIFromURL
1:d08ab9b:         ( final String urlString, String rowTag, ArrayList<String> parentTags, ArrayList<String> childTags )
1:d08ab9b:         throws Exception
1:d08ab9b:     {
1:d08ab9b:         InputStream is = AccessController.doPrivileged
1:d08ab9b:             (
1:d08ab9b:              new PrivilegedAction<InputStream>()
1:d08ab9b:              {
1:d08ab9b:                  public InputStream run()
1:d08ab9b:                  {
1:d08ab9b:                      try {
1:d08ab9b:                          return (new URL( urlString )).openStream();
1:d08ab9b:                      }
1:d08ab9b:                      catch (IOException ioe) { throw new IllegalArgumentException( ioe.getMessage(), ioe ); }
1:d08ab9b:                  }  
1:d08ab9b:              }
1:d08ab9b:            );
1:d08ab9b:         return xmlVTI( is, rowTag, parentTags, childTags );
1:d08ab9b:     }
1:d08ab9b: 
1:d08ab9b:     /** This is the static method for creating functions from an URL and both parent and child tags */
1:d08ab9b:     private  static  XmlVTI  xmlVTI
1:d08ab9b:         ( InputStream xmlResource, String rowTag, ArrayList<String> parentTags, ArrayList<String> childTags )
1:d08ab9b:         throws Exception
1:d08ab9b:     {
1:d08ab9b:         if ( parentTags == null ) { parentTags = new ArrayList<String>(); }
1:d08ab9b:         if ( childTags == null ) { childTags = new ArrayList<String>(); }
1:d08ab9b:         
1:23643e8:         String[]    allTags = new String[ parentTags.size() + childTags.size() ];
1:23643e8:         int     idx = 0;
1:23643e8:         for ( String tag : parentTags ) { allTags[ idx++ ] = tag; }
1:23643e8:         for ( String tag : childTags ) { allTags[ idx++ ] = tag; }
1:23643e8:         
1:d08ab9b:         return new XmlVTI( xmlResource, rowTag, parentTags.size(), allTags );
1:23643e8:     }
1:23643e8: 
1:23643e8:     /** Factory method to create an ArrayList<String> */
1:23643e8:     public  static  ArrayList<String>   asList( String... cells )
1:23643e8:     {
1:23643e8:         ArrayList<String>   retval = new ArrayList<String>();
1:23643e8:         for ( String cell : cells ) { retval.add( cell ); }
1:23643e8:         
1:23643e8:         return retval;
1:7f17ba1:     }
1:7f17ba1:     
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1:     //
1:7f17ba1:     // StringColumnVTI BEHAVIOR TO BE IMPLEMENTED BY SUBCLASSES
1:7f17ba1:     //
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1: 
1:7f17ba1:     /**
1:7f17ba1:      * <p>
1:7f17ba1:      * Get the string value of the column in the current row identified by the 1-based columnNumber.
1:7f17ba1:      * </p>
1:7f17ba1:      */
1:7f17ba1:     protected  String  getRawColumn( int columnNumber ) throws SQLException
1:7f17ba1:     {
1:23e89eb:         try {
1:7f17ba1:             return  _currentRow[ columnNumber - 1 ];
1:7f17ba1:         } catch (Throwable t) { throw new SQLException( t.getMessage() ); }
1:7f17ba1:     }
1:7f17ba1:     
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1:     //
1:7f17ba1:     // ResultSet BEHAVIOR
1:7f17ba1:     //
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1: 
1:7f17ba1:     public  void close() throws SQLException
1:7f17ba1:     {
1:7f17ba1:         _builder = null;
1:7f17ba1:         _rawRows = null;
1:7f17ba1:     }
1:7f17ba1: 
1:7f17ba1:     public  ResultSetMetaData   getMetaData() throws SQLException
1:7f17ba1:     {
1:7f17ba1:         throw new SQLException( "Not implemented." );
1:7f17ba1:     }
1:7f17ba1:     
1:7f17ba1:     public  boolean next() throws SQLException
1:7f17ba1:     {
2:7f17ba1:         try {
1:7f17ba1:             if ( _rowIdx < 0 ) { readRows(); }
1:7f17ba1: 
1:7f17ba1:             if ( ++_rowIdx < _rowCount )
1:7f17ba1:             {
1:7f17ba1:                 parseRow( _rowIdx );
1:7f17ba1:                 return true;
1:7f17ba1:             }
1:7f17ba1:             else { return false; }
1:7f17ba1:         } catch (Throwable t)
1:7f17ba1:         {
1:7ed0ef0:             throw new SQLException( t.getMessage(), t );
1:7f17ba1:         }
1:7f17ba1:     }
1:7f17ba1: 
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1:     //
1:7f17ba1:     // MINIONS
1:7f17ba1:     //
1:7f17ba1:     ///////////////////////////////////////////////////////////////////////////////////
1:7f17ba1: 
1:7f17ba1:     //////////////////////////
1:7f17ba1:     //
1:7f17ba1:     // XML MINIONS
1:7f17ba1:     //
1:7f17ba1:     //////////////////////////
1:7f17ba1: 
1:7f17ba1:     /**
1:7f17ba1:      * <p>
1:7f17ba1:      * Fault in the list of rows.
1:7f17ba1:      * </p>
1:7f17ba1:      */
1:23643e8:     private    void    readRows() throws Exception
1:7f17ba1:     {
1:7f17ba1:         DocumentBuilderFactory  factory = DocumentBuilderFactory.newInstance();
1:7f17ba1:         
1:7643f96: 	    factory.setFeature( XMLConstants.FEATURE_SECURE_PROCESSING, true );
1:7643f96: 	    factory.setFeature(
1:7643f96:             "http://xml.org/sax/features/external-general-entities", false );
1:7643f96: 
1:7f17ba1:         _builder = factory.newDocumentBuilder();
1:7ed0ef0:         _builder.setErrorHandler(new XMLErrorHandler());
1:7f17ba1: 
1:d08ab9b:         Document        doc = _builder.parse( _xmlResource );
1:d08ab9b:         Element             root = doc.getDocumentElement();
1:23e89eb:                          
1:d08ab9b:         _rawRows = root.getElementsByTagName( _rowTag );
1:d08ab9b:         _rowCount = _rawRows.getLength();
1:23e89eb:                          
1:d08ab9b:         _xmlResource.close();
1:23e89eb:     }
1:23e89eb:     
1:7f17ba1:     /**
1:7f17ba1:      * <p>
1:7f17ba1:      * Parse a row into columns.
1:7f17ba1:      * </p>
1:7f17ba1:      */
1:23643e8:     private    void    parseRow( int rowNumber ) throws Exception
1:7f17ba1:     {
1:7f17ba1:         Element         rawRow = (Element) _rawRows.item( rowNumber );
1:7f17ba1:         int                 columnCount = getColumnCount();
1:7f17ba1:         
1:7f17ba1:         _currentRow = new String[ columnCount ];
1:7f17ba1: 
1:7f17ba1:         for ( int i = 0; i < columnCount; i++ )
1:7f17ba1:         {
1:23643e8:             _currentRow[ i ] = findColumnValue( rawRow, i );
1:23e89eb:         }
1:23e89eb:     }
1:23643e8: 
1:23643e8:     /**
1:23643e8:      * <p>
1:23643e8:      * Find the value of a column inside an element. The columnNumber is 0-based.
1:23643e8:      * </p>
1:23643e8:      */
1:23643e8:     private String  findColumnValue( Element rawRow, int columnNumber )
1:23643e8:         throws Exception
1:23643e8:     {
1:23643e8:         // handle tags which are supposed to come from outer elements
1:23643e8:         boolean     inParent = (columnNumber < _firstChildTagIdx);
1:23643e8:         if ( inParent )
1:23643e8:         {
1:23643e8:             Node    parent = rawRow.getParentNode();
1:23643e8:             if ( (parent == null ) || !( parent instanceof Element) ) { return null; }
1:23643e8:             else { rawRow = (Element) parent; }
1:23643e8:         }
1:23643e8:         
1:23643e8:         // first look for an attribute by the column name
1:23643e8:         String      columnName = getColumnName( columnNumber + 1 );
1:23643e8:         String      contents = rawRow.getAttribute( columnName );
1:23643e8: 
1:23643e8:         // missing attributes turn up as empty strings. make them null instead
1:23643e8:         if ( "".equals( contents ) ) { contents = null; }
1:23643e8: 
1:23643e8:         // if there is not attribute by that name, then look for descendent elements by
1:23643e8:         // that name. concatenate them all.
1:23643e8:         if ( contents == null )
1:23643e8:         {
1:23643e8:             NodeList    children = rawRow.getElementsByTagName( columnName );
1:23643e8: 
1:23643e8:             if ( (children != null) && (children.getLength() > 0) )
1:23643e8:             {
1:23643e8:                 int                 childCount = children.getLength();
1:23643e8:                 StringBuilder    buffer = new StringBuilder();
1:23643e8: 
1:23643e8:                 for ( int j = 0; j < childCount; j++ )
1:23643e8:                 {
1:23643e8:                     Element     child = (Element) children.item( j );
1:23643e8:                     // separate values with spaces.
1:23643e8:                     if (j != 0){ buffer.append(" "); }
1:23643e8:                     buffer.append( squeezeText( child ) );
1:23643e8:                 }
1:23643e8:                 contents = buffer.toString();
1:23643e8:             }
1:23643e8:         }
1:23643e8: 
1:23643e8:         // recurse if looking in parent element
1:23643e8:         if ( inParent && (contents == null) ) { return findColumnValue( rawRow, columnNumber ); }
1:23643e8:         else { return contents; }
1:23643e8:     }
1:7f17ba1:     
1:7f17ba1:     /**
1:7f17ba1:      * <p>
1:7f17ba1:      * Squeeze the text out of an Element.
1:7f17ba1:      * </p>
1:7f17ba1:      */
1:7f17ba1:     private String squeezeText( Element node )
1:7f17ba1:         throws Exception
1:7f17ba1:     {
1:7f17ba1:         String      text = null;
1:7f17ba1:         Node        textChild = node.getFirstChild();
1:7f17ba1: 
1:7f17ba1:         if ( textChild != null ) { text = textChild.getNodeValue(); }
1:7f17ba1: 
1:7f17ba1:         return text;
1:7f17ba1:     }
1:7f17ba1: 
1:7f17ba1: 
1:7ed0ef0:     /*
1:7ed0ef0:      ** The XMLErrorHandler class is just a generic implementation
1:7ed0ef0:      ** of the ErrorHandler interface.  It allows us to catch
1:7ed0ef0:      ** and process XML parsing errors in a graceful manner.
1:7ed0ef0:      */
1:7ed0ef0:     private class XMLErrorHandler implements ErrorHandler
1:7ed0ef0:     {
1:7ed0ef0:         private void closeInput()
1:7ed0ef0:         {
1:7ed0ef0:             try
1:7ed0ef0:             {
1:7ed0ef0:                 if( _xmlResource != null )
1:7ed0ef0:                     _xmlResource.close();
1:7ed0ef0:             }
1:7ed0ef0:             catch (Exception ex)
1:7ed0ef0:             {
1:7ed0ef0:             }
1:7ed0ef0:         }
1:7ed0ef0: 
1:7ed0ef0:         public void error (SAXParseException exception)
1:7ed0ef0:             throws SAXException
1:7ed0ef0:         {
1:7ed0ef0:             closeInput();
1:7ed0ef0:             throw new SAXException (exception);
1:7ed0ef0:         }
1:7ed0ef0: 
1:7ed0ef0:         public void fatalError (SAXParseException exception)
1:7ed0ef0:             throws SAXException
1:7ed0ef0:         {
1:7ed0ef0:             closeInput();
1:7ed0ef0:             throw new SAXException (exception);
1:7ed0ef0:         }
1:7ed0ef0: 
1:7ed0ef0:         public void warning (SAXParseException exception)
1:7ed0ef0:             throws SAXException
1:7ed0ef0:         {
1:7ed0ef0:             closeInput();
1:7ed0ef0:             throw new SAXException (exception);
1:7ed0ef0:         }
1:7ed0ef0:     }
1:7ed0ef0: 
1:7f17ba1: }
1:7f17ba1: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7643f96
/////////////////////////////////////////////////////////////////////////
1: import javax.xml.XMLConstants;
/////////////////////////////////////////////////////////////////////////
1:  * <p>
1:  * XML files parsed by this VTI are always processed with external entity
1:  * expansion disabled and secure parser processing enabled.
1:  * <p>
1:  * There are two invocation formats provided by this VTI.
1:  * <p>
/////////////////////////////////////////////////////////////////////////
1: 	    factory.setFeature( XMLConstants.FEATURE_SECURE_PROCESSING, true );
1: 	    factory.setFeature(
1:             "http://xml.org/sax/features/external-general-entities", false );
1: 
commit:7ed0ef0
/////////////////////////////////////////////////////////////////////////
1: import org.xml.sax.ErrorHandler;
1: import org.xml.sax.SAXParseException;
/////////////////////////////////////////////////////////////////////////
1:             throw new SQLException( t.getMessage(), t );
/////////////////////////////////////////////////////////////////////////
1:         _builder.setErrorHandler(new XMLErrorHandler());
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      ** The XMLErrorHandler class is just a generic implementation
1:      ** of the ErrorHandler interface.  It allows us to catch
1:      ** and process XML parsing errors in a graceful manner.
1:      */
1:     private class XMLErrorHandler implements ErrorHandler
1:     {
1:         private void closeInput()
1:         {
1:             try
1:             {
1:                 if( _xmlResource != null )
1:                     _xmlResource.close();
1:             }
1:             catch (Exception ex)
1:             {
1:             }
1:         }
1: 
1:         public void error (SAXParseException exception)
1:             throws SAXException
1:         {
1:             closeInput();
1:             throw new SAXException (exception);
1:         }
1: 
1:         public void fatalError (SAXParseException exception)
1:             throws SAXException
1:         {
1:             closeInput();
1:             throw new SAXException (exception);
1:         }
1: 
1:         public void warning (SAXParseException exception)
1:             throws SAXException
1:         {
1:             closeInput();
1:             throw new SAXException (exception);
1:         }
1:     }
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:699ab55
/////////////////////////////////////////////////////////////////////////
1:      * Build an XmlVTI.
1:      *
1:      * @param   xmlResource The xml source as an InputStream.
1:      * @param   rowTag  The tag of the master row Element.
1:      * @param   firstChildTagIdx    The first (0-based) tag from columnTags which is a child tag.
1:      * @param   columnTags  The tags which supply column data; all of the tag positions less than firstChildTagIdx come from Elements which are outer to the rowTag element; the remaining tags, starting at firstChildTagIdx, are tags of attributes or Elements inside the rowTag Element.
commit:6f55de1
/////////////////////////////////////////////////////////////////////////
1:  * order by estimatedCost;
1:  * </pre>
commit:d08ab9b
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
1:     private InputStream _xmlResource;
/////////////////////////////////////////////////////////////////////////
0:      * Build a XmlVTI given an xml resource stream, the  tag of the row
1:     public  XmlVTI( InputStream xmlResource, String rowTag, int firstChildTagIdx, String... columnTags )
1:         _xmlResource = xmlResource;
/////////////////////////////////////////////////////////////////////////
1:     /** This is the static method for creating functions from a file name and child tags */
1:     public  static  XmlVTI  xmlVTI( String fileName, String rowTag, String... childTags )
1:         throws Exception
1:         return xmlVTI( fileName, rowTag, null, asList( childTags ) );
1:     /** This is the static method for creating functions from an url and child tags */
1:     public  static  XmlVTI  xmlVTIFromURL( String urlString, String rowTag, String... childTags )
1:         throws Exception
1:         return xmlVTIFromURL( urlString, rowTag, null, asList( childTags ) );
1:     }
1:     
1:     /** This is the static method for creating functions from a file name and both parent and child tags */
1:     public  static  XmlVTI  xmlVTI
1:         ( final String fileName, String rowTag, ArrayList<String> parentTags, ArrayList<String> childTags )
1:         throws Exception
1:     {
1:         FileInputStream fis = AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<FileInputStream>()
1:              {
1:                  public FileInputStream run()
1:                  {
1:                      try {
1:                          return new FileInputStream( new File( fileName ) );
1:                      }
1:                      catch (IOException ioe) { throw new IllegalArgumentException( ioe.getMessage(), ioe ); }
1:                  }  
1:              }
1:            );
1:         return xmlVTI( fis, rowTag, parentTags, childTags );
1:     }
1: 
1:     /** This is the static method for creating functions from an URL and both parent and child tags */
1:     public  static  XmlVTI  xmlVTIFromURL
1:         ( final String urlString, String rowTag, ArrayList<String> parentTags, ArrayList<String> childTags )
1:         throws Exception
1:     {
1:         InputStream is = AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<InputStream>()
1:              {
1:                  public InputStream run()
1:                  {
1:                      try {
1:                          return (new URL( urlString )).openStream();
1:                      }
1:                      catch (IOException ioe) { throw new IllegalArgumentException( ioe.getMessage(), ioe ); }
1:                  }  
1:              }
1:            );
1:         return xmlVTI( is, rowTag, parentTags, childTags );
1:     }
1: 
1:     /** This is the static method for creating functions from an URL and both parent and child tags */
1:     private  static  XmlVTI  xmlVTI
1:         ( InputStream xmlResource, String rowTag, ArrayList<String> parentTags, ArrayList<String> childTags )
1:         throws Exception
1:     {
1:         if ( parentTags == null ) { parentTags = new ArrayList<String>(); }
1:         if ( childTags == null ) { childTags = new ArrayList<String>(); }
1:         
1:         return new XmlVTI( xmlResource, rowTag, parentTags.size(), allTags );
/////////////////////////////////////////////////////////////////////////
1:         Document        doc = _builder.parse( _xmlResource );
1:         Element             root = doc.getDocumentElement();
1:         _rawRows = root.getElementsByTagName( _rowTag );
1:         _rowCount = _rawRows.getLength();
1:         _xmlResource.close();
commit:23e89eb
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.xml.sax.SAXException;
/////////////////////////////////////////////////////////////////////////
0:         AccessController.doPrivileged
0:             (
0:              new PrivilegedAction<Object>()
1:              {
0:                  public Object run()
1:                  {
1:                      try {
0:                          File                file = new File( _xmlResourceName );
0:                          FileInputStream     is = new FileInputStream( file );
0:                          Document        doc = _builder.parse( is );
0:                          Element             root = doc.getDocumentElement();
1:                          
0:                          _rawRows = root.getElementsByTagName( _rowTag );
0:                          _rowCount = _rawRows.getLength();
1:                          
0:                          is.close();
1:                          
0:                          return null;
1:                      }
0:                      catch (IOException ioe) { throw new IllegalArgumentException( ioe.getMessage(), ioe ); }
0:                      catch (SAXException ioe) { throw new IllegalArgumentException( ioe.getMessage(), ioe ); }
1:                  }  
1:              }
0:            );
commit:3397f9f
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.FileInputStream;
/////////////////////////////////////////////////////////////////////////
1:  * <li>xmlResourceName - The name of an xml file.</li>
/////////////////////////////////////////////////////////////////////////
1:  *          'findbugs.xml',
/////////////////////////////////////////////////////////////////////////
1:  * <li>xmlResourceName - The name of an xml file.</li>
/////////////////////////////////////////////////////////////////////////
1:  *                 '/Users/me/derby/mainline/z.xml',
/////////////////////////////////////////////////////////////////////////
0:         File                file = new File( _xmlResourceName );
0:         FileInputStream     is = new FileInputStream( file );
commit:23643e8
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStream;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.util.ArrayList;
1: import javax.xml.parsers.DocumentBuilder;
1: import javax.xml.parsers.DocumentBuilderFactory;
1: import org.w3c.dom.Document;
1: import org.w3c.dom.Element;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.NodeList;
1:  * One form of this VTI takes the following arguments. This form is useful when
1:  * all of the columns in the row can be constructed from data nested INSIDE the row Element.
/////////////////////////////////////////////////////////////////////////
1:  * Here is a sample declaration of this first form of the XmlVTI:
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * <p>
1:  * A second form of this VTI takes the following arguments. This form is useful when
1:  * some of the columns in the row are "inherited" from outer elements inside which the
1:  * row element nests:
1:  * </p>
1:  *
1:  * <ul>
0:  * <li>xmlResourceName - An URL identifying an xml resource.</li>
1:  * <li>rowTag - The tag of the element which contains the row-structured content.</li>
1:  * <li>parentTags - Attributes and elements (to be treated as columns) from outer elements in which the rowTag is nested.</li>
1:  * <li>childTags - Attributes and elements (to be treated as columns) inside the row element.</li>
1:  * </ul>
1:  *
1:  *
1:  * <p>
1:  * Here is a sample declaration of this second form of the XmlVTI. Using the second form
1:  * involves declaring an ArrayList type and a factory method too:
1:  * </p>
1:  *
1:  * <pre>
1:  * create type ArrayList external name 'java.util.ArrayList' language java;
1:  * 
1:  * create function asList( cell varchar( 32672 ) ... ) returns ArrayList
1:  * language java parameter style derby no sql
1:  * external name 'org.apache.derby.vti.XmlVTI.asList';
1:  * 
1:  * create function optTrace
1:  * (
1:  *     xmlResourceName varchar( 32672 ),
1:  *     rowTag varchar( 32672 ),
1:  *     parentTags ArrayList,
1:  *     childTags ArrayList
1:  * )
1:  * returns table
1:  * (
1:  *     stmtID    int,
1:  *     queryID   int,
1:  *     complete  boolean,
1:  *     summary   varchar( 32672 ),
1:  *     type        varchar( 50 ),
1:  *     estimatedCost        double,
1:  *     estimatedRowCount    int
1:  * )
1:  * language java parameter style derby_jdbc_result_set no sql
1:  * external name 'org.apache.derby.vti.XmlVTI.xmlVTI';
1:  * 
1:  * create view optTrace as
1:  *        select *
1:  *        from table
1:  *        (
1:  *             optTrace
1:  *             (
0:  *                 'file:///Users/me/derby/mainline/z.xml',
1:  *                 'planCost',
1:  *                 asList( 'stmtID', 'queryID', 'complete' ),
1:  *                 asList( 'summary', 'type', 'estimatedCost', 'estimatedRowCount' )
1:  *             )
1:  *         ) v
1:  * ;
1:  * 
1:  * select * from optTrace
1:  * where stmtID = 6 and complete
0:  * order by estimatedCost * </pre>
/////////////////////////////////////////////////////////////////////////
1:     //
1:     // The first n column names are attribute/element tags from parent
1:     // elements. The trailing column names are attribute/element tags from
1:     // the row element or its children.
1:     //
1:     private int     _firstChildTagIdx;  // first attribute/element to be found in the row or below
1: 
/////////////////////////////////////////////////////////////////////////
0:     public  XmlVTI( String xmlResourceName, String rowTag, int firstChildTagIdx, String... columnTags )
1:         super( columnTags );
1:         _firstChildTagIdx = firstChildTagIdx;
1:     // ENTRY POINTS (SQL FUNCTIONS)
0:     /** This is the static method for creating functions with only child tags */
0:         return new XmlVTI( xmlResourceName, rowTag, 0, childTags );
1:     }
1:     
0:     /** This is the static method for creating functions with both parent and child tags */
0:     public  static  XmlVTI  xmlVTI
0:         ( String xmlResourceName, String rowTag, ArrayList<String> parentTags, ArrayList<String> childTags )
1:     {
1:         String[]    allTags = new String[ parentTags.size() + childTags.size() ];
1:         int     idx = 0;
1:         for ( String tag : parentTags ) { allTags[ idx++ ] = tag; }
1:         for ( String tag : childTags ) { allTags[ idx++ ] = tag; }
1:         
0:         return new XmlVTI( xmlResourceName, rowTag, parentTags.size(), allTags );
1:     }
1: 
1:     /** Factory method to create an ArrayList<String> */
1:     public  static  ArrayList<String>   asList( String... cells )
1:     {
1:         ArrayList<String>   retval = new ArrayList<String>();
1:         for ( String cell : cells ) { retval.add( cell ); }
1:         
1:         return retval;
/////////////////////////////////////////////////////////////////////////
1:     private    void    readRows() throws Exception
/////////////////////////////////////////////////////////////////////////
1:     private    void    parseRow( int rowNumber ) throws Exception
/////////////////////////////////////////////////////////////////////////
1:             _currentRow[ i ] = findColumnValue( rawRow, i );
1: 
1:     /**
1:      * <p>
1:      * Find the value of a column inside an element. The columnNumber is 0-based.
1:      * </p>
1:      */
1:     private String  findColumnValue( Element rawRow, int columnNumber )
1:         throws Exception
1:     {
1:         // handle tags which are supposed to come from outer elements
1:         boolean     inParent = (columnNumber < _firstChildTagIdx);
1:         if ( inParent )
1:         {
1:             Node    parent = rawRow.getParentNode();
1:             if ( (parent == null ) || !( parent instanceof Element) ) { return null; }
1:             else { rawRow = (Element) parent; }
1:         }
1:         
1:         // first look for an attribute by the column name
1:         String      columnName = getColumnName( columnNumber + 1 );
1:         String      contents = rawRow.getAttribute( columnName );
1: 
1:         // missing attributes turn up as empty strings. make them null instead
1:         if ( "".equals( contents ) ) { contents = null; }
1: 
1:         // if there is not attribute by that name, then look for descendent elements by
1:         // that name. concatenate them all.
1:         if ( contents == null )
1:         {
1:             NodeList    children = rawRow.getElementsByTagName( columnName );
1: 
1:             if ( (children != null) && (children.getLength() > 0) )
1:             {
1:                 int                 childCount = children.getLength();
1:                 StringBuilder    buffer = new StringBuilder();
1: 
1:                 for ( int j = 0; j < childCount; j++ )
1:                 {
1:                     Element     child = (Element) children.item( j );
1:                     // separate values with spaces.
1:                     if (j != 0){ buffer.append(" "); }
1:                     buffer.append( squeezeText( child ) );
1:                 }
1:                 contents = buffer.toString();
1:             }
1:         }
1: 
1:         // recurse if looking in parent element
1:         if ( inParent && (contents == null) ) { return findColumnValue( rawRow, columnNumber ); }
1:         else { return contents; }
1:     }
commit:7f17ba1
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derby.vti.XmlVTI
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.vti;
1: 
0: import java.io.*;
0: import java.lang.reflect.*;
0: import java.net.URL;
0: import java.sql.*;
1: import java.text.DateFormat;
1: import java.text.ParseException;
0: import javax.xml.parsers.*;
0: import org.w3c.dom.*;
1: 
1: /**
1:  * <p>
1:  * This is a VTI designed to read XML files which are structured like row sets.
0:  * This VTI takes the following arguments:
1:  * </p>
1:  *
1:  * <ul>
0:  * <li>xmlResourceName - An URL identifying an xml resource.</li>
1:  * <li>rowTag - The tag of the element which contains the row-structured content.</li>
1:  * <li>childTags - The attributes and descendant elements inside the row element which should be treated as columns.</li>
1:  * </ul>
1:  *
1:  * <p>
0:  * Here is a sample declaration:
1:  * </p>
1:  *
1:  * <pre>
1:  * create function findbugs( xmlResourceName varchar( 32672 ), rowTag varchar( 32672 ), childTags varchar( 32672 )... )
1:  * returns table
1:  * (
1:  *      className   varchar( 32672 ),
1:  *      bugCount    int
1:  * )
1:  * language java parameter style derby_jdbc_result_set no sql
1:  * external name 'org.apache.derby.vti.XmlVTI.xmlVTI';
1:  * </pre>
1:  *
1:  * <p>
1:  * ...and here is a sample invocation:
1:  * </p>
1:  *
1:  * <pre>
1:  * create view findbugs as
1:  * select *
1:  * from table
1:  * (
1:  *      findbugs
1:  *      (
0:  *          'file:///Users/me/static-analysis/findbugs.xml',
1:  *          'ClassStats',
1:  *          'class', 'bugs'
1:  *      )
1:  *  ) v;
1:  * 
1:  * select * from findbugs where bugCount != 0;
1:  * </pre>
1:  */
1: public  class   XmlVTI  extends StringColumnVTI
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private String      _rowTag;
0:     private String      _xmlResourceName;
1: 
1:     private int             _rowIdx = -1;
1:     private int             _rowCount = -1;
1:     private String[]    _currentRow;
1:     
1:     private DocumentBuilder _builder;
1:     private NodeList    _rawRows;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTORS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
0:      * Build a XmlVTI given the name of an xml resource, the  tag of the row
0:      * element, and an array of attribute-names/element-tags underneath the row element
1:      * </p>
1:      */
0:     public  XmlVTI( String xmlResourceName, String rowTag, String... childTags )
1:     {
0:         super( childTags );
1: 
0:         _xmlResourceName = xmlResourceName;
1:         _rowTag = rowTag;
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
0:     // ENTRY POINT (SQL FUNCTION)
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
0:     /** This is the static method bound to the function */
0:     public  static  XmlVTI  xmlVTI( String xmlResourceName, String rowTag, String... childTags )
1:     {
0:         return new XmlVTI( xmlResourceName, rowTag, childTags );
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // StringColumnVTI BEHAVIOR TO BE IMPLEMENTED BY SUBCLASSES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Get the string value of the column in the current row identified by the 1-based columnNumber.
1:      * </p>
1:      */
1:     protected  String  getRawColumn( int columnNumber ) throws SQLException
1:     {
1:         try {
1:             return  _currentRow[ columnNumber - 1 ];
1:         } catch (Throwable t) { throw new SQLException( t.getMessage() ); }
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // ResultSet BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public  void close() throws SQLException
1:     {
1:         _builder = null;
1:         _rawRows = null;
1:     }
1: 
1:     public  ResultSetMetaData   getMetaData() throws SQLException
1:     {
1:         throw new SQLException( "Not implemented." );
1:     }
1:     
1:     public  boolean next() throws SQLException
1:     {
1:         try {
1:             if ( _rowIdx < 0 ) { readRows(); }
1: 
1:             if ( ++_rowIdx < _rowCount )
1:             {
1:                 parseRow( _rowIdx );
1:                 return true;
1:             }
1:             else { return false; }
1:         } catch (Throwable t)
1:         {
0:             t.printStackTrace( System.out );
0:             throw new SQLException( t.getMessage() );
1:         }
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     //////////////////////////
1:     //
1:     // XML MINIONS
1:     //
1:     //////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Fault in the list of rows.
1:      * </p>
1:      */
0:      private    void    readRows() throws Exception
1:     {
1:         DocumentBuilderFactory  factory = DocumentBuilderFactory.newInstance();
1:         
1:         _builder = factory.newDocumentBuilder();
1: 
0:         URL                 url = new URL( _xmlResourceName );
0:         InputStream     is = url.openStream();
0:         Document        doc = _builder.parse( is );
0:         Element             root = doc.getDocumentElement();
1: 
0:         _rawRows = root.getElementsByTagName( _rowTag );
0:         _rowCount = _rawRows.getLength();
1: 
0:         is.close();
1:     }
1:     
1:     /**
1:      * <p>
1:      * Parse a row into columns.
1:      * </p>
1:      */
0:      private    void    parseRow( int rowNumber ) throws Exception
1:     {
1:         Element         rawRow = (Element) _rawRows.item( rowNumber );
1:         int                 columnCount = getColumnCount();
1:         
1:         _currentRow = new String[ columnCount ];
1: 
1:         for ( int i = 0; i < columnCount; i++ )
1:         {
0:             // first look for an attribute by the column name
0:             String      columnName = getColumnName( i + 1 );
0:             String      contents = rawRow.getAttribute( columnName );
1: 
0:             // if there is not attribute by that name, then look for descendent elements by
0:             // that name. concatenate them all.
0:             if ( (contents == null) ||  "".equals( contents ) )
1:             {
0:                 NodeList    children = rawRow.getElementsByTagName( columnName );
1: 
0:                 if ( (children != null) && (children.getLength() > 0) )
1:                 {
0:                     int                 childCount = children.getLength();
0:                     StringBuffer    buffer = new StringBuffer();
1: 
0:                     for ( int j = 0; j < childCount; j++ )
1:                     {
0:                         Element     child = (Element) children.item( j );
0:                         // separate values with spaces.
0:                         if (j != 0)
0:                             buffer.append(" ");
0:                         buffer.append( squeezeText( child ) );
1:                     }
0:                     contents = buffer.toString();
1:                 }
1:             }
1: 
0:             _currentRow[ i ] = contents;
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Squeeze the text out of an Element.
1:      * </p>
1:      */
1:     private String squeezeText( Element node )
1:         throws Exception
1:     {
1:         String      text = null;
1:         Node        textChild = node.getFirstChild();
1: 
1:         if ( textChild != null ) { text = textChild.getNodeValue(); }
1: 
1:         return text;
1:     }
1: 
1: 
1: }
1: 
============================================================================