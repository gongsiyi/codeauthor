1:67614ad: /*
1:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.harness.SimpleDiff
1:67614ad: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
69:f68f62f: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:f68f62f: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:f68f62f: 
2:67614ad:  */
1:67614ad: 
1:67614ad: //SimpleDiff.java
1:67614ad: package org.apache.derbyTesting.functionTests.harness;
1:67614ad: 
1:67614ad: import java.io.IOException;
1:67614ad: import java.io.BufferedInputStream;
1:67614ad: import java.util.Vector;
1:67614ad: import java.io.File;
1:67614ad: import java.io.PrintWriter;
1:67614ad: import java.io.BufferedReader;
1:67614ad: import java.io.FileReader;
1:67614ad: 
1:67614ad: public class SimpleDiff
1:67614ad: {
1:67614ad: 
1:67614ad:     PrintWriter pw;
1:67614ad: 
1:67614ad:     boolean debugOn = Boolean.getBoolean("simplediff.debug");
1:67614ad:     int debugLevel = 1;
1:67614ad: 
1:67614ad:     boolean diffsFound = true;
1:67614ad: 
1:67614ad:     int lookAhead = 20;
1:67614ad: 
1:67614ad:     public void debug(int level, String msg)
1:67614ad:     {
1:67614ad:         if (debugLevel >= level)
1:67614ad:         {
1:67614ad:             debug(msg);
1:67614ad:         }
1:67614ad:     }
1:67614ad:     public void debug(String msg)
1:67614ad:     {
1:67614ad:         if (debugOn)
1:67614ad:         {
1:67614ad:             System.out.println("DEBUG: " + msg);
1:67614ad:         }
1:67614ad:     }
1:67614ad: 
1:67614ad:     int lineCount(String file) throws IOException
1:67614ad:     {
1:67614ad:         BufferedReader input = new BufferedReader(new FileReader(file));
1:67614ad:         int count = 0;
1:67614ad:         String aLine = input.readLine();
1:67614ad:         while (aLine != null)
1:67614ad:         {
1:67614ad:             count++;
1:67614ad:             aLine = input.readLine();
1:67614ad:         }
1:67614ad:         input.close();
1:67614ad:         return count;
1:67614ad:     }
1:67614ad: 
1:67614ad: 
1:67614ad:     public String[] readFile(BufferedReader input) throws IOException
1:67614ad:     {
1:67614ad: 
1:3f5c48a:         Vector<String> vec = new Vector<String>();
1:67614ad: 
1:67614ad:         String aLine = "";
1:67614ad:         //int count = 0;
1:67614ad:         aLine = input.readLine();
1:67614ad:         while (aLine != null)
1:67614ad:         {
1:67614ad:             vec.addElement(aLine);
1:67614ad:             //count++;
1:67614ad:             aLine = input.readLine();
1:67614ad:         }
1:67614ad:         input.close();
1:67614ad: 
1:67614ad:         String rV[] = new String[vec.size()];
1:67614ad:         //debug(2, ""+count + " lines in " + filename);
1:67614ad:         debug(2, ""+vec.size() + " lines in input");
1:67614ad:         vec.copyInto(rV);
1:67614ad: 
1:67614ad:         return rV;
1:67614ad:     }
1:67614ad: 
1:67614ad:     public void printFile(String file[])
1:67614ad:     {
1:67614ad:         for (int i = 0; i < file.length; i++)
1:67614ad:         {
1:67614ad:             pw.println(i + ": " + file[i]);
1:67614ad:             System.out.println(i + ": " + file[i]);
1:67614ad:         }
1:67614ad:     }
1:67614ad: 
1:67614ad:     public static String usage = "java SimpleDiff <file1> <file2>";
1:67614ad: 
2:67614ad:     /**
1:df4020d:         @param file1 Name of first file to be read
1:df4020d:         @param file2 Name of file with which to compare
1:67614ad:         @return String array of file contents
1:67614ad:         @exception IOException thrown by underlying calls
1:67614ad:             to the file system
1:67614ad:     */
1:67614ad: 
1:67614ad:     public String[] diffFiles(  DiffBuffer file1,
1:67614ad:                                 DiffBuffer file2)
1:67614ad:                                 throws IOException
1:67614ad:     {
1:67614ad: 
1:67614ad:         int currentLine1 = 0;
1:67614ad:         int currentLine2 = 0;
1:3f5c48a:         Vector<String> returnVec = new Vector<String>();
1:67614ad: 
1:67614ad:         while ( file1.isValidOffset(currentLine1) &&
1:67614ad:                 file2.isValidOffset(currentLine2))
1:67614ad:         {
1:67614ad:             String f1 = file1.lineAt(currentLine1);
1:67614ad:             String f2 = file2.lineAt(currentLine2);
1:67614ad: 
1:67614ad:             if (f1.equals(f2))
1:67614ad:             {
1:67614ad:                 debug(1, currentLine1 + ": match");
1:67614ad:                 currentLine1++;
1:67614ad:                 currentLine2++;
1:67614ad:                 file1.setLowWater(currentLine1);
1:67614ad:                 file2.setLowWater(currentLine2);
1:67614ad:             }
1:67614ad:             else
1:67614ad:             {
1:67614ad:                 boolean foundMatch = false;
1:67614ad:                 int checkLine2 = currentLine2;
1:67614ad:                 int checkCount = 1;
1:67614ad: //                while ( (currentLine2 + checkCount) < (file2Length - 1) &&
1:67614ad:                 while ( file2.isValidOffset(currentLine2 + checkCount) &&
1:67614ad:                         checkCount < lookAhead)
1:67614ad:                 {
1:67614ad:                     debug(1, "currentLine1 " + currentLine1 + "  currentLine2 " + (currentLine2 +checkCount));
1:67614ad:                     debug(1, "about to reference file2[" + (currentLine2 + checkCount) + "]");
1:67614ad:                     f2 = file2.lineAt(currentLine2 + checkCount);
1:67614ad:                     debug(2, "did");
1:67614ad:                     if (f1.equals(f2))
1:67614ad:                     {
1:67614ad:                         foundMatch = true;
1:67614ad:                         if (checkCount > 1)
1:67614ad:                         {
1:67614ad:                             returnVec.addElement(currentLine1 + "a" + (currentLine2 + 1) + "," + (currentLine2 + checkCount));
1:67614ad:                         }
1:67614ad:                         else
1:67614ad:                         {
1:67614ad:                             returnVec.addElement(currentLine1 + "a" + (currentLine2 + 1));
1:67614ad:                         }
1:67614ad: 
1:67614ad:                         for (int j = 0; j < checkCount; j++)
1:67614ad:                         {
1:67614ad:                             returnVec.addElement("> " +
1:67614ad:                                   file2.lineAt(currentLine2 + j) );
1:67614ad:                         }
1:67614ad:                         currentLine2 = currentLine2 + checkCount;
1:67614ad:                         checkCount = 0;
1:67614ad: 
1:67614ad: 						// This break statement was commented out, which
1:67614ad: 						// caused problems in the diff output.  I don't
1:67614ad: 						// know why it was commented out, and uncommenting
1:67614ad: 						// it fixed the problem.
1:67614ad: 						//
1:67614ad: 						//			-	Jeff Lichtman
1:67614ad: 						//				March 24, 1999
1:67614ad:                         break;
1:67614ad:                     }
1:67614ad:                     checkCount ++;
1:67614ad:                 }
1:67614ad:                 if (!foundMatch && file2.isValidOffset(currentLine2))
1:67614ad:                 {
1:67614ad:                     int checkLine1 = currentLine1;
1:67614ad:                     checkCount = 1;
1:67614ad:                     f2 = file2.lineAt(currentLine2);
1:67614ad:                     while ( file1.isValidOffset(currentLine1 + checkCount) &&
1:67614ad:                             checkCount < lookAhead)
1:67614ad:                     {
1:67614ad:                         debug(1, "currentLine2 " + currentLine2 + "  currentLine1 " + (currentLine1 + checkCount));
1:67614ad:                         f1 = file1.lineAt(currentLine1 + checkCount);
1:67614ad:                         if ( f2.equals(f1))
1:67614ad:                         {
1:67614ad:                             foundMatch = true;
1:67614ad:                             if (checkCount > 1)
1:67614ad:                             {
1:67614ad:                                 returnVec.addElement((currentLine1 + 1) + "," + (currentLine1 + checkCount) + "d" + currentLine2);
1:67614ad:                             }
1:67614ad:                             else
1:67614ad:                             {
1:67614ad:                                 returnVec.addElement((currentLine1 + 1) + "d" + currentLine2);
1:67614ad:                             }
1:67614ad: 
1:67614ad:                             for (int j = 0; j < checkCount; j++)
1:67614ad:                             {
1:67614ad:                                 returnVec.addElement("< " +
1:67614ad:                                       file1.lineAt(currentLine1 + j) );
1:67614ad: 
1:67614ad:                             }
1:67614ad:                             currentLine1 = currentLine1 + checkCount;
1:67614ad:                             checkCount = 0;
1:67614ad:                             debug(1, "continuing");
1:67614ad:                             break;
1:67614ad:                         }
1:67614ad:                         checkCount ++;
1:67614ad:                     }
1:67614ad: 
1:67614ad:                 }
1:67614ad:                 if (!foundMatch)
1:67614ad:                 {
1:67614ad:                     debug(1, currentLine1 + ": NOMATCH");
1:67614ad:                     returnVec.addElement((currentLine1 + 1) +" del");// + (currentLine2 + 1));
1:67614ad:                     returnVec.addElement("< " + file1.lineAt(currentLine1));
1:67614ad:                     currentLine1++;
1:67614ad:                 }
1:67614ad:                 else
1:67614ad:                 {
1:67614ad:                     currentLine1++;
1:67614ad:                     currentLine2++;
1:67614ad:                     file1.setLowWater(currentLine1);
1:67614ad:                     file2.setLowWater(currentLine2);
1:67614ad:                 }
1:67614ad:             }
1:67614ad:         }
1:67614ad: 
1:67614ad:         if (file1.isValidOffset(currentLine1))
1:67614ad:         {
1:67614ad:             returnVec.addElement((currentLine2) + " del");
1:67614ad:             for (int i = currentLine1; file1.isValidOffset(i); i++)
1:67614ad:             {
1:67614ad:                 returnVec.addElement("< " + file1.lineAt(i));
1:67614ad:             }
1:67614ad:         }
1:67614ad:         if (file2.isValidOffset(currentLine2))
1:67614ad:         {
1:67614ad:             returnVec.addElement((currentLine1) + " add");
1:67614ad:             for (int i = currentLine2; file2.isValidOffset(i); i++)
1:67614ad:             {
1:67614ad:                 returnVec.addElement("> " + file2.lineAt(i));
1:67614ad:             }
1:67614ad:         }
1:67614ad: 
1:67614ad:         file1.close();
1:67614ad:         file2.close();
1:67614ad: 
1:3f5c48a:         if (returnVec.isEmpty())
1:67614ad:         {
1:67614ad:             return null;
1:67614ad:         }
1:67614ad: 
1:67614ad: 
1:67614ad:         String [] returnArray = new String[returnVec.size()];
1:67614ad:         returnVec.copyInto(returnArray);
1:67614ad:         return returnArray;
1:67614ad: 
1:67614ad: 
1:67614ad:     }
1:67614ad: 
1:67614ad:     private void reportMemory()
1:67614ad:     {
1:67614ad:         reportMemory(null);
1:67614ad:     }
1:67614ad: 
1:67614ad:     private void reportMemory(String header)
1:67614ad:     {
1:67614ad:         if (header != null)
1:67614ad:         {
1:67614ad:             System.out.println(header);
1:67614ad:         }
1:67614ad:         long free = Runtime.getRuntime().freeMemory();
1:67614ad:         long total = Runtime.getRuntime().totalMemory();
1:67614ad: 
1:67614ad:         System.out.println("total:         " + total );
1:67614ad:         System.out.println("free:          " + free );
1:67614ad:         System.out.println("used:          " + (total - free));
1:67614ad:         System.gc();
1:67614ad:         System.out.println("used: <postgc> " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));
1:67614ad:         System.out.println("  ");
1:67614ad:     }
1:67614ad: 
1:67614ad:     public boolean doWork(BufferedReader in1, BufferedReader in2, PrintWriter localPW) throws IOException
1:67614ad:     {
1:67614ad:         this.pw=(localPW==null?new PrintWriter(System.out):localPW);
1:67614ad:         try
1:67614ad:         {
1:67614ad:             DiffBuffer db1 = new DiffBuffer(in1, "1");
1:67614ad:             DiffBuffer db2 = new DiffBuffer(in2, "2");
1:67614ad: 
1:67614ad:             String diffs[] = diffFiles(db1, db2);
1:67614ad: 
1:67614ad:             if (diffs == null)
1:67614ad:             {
1:67614ad:                 debug(1, "no diff");
1:67614ad:                 return false;
1:67614ad:             }
1:67614ad:             else
1:67614ad:             {
1:67614ad:                 for (int i = 0; i < diffs.length; i++)
1:67614ad:                 {
1:67614ad:                     this.pw.println(diffs[i]);
1:67614ad:                     System.out.println(diffs[i]);
1:67614ad:                 }
1:67614ad:             }
1:67614ad: 
1:67614ad:         }
1:67614ad:         catch (IOException ioe)
1:67614ad:         {
1:67614ad:             System.err.println("IOException comparing <" + in1 +
1:67614ad:                 "> and <" + in2 + ">");
1:67614ad:             System.err.println(ioe);
1:67614ad: 
1:67614ad:             this.pw.println("IOException comparing <" + in1 +
1:67614ad:                 "> and <" + in2 + ">");
1:67614ad:             this.pw.println(ioe);
1:67614ad:         }
1:67614ad:         return true;
1:67614ad:     }
1:67614ad:     public static void main(String args[]) throws IOException
1:67614ad:     {
1:67614ad: 
1:67614ad:         if (args.length < 2)
1:67614ad:         {
1:67614ad:             System.err.println("Invalid number of arguments");
1:67614ad:             System.err.println("Usage: " + usage);
1:67614ad:             System.exit(1);
1:67614ad:         }
1:67614ad: 
1:67614ad:         SimpleDiff me = new SimpleDiff();
1:67614ad: 
1:67614ad:         try
1:67614ad:         {
1:67614ad:             BufferedReader br1 = new BufferedReader(new FileReader(args[0]));
1:67614ad:             BufferedReader br2 = new BufferedReader(new FileReader(args[1]));
1:67614ad:             me.doWork(br1, br2, null);
1:67614ad:         }
1:67614ad:         catch (IOException ioe)
1:67614ad:         {
1:67614ad:             System.out.println("IOExeption: " + ioe);
1:67614ad:         }
1:67614ad:     }
1:67614ad: 
1:67614ad:     public void pause()
1:67614ad:     {
1:67614ad:         BufferedInputStream bis = new BufferedInputStream(System.in);
1:67614ad:         try
1:67614ad:         {
1:67614ad:             bis.read();
1:67614ad:         }
1:67614ad:         catch (IOException ioe)
1:67614ad:         {
1:67614ad:             pw.println("Error trying to pause...");
1:67614ad:             System.out.println("Error trying to pause...");
1:67614ad:         }
1:67614ad:     }
1:67614ad: 
1:3f5c48a:     class DiffBuffer extends Vector<String>
1:67614ad:     {
1:67614ad: 
1:67614ad: 
1:67614ad:         public boolean atEOF()
1:67614ad:         {
1:67614ad:             return atEnd;
1:67614ad:         }
1:67614ad: 
1:67614ad:         public DiffBuffer(BufferedReader rb)
1:67614ad:         {
1:67614ad:             this(rb, "");
1:67614ad:         }
1:67614ad: 
1:67614ad:         public DiffBuffer(BufferedReader rb, String name)
1:67614ad:         {
1:67614ad:             this (rb, name, 1024);
1:67614ad:         }
1:67614ad: 
1:67614ad:         public DiffBuffer(BufferedReader rb, String name, int size)
1:67614ad:         {
1:67614ad:             super(size);
1:67614ad:             readBuffer = rb;
1:67614ad:             currentLowWater = 0;
1:67614ad:             currentHighWater = -1;
1:67614ad:             oldLow = 0;
1:67614ad:             myName = name;
1:67614ad:             atEnd = false;
1:67614ad:         }
1:67614ad: 
1:67614ad:         public boolean isValidOffset(int lineNumber) throws IOException
1:67614ad:         {
1:67614ad:             if (atEnd)
1:67614ad:             {
1:67614ad:                 return lineNumber <= actualEndOfFile;
1:67614ad:             }
1:67614ad: 
1:67614ad:             if (lineAt(lineNumber) == null)
1:67614ad:             {
1:67614ad:                 return false;
1:67614ad:             }
1:67614ad:             return true;
1:67614ad:         }
1:67614ad: 
1:67614ad:         public String lineAt(int offset) throws IOException
1:67614ad:         {
1:67614ad: /*
1:67614ad: System.out.println("offset: " + offset);
1:67614ad: System.out.println("currentHighWater: " + currentHighWater);
1:67614ad: System.out.println("");
1:67614ad: */
1:67614ad:             if (offset > currentHighWater)
1:67614ad:             {
1:67614ad:                 for (int i = 0; i < offset - currentHighWater; i++)
1:67614ad:                 {
1:67614ad:                     String aLine = readBuffer.readLine();
1:67614ad:                     addElement(aLine);
1:67614ad: /*
1:67614ad: System.out.println("aLine: " + aLine);
1:67614ad: */
1:67614ad:                     if (aLine == null)
1:67614ad:                     {
1:67614ad:                         if (!atEnd)
1:67614ad:                         {
1:67614ad:                             //first time we've tried to read past the EOF
1:67614ad:                             actualEndOfFile = currentHighWater + i;
1:67614ad: //System.out.println(myName + ": length " + actualEndOfFile);
1:67614ad:                             atEnd = true;
1:67614ad:                         }
1:67614ad:                     }
1:67614ad:                 }
1:67614ad:                 currentHighWater = offset;
1:67614ad:             }
1:67614ad:             return (String) elementAt(offset);
1:67614ad:         }
1:67614ad: 
1:67614ad: 
1:67614ad:         public final String EMPTY = null;
1:67614ad:         protected BufferedReader readBuffer;
1:67614ad:         protected int currentLowWater;
1:67614ad:         protected int currentHighWater;
1:67614ad:         private int oldLow;
1:67614ad:         protected String myName;
1:67614ad:         protected boolean atEnd;
1:67614ad:         protected int actualEndOfFile;
1:67614ad:         /**
1:67614ad:             Useful to keep memory requirements low
1:67614ad:          */
1:67614ad:         public void setLowWater(int newLow)
1:67614ad:         {
1:67614ad: 
1:67614ad:             for (int i = oldLow; i < newLow; i++)
1:67614ad:             {
1:67614ad:                 setElementAt(EMPTY, i);
1:67614ad:             }
1:67614ad:             currentLowWater = newLow;
1:67614ad:             oldLow = newLow -1;
1:67614ad:         }
1:67614ad: 
1:67614ad: 
1:67614ad:     public void iterate(boolean verbose)
1:67614ad:     {
1:67614ad:         int nulls = 0;
1:67614ad:         int nonnulls = 0;
1:67614ad: 
1:67614ad: 
1:67614ad:         for (int i = 0; i < this.size(); i++)
1:67614ad:         {
1:67614ad:             if (elementAt(i) == null)
1:67614ad:             {
1:67614ad:                 if (verbose)
1:67614ad:                 {
1:67614ad:                     System.out.print("[" + i + "] ");
1:67614ad:                     System.out.println("null");
1:67614ad:                 }
1:67614ad:                 nulls++;
1:67614ad: 
1:67614ad:             }
1:67614ad:             else
1:67614ad:             {
1:67614ad:                 if (verbose)
1:67614ad:                 {
1:67614ad:                     System.out.print("[" + i + "] ");
1:67614ad:                     System.out.println("NotNULL");
1:67614ad:                 }
1:67614ad:                 nonnulls++;
1:67614ad:             }
1:67614ad:         }
1:67614ad:         System.out.println("nulls: " + nulls + "  nonNull: " + nonnulls);
1:67614ad:     }
1:67614ad: 
1:67614ad:     public void close() throws IOException
1:67614ad:     {
1:67614ad: //		System.out.println("Closing BufferedReader");
1:67614ad:         readBuffer.close();
1:67614ad:         readBuffer = null;
1:67614ad:     }
1:67614ad:     }
1:67614ad: 
1:67614ad: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:         Vector<String> vec = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1:         Vector<String> returnVec = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1:         if (returnVec.isEmpty())
/////////////////////////////////////////////////////////////////////////
1:     class DiffBuffer extends Vector<String>
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1:         @param file1 Name of first file to be read
1:         @param file2 Name of file with which to compare
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.harness
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: //SimpleDiff.java
1: package org.apache.derbyTesting.functionTests.harness;
1: 
1: import java.io.IOException;
1: import java.io.BufferedInputStream;
1: import java.util.Vector;
1: import java.io.File;
1: import java.io.PrintWriter;
1: import java.io.BufferedReader;
1: import java.io.FileReader;
1: 
1: public class SimpleDiff
1: { 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1:     PrintWriter pw;
1: 
1:     boolean debugOn = Boolean.getBoolean("simplediff.debug");
1:     int debugLevel = 1;
1: 
1:     boolean diffsFound = true;
1: 
1:     int lookAhead = 20;
1: 
1:     public void debug(int level, String msg)
1:     {
1:         if (debugLevel >= level)
1:         {
1:             debug(msg);
1:         }
1:     }
1:     public void debug(String msg)
1:     {
1:         if (debugOn)
1:         {
1:             System.out.println("DEBUG: " + msg);
1:         }
1:     }
1: 
1:     int lineCount(String file) throws IOException
1:     {
1:         BufferedReader input = new BufferedReader(new FileReader(file));
1:         int count = 0;
1:         String aLine = input.readLine();
1:         while (aLine != null)
1:         {
1:             count++;
1:             aLine = input.readLine();
1:         }
1:         input.close();
1:         return count;
1:     }
1: 
1: 
1:     public String[] readFile(BufferedReader input) throws IOException
1:     {
1: 
0:         Vector vec = new Vector();
1: 
1:         String aLine = "";
1:         //int count = 0;
1:         aLine = input.readLine();
1:         while (aLine != null)
1:         {
1:             vec.addElement(aLine);
1:             //count++;
1:             aLine = input.readLine();
1:         }
1:         input.close();
1: 
1:         String rV[] = new String[vec.size()];
1:         //debug(2, ""+count + " lines in " + filename);
1:         debug(2, ""+vec.size() + " lines in input");
1:         vec.copyInto(rV);
1: 
1:         return rV;
1:     }
1: 
1:     public void printFile(String file[])
1:     {
1:         for (int i = 0; i < file.length; i++)
1:         {
1:             pw.println(i + ": " + file[i]);
1:             System.out.println(i + ": " + file[i]);
1:         }
1:     }
1: 
1:     public static String usage = "java SimpleDiff <file1> <file2>";
1: 
1:     /**
0:         @param filename Name of file to be read
1:         @return String array of file contents
1:         @exception IOException thrown by underlying calls
1:             to the file system
1:     */
1: 
1:     public String[] diffFiles(  DiffBuffer file1,
1:                                 DiffBuffer file2)
1:                                 throws IOException
1:     {
1: 
1:         int currentLine1 = 0;
1:         int currentLine2 = 0;
0:         Vector returnVec = new Vector();
1: 
1:         while ( file1.isValidOffset(currentLine1) &&
1:                 file2.isValidOffset(currentLine2))
1:         {
1:             String f1 = file1.lineAt(currentLine1);
1:             String f2 = file2.lineAt(currentLine2);
1: 
1:             if (f1.equals(f2))
1:             {
1:                 debug(1, currentLine1 + ": match");
1:                 currentLine1++;
1:                 currentLine2++;
1:                 file1.setLowWater(currentLine1);
1:                 file2.setLowWater(currentLine2);
1:             }
1:             else
1:             {
1:                 boolean foundMatch = false;
1:                 int checkLine2 = currentLine2;
1:                 int checkCount = 1;
1: //                while ( (currentLine2 + checkCount) < (file2Length - 1) &&
1:                 while ( file2.isValidOffset(currentLine2 + checkCount) &&
1:                         checkCount < lookAhead)
1:                 {
1:                     debug(1, "currentLine1 " + currentLine1 + "  currentLine2 " + (currentLine2 +checkCount));
1:                     debug(1, "about to reference file2[" + (currentLine2 + checkCount) + "]");
1:                     f2 = file2.lineAt(currentLine2 + checkCount);
1:                     debug(2, "did");
1:                     if (f1.equals(f2))
1:                     {
1:                         foundMatch = true;
1:                         if (checkCount > 1)
1:                         {
1:                             returnVec.addElement(currentLine1 + "a" + (currentLine2 + 1) + "," + (currentLine2 + checkCount));
1:                         }
1:                         else
1:                         {
1:                             returnVec.addElement(currentLine1 + "a" + (currentLine2 + 1));
1:                         }
1: 
1:                         for (int j = 0; j < checkCount; j++)
1:                         {
1:                             returnVec.addElement("> " +
1:                                   file2.lineAt(currentLine2 + j) );
1:                         }
1:                         currentLine2 = currentLine2 + checkCount;
1:                         checkCount = 0;
1: 
1: 						// This break statement was commented out, which
1: 						// caused problems in the diff output.  I don't
1: 						// know why it was commented out, and uncommenting
1: 						// it fixed the problem.
1: 						//
1: 						//			-	Jeff Lichtman
1: 						//				March 24, 1999
1:                         break;
1:                     }
1:                     checkCount ++;
1:                 }
1:                 if (!foundMatch && file2.isValidOffset(currentLine2))
1:                 {
1:                     int checkLine1 = currentLine1;
1:                     checkCount = 1;
1:                     f2 = file2.lineAt(currentLine2);
1:                     while ( file1.isValidOffset(currentLine1 + checkCount) &&
1:                             checkCount < lookAhead)
1:                     {
1:                         debug(1, "currentLine2 " + currentLine2 + "  currentLine1 " + (currentLine1 + checkCount));
1:                         f1 = file1.lineAt(currentLine1 + checkCount);
1:                         if ( f2.equals(f1))
1:                         {
1:                             foundMatch = true;
1:                             if (checkCount > 1)
1:                             {
1:                                 returnVec.addElement((currentLine1 + 1) + "," + (currentLine1 + checkCount) + "d" + currentLine2);
1:                             }
1:                             else
1:                             {
1:                                 returnVec.addElement((currentLine1 + 1) + "d" + currentLine2);
1:                             }
1: 
1:                             for (int j = 0; j < checkCount; j++)
1:                             {
1:                                 returnVec.addElement("< " +
1:                                       file1.lineAt(currentLine1 + j) );
1: 
1:                             }
1:                             currentLine1 = currentLine1 + checkCount;
1:                             checkCount = 0;
1:                             debug(1, "continuing");
1:                             break;
1:                         }
1:                         checkCount ++;
1:                     }
1: 
1:                 }
1:                 if (!foundMatch)
1:                 {
1:                     debug(1, currentLine1 + ": NOMATCH");
1:                     returnVec.addElement((currentLine1 + 1) +" del");// + (currentLine2 + 1));
1:                     returnVec.addElement("< " + file1.lineAt(currentLine1));
1:                     currentLine1++;
1:                 }
1:                 else
1:                 {
1:                     currentLine1++;
1:                     currentLine2++;
1:                     file1.setLowWater(currentLine1);
1:                     file2.setLowWater(currentLine2);
1:                 }
1:             }
1:         }
1: 
1:         if (file1.isValidOffset(currentLine1))
1:         {
1:             returnVec.addElement((currentLine2) + " del");
1:             for (int i = currentLine1; file1.isValidOffset(i); i++)
1:             {
1:                 returnVec.addElement("< " + file1.lineAt(i));
1:             }
1:         }
1:         if (file2.isValidOffset(currentLine2))
1:         {
1:             returnVec.addElement((currentLine1) + " add");
1:             for (int i = currentLine2; file2.isValidOffset(i); i++)
1:             {
1:                 returnVec.addElement("> " + file2.lineAt(i));
1:             }
1:         }
1: 
1:         file1.close();
1:         file2.close();
1: 
0:         if (returnVec.size() == 0)
1:         {
1:             return null;
1:         }
1: 
1: 
1:         String [] returnArray = new String[returnVec.size()];
1:         returnVec.copyInto(returnArray);
1:         return returnArray;
1: 
1: 
1:     }
1: 
1:     private void reportMemory()
1:     {
1:         reportMemory(null);
1:     }
1: 
1:     private void reportMemory(String header)
1:     {
1:         if (header != null)
1:         {
1:             System.out.println(header);
1:         }
1:         long free = Runtime.getRuntime().freeMemory();
1:         long total = Runtime.getRuntime().totalMemory();
1: 
1:         System.out.println("total:         " + total );
1:         System.out.println("free:          " + free );
1:         System.out.println("used:          " + (total - free));
1:         System.gc();
1:         System.out.println("used: <postgc> " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));
1:         System.out.println("  ");
1:     }
1: 
1:     public boolean doWork(BufferedReader in1, BufferedReader in2, PrintWriter localPW) throws IOException
1:     {
1:         this.pw=(localPW==null?new PrintWriter(System.out):localPW);
1:         try
1:         {
1:             DiffBuffer db1 = new DiffBuffer(in1, "1");
1:             DiffBuffer db2 = new DiffBuffer(in2, "2");
1: 
1:             String diffs[] = diffFiles(db1, db2);
1: 
1:             if (diffs == null)
1:             {
1:                 debug(1, "no diff");
1:                 return false;
1:             }
1:             else
1:             {
1:                 for (int i = 0; i < diffs.length; i++)
1:                 {
1:                     this.pw.println(diffs[i]);
1:                     System.out.println(diffs[i]);
1:                 }
1:             }
1: 
1:         }
1:         catch (IOException ioe)
1:         {
1:             System.err.println("IOException comparing <" + in1 +
1:                 "> and <" + in2 + ">");
1:             System.err.println(ioe);
1: 
1:             this.pw.println("IOException comparing <" + in1 +
1:                 "> and <" + in2 + ">");
1:             this.pw.println(ioe);
1:         }
1:         return true;
1:     }
1:     public static void main(String args[]) throws IOException
1:     {
1: 
1:         if (args.length < 2)
1:         {
1:             System.err.println("Invalid number of arguments");
1:             System.err.println("Usage: " + usage);
1:             System.exit(1);
1:         }
1: 
1:         SimpleDiff me = new SimpleDiff();
1: 
1:         try
1:         {
1:             BufferedReader br1 = new BufferedReader(new FileReader(args[0]));
1:             BufferedReader br2 = new BufferedReader(new FileReader(args[1]));
1:             me.doWork(br1, br2, null);
1:         }
1:         catch (IOException ioe)
1:         {
1:             System.out.println("IOExeption: " + ioe);
1:         }
1:     }
1: 
1:     public void pause()
1:     {
1:         BufferedInputStream bis = new BufferedInputStream(System.in);
1:         try
1:         {
1:             bis.read();
1:         }
1:         catch (IOException ioe)
1:         {
1:             pw.println("Error trying to pause...");
1:             System.out.println("Error trying to pause...");
1:         }
1:     }
1: 
0:     class DiffBuffer extends Vector
1:     {
1: 
1: 
1:         public boolean atEOF()
1:         {
1:             return atEnd;
1:         }
1: 
1:         public DiffBuffer(BufferedReader rb)
1:         {
1:             this(rb, "");
1:         }
1: 
1:         public DiffBuffer(BufferedReader rb, String name)
1:         {
1:             this (rb, name, 1024);
1:         }
1: 
1:         public DiffBuffer(BufferedReader rb, String name, int size)
1:         {
1:             super(size);
1:             readBuffer = rb;
1:             currentLowWater = 0;
1:             currentHighWater = -1;
1:             oldLow = 0;
1:             myName = name;
1:             atEnd = false;
1:         }
1: 
1:         public boolean isValidOffset(int lineNumber) throws IOException
1:         {
1:             if (atEnd)
1:             {
1:                 return lineNumber <= actualEndOfFile;
1:             }
1: 
1:             if (lineAt(lineNumber) == null)
1:             {
1:                 return false;
1:             }
1:             return true;
1:         }
1: 
1:         public String lineAt(int offset) throws IOException
1:         {
1: /*
1: System.out.println("offset: " + offset);
1: System.out.println("currentHighWater: " + currentHighWater);
1: System.out.println("");
1: */
1:             if (offset > currentHighWater)
1:             {
1:                 for (int i = 0; i < offset - currentHighWater; i++)
1:                 {
1:                     String aLine = readBuffer.readLine();
1:                     addElement(aLine);
1: /*
1: System.out.println("aLine: " + aLine);
1: */
1:                     if (aLine == null)
1:                     {
1:                         if (!atEnd)
1:                         {
1:                             //first time we've tried to read past the EOF
1:                             actualEndOfFile = currentHighWater + i;
1: //System.out.println(myName + ": length " + actualEndOfFile);
1:                             atEnd = true;
1:                         }
1:                     }
1:                 }
1:                 currentHighWater = offset;
1:             }
1:             return (String) elementAt(offset);
1:         }
1: 
1: 
1:         public final String EMPTY = null;
1:         protected BufferedReader readBuffer;
1:         protected int currentLowWater;
1:         protected int currentHighWater;
1:         private int oldLow;
1:         protected String myName;
1:         protected boolean atEnd;
1:         protected int actualEndOfFile;
1:         /**
1:             Useful to keep memory requirements low
1:          */
1:         public void setLowWater(int newLow)
1:         {
1: 
1:             for (int i = oldLow; i < newLow; i++)
1:             {
1:                 setElementAt(EMPTY, i);
1:             }
1:             currentLowWater = newLow;
1:             oldLow = newLow -1;
1:         }
1: 
1: 
1:     public void iterate(boolean verbose)
1:     {
1:         int nulls = 0;
1:         int nonnulls = 0;
1: 
1: 
1:         for (int i = 0; i < this.size(); i++)
1:         {
1:             if (elementAt(i) == null)
1:             {
1:                 if (verbose)
1:                 {
1:                     System.out.print("[" + i + "] ");
1:                     System.out.println("null");
1:                 }
1:                 nulls++;
1: 
1:             }
1:             else
1:             {
1:                 if (verbose)
1:                 {
1:                     System.out.print("[" + i + "] ");
1:                     System.out.println("NotNULL");
1:                 }
1:                 nonnulls++;
1:             }
1:         }
1:         System.out.println("nulls: " + nulls + "  nonNull: " + nonnulls);
1:     }
1: 
1:     public void close() throws IOException
1:     {
1: //		System.out.println("Closing BufferedReader");
1:         readBuffer.close();
1:         readBuffer = null;
1:     }
1:     }
1: 
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.harness.SimpleDiff
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0:  */
1: 
0: //SimpleDiff.java
0: package org.apache.derbyTesting.functionTests.harness;
1: 
0: import java.io.IOException;
0: import java.io.BufferedInputStream;
0: import java.util.Vector;
0: import java.io.File;
0: import java.io.PrintWriter;
0: import java.io.BufferedReader;
0: import java.io.FileReader;
1: 
0: public class SimpleDiff
0: {
1: 
0:     PrintWriter pw;
1: 
0:     boolean debugOn = Boolean.getBoolean("simplediff.debug");
0:     int debugLevel = 1;
1: 
0:     boolean diffsFound = true;
1: 
0:     int lookAhead = 20;
1: 
0:     public void debug(int level, String msg)
0:     {
0:         if (debugLevel >= level)
0:         {
0:             debug(msg);
0:         }
0:     }
0:     public void debug(String msg)
0:     {
0:         if (debugOn)
0:         {
0:             System.out.println("DEBUG: " + msg);
0:         }
0:     }
1: 
0:     int lineCount(String file) throws IOException
0:     {
0:         BufferedReader input = new BufferedReader(new FileReader(file));
0:         int count = 0;
0:         String aLine = input.readLine();
0:         while (aLine != null)
0:         {
0:             count++;
0:             aLine = input.readLine();
0:         }
0:         input.close();
0:         return count;
0:     }
1: 
1: 
0:     public String[] readFile(BufferedReader input) throws IOException
0:     {
1: 
0:         Vector vec = new Vector();
1: 
0:         String aLine = "";
0:         //int count = 0;
0:         aLine = input.readLine();
0:         while (aLine != null)
0:         {
0:             vec.addElement(aLine);
0:             //count++;
0:             aLine = input.readLine();
0:         }
0:         input.close();
1: 
0:         String rV[] = new String[vec.size()];
0:         //debug(2, ""+count + " lines in " + filename);
0:         debug(2, ""+vec.size() + " lines in input");
0:         vec.copyInto(rV);
1: 
0:         return rV;
0:     }
1: 
0:     public void printFile(String file[])
0:     {
0:         for (int i = 0; i < file.length; i++)
0:         {
0:             pw.println(i + ": " + file[i]);
0:             System.out.println(i + ": " + file[i]);
0:         }
0:     }
1: 
0:     public static String usage = "java SimpleDiff <file1> <file2>";
1: 
0:     /**
0:         @param filename Name of file to be read
0:         @return String array of file contents
0:         @exception IOException thrown by underlying calls
0:             to the file system
0:     */
1: 
0:     public String[] diffFiles(  DiffBuffer file1,
0:                                 DiffBuffer file2)
0:                                 throws IOException
0:     {
1: 
0:         int currentLine1 = 0;
0:         int currentLine2 = 0;
0:         Vector returnVec = new Vector();
1: 
0:         while ( file1.isValidOffset(currentLine1) &&
0:                 file2.isValidOffset(currentLine2))
0:         {
0:             String f1 = file1.lineAt(currentLine1);
0:             String f2 = file2.lineAt(currentLine2);
1: 
0:             if (f1.equals(f2))
0:             {
0:                 debug(1, currentLine1 + ": match");
0:                 currentLine1++;
0:                 currentLine2++;
0:                 file1.setLowWater(currentLine1);
0:                 file2.setLowWater(currentLine2);
0:             }
0:             else
0:             {
0:                 boolean foundMatch = false;
0:                 int checkLine2 = currentLine2;
0:                 int checkCount = 1;
0: //                while ( (currentLine2 + checkCount) < (file2Length - 1) &&
0:                 while ( file2.isValidOffset(currentLine2 + checkCount) &&
0:                         checkCount < lookAhead)
0:                 {
0:                     debug(1, "currentLine1 " + currentLine1 + "  currentLine2 " + (currentLine2 +checkCount));
0:                     debug(1, "about to reference file2[" + (currentLine2 + checkCount) + "]");
0:                     f2 = file2.lineAt(currentLine2 + checkCount);
0:                     debug(2, "did");
0:                     if (f1.equals(f2))
0:                     {
0:                         foundMatch = true;
0:                         if (checkCount > 1)
0:                         {
0:                             returnVec.addElement(currentLine1 + "a" + (currentLine2 + 1) + "," + (currentLine2 + checkCount));
0:                         }
0:                         else
0:                         {
0:                             returnVec.addElement(currentLine1 + "a" + (currentLine2 + 1));
0:                         }
1: 
0:                         for (int j = 0; j < checkCount; j++)
0:                         {
0:                             returnVec.addElement("> " +
0:                                   file2.lineAt(currentLine2 + j) );
0:                         }
0:                         currentLine2 = currentLine2 + checkCount;
0:                         checkCount = 0;
1: 
0: 						// This break statement was commented out, which
0: 						// caused problems in the diff output.  I don't
0: 						// know why it was commented out, and uncommenting
0: 						// it fixed the problem.
0: 						//
0: 						//			-	Jeff Lichtman
0: 						//				March 24, 1999
0:                         break;
0:                     }
0:                     checkCount ++;
0:                 }
0:                 if (!foundMatch && file2.isValidOffset(currentLine2))
0:                 {
0:                     int checkLine1 = currentLine1;
0:                     checkCount = 1;
0:                     f2 = file2.lineAt(currentLine2);
0:                     while ( file1.isValidOffset(currentLine1 + checkCount) &&
0:                             checkCount < lookAhead)
0:                     {
0:                         debug(1, "currentLine2 " + currentLine2 + "  currentLine1 " + (currentLine1 + checkCount));
0:                         f1 = file1.lineAt(currentLine1 + checkCount);
0:                         if ( f2.equals(f1))
0:                         {
0:                             foundMatch = true;
0:                             if (checkCount > 1)
0:                             {
0:                                 returnVec.addElement((currentLine1 + 1) + "," + (currentLine1 + checkCount) + "d" + currentLine2);
0:                             }
0:                             else
0:                             {
0:                                 returnVec.addElement((currentLine1 + 1) + "d" + currentLine2);
0:                             }
1: 
0:                             for (int j = 0; j < checkCount; j++)
0:                             {
0:                                 returnVec.addElement("< " +
0:                                       file1.lineAt(currentLine1 + j) );
1: 
0:                             }
0:                             currentLine1 = currentLine1 + checkCount;
0:                             checkCount = 0;
0:                             debug(1, "continuing");
0:                             break;
0:                         }
0:                         checkCount ++;
0:                     }
1: 
0:                 }
0:                 if (!foundMatch)
0:                 {
0:                     debug(1, currentLine1 + ": NOMATCH");
0:                     returnVec.addElement((currentLine1 + 1) +" del");// + (currentLine2 + 1));
0:                     returnVec.addElement("< " + file1.lineAt(currentLine1));
0:                     currentLine1++;
0:                 }
0:                 else
0:                 {
0:                     currentLine1++;
0:                     currentLine2++;
0:                     file1.setLowWater(currentLine1);
0:                     file2.setLowWater(currentLine2);
0:                 }
0:             }
0:         }
1: 
0:         if (file1.isValidOffset(currentLine1))
0:         {
0:             returnVec.addElement((currentLine2) + " del");
0:             for (int i = currentLine1; file1.isValidOffset(i); i++)
0:             {
0:                 returnVec.addElement("< " + file1.lineAt(i));
0:             }
0:         }
0:         if (file2.isValidOffset(currentLine2))
0:         {
0:             returnVec.addElement((currentLine1) + " add");
0:             for (int i = currentLine2; file2.isValidOffset(i); i++)
0:             {
0:                 returnVec.addElement("> " + file2.lineAt(i));
0:             }
0:         }
1: 
0:         file1.close();
0:         file2.close();
1: 
0:         if (returnVec.size() == 0)
0:         {
0:             return null;
0:         }
1: 
1: 
0:         String [] returnArray = new String[returnVec.size()];
0:         returnVec.copyInto(returnArray);
0:         return returnArray;
1: 
1: 
0:     }
1: 
0:     private void reportMemory()
0:     {
0:         reportMemory(null);
0:     }
1: 
0:     private void reportMemory(String header)
0:     {
0:         if (header != null)
0:         {
0:             System.out.println(header);
0:         }
0:         long free = Runtime.getRuntime().freeMemory();
0:         long total = Runtime.getRuntime().totalMemory();
1: 
0:         System.out.println("total:         " + total );
0:         System.out.println("free:          " + free );
0:         System.out.println("used:          " + (total - free));
0:         System.gc();
0:         System.out.println("used: <postgc> " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));
0:         System.out.println("  ");
0:     }
1: 
0:     public boolean doWork(BufferedReader in1, BufferedReader in2, PrintWriter localPW) throws IOException
0:     {
0:         this.pw=(localPW==null?new PrintWriter(System.out):localPW);
0:         try
0:         {
0:             DiffBuffer db1 = new DiffBuffer(in1, "1");
0:             DiffBuffer db2 = new DiffBuffer(in2, "2");
1: 
0:             String diffs[] = diffFiles(db1, db2);
1: 
0:             if (diffs == null)
0:             {
0:                 debug(1, "no diff");
0:                 return false;
0:             }
0:             else
0:             {
0:                 for (int i = 0; i < diffs.length; i++)
0:                 {
0:                     this.pw.println(diffs[i]);
0:                     System.out.println(diffs[i]);
0:                 }
0:             }
1: 
0:         }
0:         catch (IOException ioe)
0:         {
0:             System.err.println("IOException comparing <" + in1 +
0:                 "> and <" + in2 + ">");
0:             System.err.println(ioe);
1: 
0:             this.pw.println("IOException comparing <" + in1 +
0:                 "> and <" + in2 + ">");
0:             this.pw.println(ioe);
0:         }
0:         return true;
0:     }
0:     public static void main(String args[]) throws IOException
0:     {
1: 
0:         if (args.length < 2)
0:         {
0:             System.err.println("Invalid number of arguments");
0:             System.err.println("Usage: " + usage);
0:             System.exit(1);
0:         }
1: 
0:         SimpleDiff me = new SimpleDiff();
1: 
0:         try
0:         {
0:             BufferedReader br1 = new BufferedReader(new FileReader(args[0]));
0:             BufferedReader br2 = new BufferedReader(new FileReader(args[1]));
0:             me.doWork(br1, br2, null);
0:         }
0:         catch (IOException ioe)
0:         {
0:             System.out.println("IOExeption: " + ioe);
0:         }
0:     }
1: 
0:     public void pause()
0:     {
0:         BufferedInputStream bis = new BufferedInputStream(System.in);
0:         try
0:         {
0:             bis.read();
0:         }
0:         catch (IOException ioe)
0:         {
0:             pw.println("Error trying to pause...");
0:             System.out.println("Error trying to pause...");
0:         }
0:     }
1: 
0:     class DiffBuffer extends Vector
0:     {
1: 
1: 
0:         public boolean atEOF()
0:         {
0:             return atEnd;
0:         }
1: 
0:         public DiffBuffer(BufferedReader rb)
0:         {
0:             this(rb, "");
0:         }
1: 
0:         public DiffBuffer(BufferedReader rb, String name)
0:         {
0:             this (rb, name, 1024);
0:         }
1: 
0:         public DiffBuffer(BufferedReader rb, String name, int size)
0:         {
0:             super(size);
0:             readBuffer = rb;
0:             currentLowWater = 0;
0:             currentHighWater = -1;
0:             oldLow = 0;
0:             myName = name;
0:             atEnd = false;
0:         }
1: 
0:         public boolean isValidOffset(int lineNumber) throws IOException
0:         {
0:             if (atEnd)
0:             {
0:                 return lineNumber <= actualEndOfFile;
0:             }
1: 
0:             if (lineAt(lineNumber) == null)
0:             {
0:                 return false;
0:             }
0:             return true;
0:         }
1: 
0:         public String lineAt(int offset) throws IOException
0:         {
0: /*
0: System.out.println("offset: " + offset);
0: System.out.println("currentHighWater: " + currentHighWater);
0: System.out.println("");
0: */
0:             if (offset > currentHighWater)
0:             {
0:                 for (int i = 0; i < offset - currentHighWater; i++)
0:                 {
0:                     String aLine = readBuffer.readLine();
0:                     addElement(aLine);
0: /*
0: System.out.println("aLine: " + aLine);
0: */
0:                     if (aLine == null)
0:                     {
0:                         if (!atEnd)
0:                         {
0:                             //first time we've tried to read past the EOF
0:                             actualEndOfFile = currentHighWater + i;
0: //System.out.println(myName + ": length " + actualEndOfFile);
0:                             atEnd = true;
0:                         }
0:                     }
0:                 }
0:                 currentHighWater = offset;
0:             }
0:             return (String) elementAt(offset);
0:         }
1: 
1: 
0:         public final String EMPTY = null;
0:         protected BufferedReader readBuffer;
0:         protected int currentLowWater;
0:         protected int currentHighWater;
0:         private int oldLow;
0:         protected String myName;
0:         protected boolean atEnd;
0:         protected int actualEndOfFile;
0:         /**
0:             Useful to keep memory requirements low
0:          */
0:         public void setLowWater(int newLow)
0:         {
1: 
0:             for (int i = oldLow; i < newLow; i++)
0:             {
0:                 setElementAt(EMPTY, i);
0:             }
0:             currentLowWater = newLow;
0:             oldLow = newLow -1;
0:         }
1: 
1: 
0:     public void iterate(boolean verbose)
0:     {
0:         int nulls = 0;
0:         int nonnulls = 0;
1: 
1: 
0:         for (int i = 0; i < this.size(); i++)
0:         {
0:             if (elementAt(i) == null)
0:             {
0:                 if (verbose)
0:                 {
0:                     System.out.print("[" + i + "] ");
0:                     System.out.println("null");
0:                 }
0:                 nulls++;
1: 
0:             }
0:             else
0:             {
0:                 if (verbose)
0:                 {
0:                     System.out.print("[" + i + "] ");
0:                     System.out.println("NotNULL");
0:                 }
0:                 nonnulls++;
0:             }
0:         }
0:         System.out.println("nulls: " + nulls + "  nonNull: " + nonnulls);
0:     }
1: 
0:     public void close() throws IOException
0:     {
0: //		System.out.println("Closing BufferedReader");
0:         readBuffer.close();
0:         readBuffer = null;
0:     }
0:     }
1: 
0: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.harness.SimpleDiff
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
============================================================================