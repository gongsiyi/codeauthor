3:38b4bbb: /*
1:8404f5d:  *
1:38b4bbb:  * Derby - Class org.apache.derbyTesting.system.oe.direct.Standard
2:38b4bbb:  *
1:38b4bbb:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:38b4bbb:  * contributor license agreements.  See the NOTICE file distributed with
1:38b4bbb:  * this work for additional information regarding copyright ownership.
1:38b4bbb:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:38b4bbb:  * (the "License"); you may not use this file except in compliance with
1:38b4bbb:  * the License.  You may obtain a copy of the License at
1:38b4bbb:  *
1:38b4bbb:  *    http://www.apache.org/licenses/LICENSE-2.0
1:38b4bbb:  *
1:38b4bbb:  * Unless required by applicable law or agreed to in writing, 
1:38b4bbb:  * software distributed under the License is distributed on an 
1:38b4bbb:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:38b4bbb:  * either express or implied. See the License for the specific 
1:38b4bbb:  * language governing permissions and limitations under the License.
1:9f7e882:  */
1:38b4bbb: package org.apache.derbyTesting.system.oe.direct;
1:8404f5d: 
1:72a917a: import java.math.BigDecimal;
1:38b4bbb: import java.sql.Connection;
1:38b4bbb: import java.sql.PreparedStatement;
1:38b4bbb: import java.sql.ResultSet;
1:38b4bbb: import java.sql.SQLException;
1:24e8abd: import java.sql.Types;
1:9f7e882: import java.util.ArrayList;
1:9f7e882: import java.util.List;
1:72a917a: 
1:38b4bbb: import org.apache.derbyTesting.system.oe.client.Display;
1:38b4bbb: import org.apache.derbyTesting.system.oe.client.Operations;
1:9f7e882: import org.apache.derbyTesting.system.oe.model.Customer;
1:8404f5d: import org.apache.derbyTesting.system.oe.model.District;
1:9f7e882: import org.apache.derbyTesting.system.oe.model.Order;
1:9f7e882: import org.apache.derbyTesting.system.oe.model.OrderLine;
1:8404f5d: import org.apache.derbyTesting.system.oe.model.Warehouse;
1:8404f5d: 
1:72a917a: /**
1:38b4bbb:  * Implement the transactions following the TPC-C specification
1:38b4bbb:  * using client side prepared statements. Thus all the logic
1:38b4bbb:  * is contained within this class. The client, through this
1:38b4bbb:  * object, holds onto PreparedStatements for all the SQL
1:38b4bbb:  * for its lifetime.
1:38b4bbb:  * <P>
1:38b4bbb:  * This standard implementation is based upon the sample
1:38b4bbb:  * programs in the appendix of the TPC-C specification.
1:38b4bbb:  * <P>
1:38b4bbb:  * More specific direct (client side) implementations
1:38b4bbb:  * could extend this class overriding methods as needed.
1:57403e7:  * <P>
1:57403e7:  * Object is single threaded so it re-uses objects
1:57403e7:  * where possible to avoid the garbage collection
1:57403e7:  * due to the application affecting the results
1:57403e7:  * too much since the purpose of the framework
1:57403e7:  * is to test Derby's performance.
1:72a917a:  */
1:a6358d6: public class Standard extends StatementHelper implements Operations {
1:57403e7:     
1:57403e7:     /*
1:57403e7:      * Objects for re-use within the transactions
1:57403e7:      */
1:57403e7:     private final Customer customer = new Customer();
1:57403e7:     
1:57403e7:     private final Warehouse warehouse = new Warehouse();
1:57403e7:     
1:57403e7:     private final District district = new District();
1:57403e7:     
1:57403e7:     private final Order order = new Order();
1:57403e7:     
1:9d44c9e:     private final List<Object> nameList = new ArrayList<Object>();
1:57403e7: 
1:57403e7: 
1:72a917a:     /**
1:38b4bbb:      * Create an instance of this implementation.
1:38b4bbb:      * Connection will be set to non auto commit
1:38b4bbb:      * mode and SERIZIALZABLE isolation.
1:72a917a:      */
1:38b4bbb:     public Standard(Connection conn) throws SQLException
1:8404f5d:     {
1:a6358d6:         super(conn, false, Connection.TRANSACTION_SERIALIZABLE);
1:72a917a:     }
1:85fc221:     
1:85fc221:     /**
1:1b6c3f0:      * Return an Operations implementation based upon
1:1b6c3f0:      * Standard with a single difference. In this implementation
1:1b6c3f0:      * the reset() executed after each PreparedStatement execute
1:1b6c3f0:      * does nothing. Sees if there is any performance impact
1:1b6c3f0:      * of explicitly closing each ResultSet and clearing the
1:1b6c3f0:      * parameters.
1:1b6c3f0:      * <P>
1:1b6c3f0:      * Each ResultSet will be closed implicitly either at commit
1:1b6c3f0:      * time or at the next execution of the same PreparedStatement object.
1:1b6c3f0:      */
1:1b6c3f0:     public static Operations noReset(final Connection conn)
1:1b6c3f0:         throws SQLException
1:1b6c3f0:     {
1:1b6c3f0:         return new Standard(conn) {
1:1b6c3f0:             protected void reset(PreparedStatement ps) {}
1:1b6c3f0:         };
1:1b6c3f0:     }
1:1b6c3f0:     
1:1b6c3f0:     /**
1:38b4bbb:      *  Stock Level transaction.
1:38b4bbb:      *  Described in section 2.8.2.
1:38b4bbb:      *  SQL based upon sample prgram in appendix A.5.
1:8404f5d:      */
1:38b4bbb:     public void stockLevel(Display display, Object displayData, short w,
1:38b4bbb:             short d, int threshold) throws Exception {
1:72a917a:         
1:38b4bbb:         int isolation = conn.getTransactionIsolation();
1:72a917a: 
1:24e8abd:         int lowStock;
1:38b4bbb:         try {
1:72a917a: 
1:38b4bbb:             try {
1:72a917a: 
1:38b4bbb:                 conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:85fc221:                 
1:85fc221:                 PreparedStatement sl1 = prepareStatement(
1:85fc221:                         "SELECT D_NEXT_O_ID FROM DISTRICT WHERE D_W_ID = ? AND D_ID = ?");
1:85fc221: 
1:85fc221:                 PreparedStatement sl2 = prepareStatement(
1:85fc221:                         "SELECT COUNT(DISTINCT(S_I_ID)) AS LOW_STOCK FROM ORDERLINE, STOCK " +
1:85fc221:                         "WHERE OL_W_ID = ? AND OL_D_ID = ? " +
1:85fc221:                         "AND OL_O_ID < ? AND OL_O_ID >= ? " +
1:85fc221:                         "AND S_W_ID = ? AND S_I_ID = OL_I_ID AND S_QUANTITY < ?");
1:72a917a:                          
1:38b4bbb:                 sl1.setShort(1, w);
1:38b4bbb:                 sl1.setShort(2, d);
1:72a917a: 
1:38b4bbb:                 sl2.setShort(1, w);
1:38b4bbb:                 sl2.setShort(2, d);
1:24e8abd: 
1:38b4bbb:                 sl2.setShort(5, w);
1:38b4bbb:                 sl2.setInt(6, threshold);
1:24e8abd: 
1:38b4bbb:                 ResultSet rs = sl1.executeQuery();
1:24e8abd: 
1:38b4bbb:                 rs.next();
1:9f7e882:                 int nextOrder = rs.getInt("D_NEXT_O_ID");
1:8404f5d:                 reset(sl1);
1:24e8abd: 
1:38b4bbb:                 sl2.setInt(3, nextOrder);
1:38b4bbb:                 sl2.setInt(4, nextOrder - 20);
1:24e8abd: 
1:38b4bbb:                 rs = sl2.executeQuery();
1:38b4bbb:                 rs.next();
1:24e8abd:                 lowStock = rs.getInt("LOW_STOCK");
1:8404f5d:                 reset(sl2);
1:8404f5d: 
1:38b4bbb:                 conn.commit();
1:38b4bbb:             } finally {
1:38b4bbb:                 conn.setTransactionIsolation(isolation);
1:72a917a:             }
1:24e8abd: 
1:38b4bbb:         } catch (SQLException sqle) {
1:8404f5d: 
1:38b4bbb:             conn.rollback();
1:85fc221:             conn.setTransactionIsolation(isolation);
1:38b4bbb:             throw sqle;
1:9f7e882:         }
12:9f7e882: 
1:38b4bbb:         if (display != null)
1:24e8abd:             display.displayStockLevel(displayData, w, d, threshold, lowStock);
1:9f7e882:     }
1:85fc221:        
1:24e8abd:     /**
1:9f7e882:      * Order status by customer last name.
1:9f7e882:      * Based up the example SQL queries in appendix A.3
1:8404f5d:      */
1:38b4bbb:     public void orderStatus(Display display, Object displayData, short w,
1:38b4bbb:             short d, String customerLast) throws Exception {
1:24e8abd:         
1:85fc221:         PreparedStatement osCustomerByName = prepareStatement(
1:85fc221:                 "SELECT C_ID, C_BALANCE, C_FIRST, C_MIDDLE " +
1:85fc221:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_LAST = ? " +
1:85fc221:                 "ORDER BY C_FIRST");
1:85fc221:         
1:24e8abd:        
1:9f7e882:         try {
1:9f7e882:             osCustomerByName.setShort(1, w);
1:9f7e882:             osCustomerByName.setShort(2, d);
1:9f7e882:             osCustomerByName.setString(3, customerLast);
1:9f7e882:             ResultSet rs = osCustomerByName.executeQuery();
1:31ad846: 
1:57403e7:             nameList.clear();
1:9f7e882:             while (rs.next())
1:72a917a:             {
2:9f7e882:                 Customer customer = new Customer();
1:9f7e882:                 customer.setWarehouse(w);
1:9f7e882:                 customer.setDistrict(d);
1:9f7e882:                 customer.setLast(customerLast);
1:24e8abd:                 
1:9f7e882:                 customer.setId(rs.getInt("C_ID"));
1:9f7e882:                 customer.setBalance(rs.getString("C_BALANCE"));
1:9f7e882:                 customer.setFirst(rs.getString("C_FIRST"));
1:9f7e882:                 customer.setMiddle(rs.getString("C_MIDDLE"));
1:24e8abd:                 
1:57403e7:                 nameList.add(customer);
1:9f7e882:             }
1:8404f5d:             reset(osCustomerByName);
1:57403e7:             if (nameList.isEmpty())
1:9f7e882:                 throw new SQLException("Order Status by name - no matching customer "
1:9f7e882:                         + customerLast);
1:24e8abd:             
1:9f7e882:             // Customer to use is midpoint (with round up) (see 2.6.2.2)
1:57403e7:             int mid = nameList.size()/2;
1:412e7b7:             if (mid != 0) {
1:57403e7:                 if (nameList.size()%2 == 1)
1:412e7b7:                     mid++;
1:412e7b7:             }
1:9f7e882: 
1:9f7e882: 
1:57403e7:             Customer customer = (Customer) nameList.get(mid);
1:57403e7:             nameList.clear();
1:9f7e882:             
1:9f7e882:             getOrderStatusForCustomer(display, displayData, true, customer);
1:9f7e882:         } catch (SQLException e) {
1:9f7e882:             conn.rollback();
1:9f7e882:             throw e;
1:9f7e882:         }
18:38b4bbb:     }
1:9f7e882: 
1:8404f5d:     /**
1:9f7e882:      * Order status by customer identifier.
1:9f7e882:      * Based up the example SQL queries in appendix A.3
1:9f7e882:      */
1:38b4bbb:     public void orderStatus(Display display, Object displayData, short w,
1:38b4bbb:             short d, int c) throws Exception {
1:9f7e882:         
1:85fc221:         PreparedStatement osCustomerById = prepareStatement(
1:85fc221:                 "SELECT C_BALANCE, C_FIRST, C_MIDDLE, C_LAST " +
1:85fc221:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:85fc221:         
1:57403e7:         customer.clear();
1:9f7e882:         customer.setWarehouse(w);
1:9f7e882:         customer.setDistrict(d);
1:9f7e882:         customer.setId(c);
1:8404f5d:         
1:9f7e882:         try {
1:9f7e882:             // Get the customer information
1:9f7e882:             osCustomerById.setShort(1, w);
1:9f7e882:             osCustomerById.setShort(2, d);
1:9f7e882:             osCustomerById.setInt(3, c);
1:9f7e882:             ResultSet rs = osCustomerById.executeQuery();
1:9f7e882:             rs.next();
1:9f7e882:             customer.setBalance(rs.getString("C_BALANCE"));
1:9f7e882:             customer.setFirst(rs.getString("C_FIRST"));
1:9f7e882:             customer.setMiddle(rs.getString("C_MIDDLE"));
1:9f7e882:             customer.setLast(rs.getString("C_LAST"));    
1:8404f5d:             reset(osCustomerById);
1:8404f5d: 
1:9f7e882:             getOrderStatusForCustomer(display, displayData, false, customer);
1:9f7e882:         } catch (SQLException e) {
1:9f7e882:             conn.rollback();
1:9f7e882:             throw e;
1:9f7e882:         }
1:9f7e882:     }
1:8404f5d:     
3:9f7e882:     /**
1:9f7e882:      * Fetch the order details having obtained the customer information
1:9f7e882:      * and display it.
1:9f7e882:      */
1:9f7e882:     private void getOrderStatusForCustomer(Display display, Object displayData,
1:9f7e882:             boolean byName, Customer customer) throws Exception
1:8404f5d:     {
1:85fc221:         PreparedStatement osLastOrderNumber = prepareStatement(
1:85fc221:                 "SELECT MAX(O_ID) AS LAST_ORDER FROM ORDERS " +
1:85fc221:                 "WHERE O_W_ID = ? AND O_D_ID = ? AND O_C_ID = ?");
1:85fc221:         PreparedStatement osOrderDetails = prepareStatement(
1:85fc221:                 "SELECT O_ENTRY_D, O_CARRIER_ID, O_OL_CNT " +
1:85fc221:                 "FROM ORDERS WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?");
1:85fc221:         PreparedStatement osOrderLineItems = prepareStatement(
1:85fc221:                 "SELECT OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, " +
1:85fc221:                 "OL_DELIVERY_D FROM ORDERLINE " +
1:85fc221:                 "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?");
1:85fc221:         
1:57403e7:         order.clear();
1:9f7e882:         order.setWarehouse(customer.getWarehouse());
1:9f7e882:         order.setDistrict(customer.getDistrict());
1:24e8abd:         
1:9f7e882:         // Find the most recent order number for this customer
1:9f7e882:         osLastOrderNumber.setShort(1, customer.getWarehouse());
1:9f7e882:         osLastOrderNumber.setShort(2, customer.getDistrict());
1:9f7e882:         osLastOrderNumber.setInt(3, customer.getId());
1:9f7e882:         ResultSet rs = osLastOrderNumber.executeQuery();
1:9f7e882:         rs.next();
1:9f7e882:         order.setId(rs.getInt("LAST_ORDER"));
1:8404f5d:         reset(osLastOrderNumber);
1:24e8abd:         
1:9f7e882:         // Details for the order.
1:9f7e882:         osOrderDetails.setShort(1, customer.getWarehouse());
1:9f7e882:         osOrderDetails.setShort(2, customer.getDistrict());
1:9f7e882:         osOrderDetails.setInt(3, order.getId());
1:9f7e882:         rs = osOrderDetails.executeQuery();
1:9f7e882:         rs.next();
1:9f7e882:         order.setEntry_d(rs.getTimestamp("O_ENTRY_D"));
1:9f7e882:         order.setCarrier_id((Integer) rs.getObject("O_CARRIER_ID"));
1:9f7e882:         order.setOl_cnt(rs.getInt("O_OL_CNT"));
1:8404f5d:         rs.close();
1:24e8abd: 
1:9f7e882:         OrderLine[] lineItems = new OrderLine[order.getOl_cnt()];
1:8404f5d:         
1:9f7e882:         osOrderLineItems.setShort(1, order.getWarehouse());
1:9f7e882:         osOrderLineItems.setShort(2, order.getDistrict());
1:9f7e882:         osOrderLineItems.setInt(3, order.getId());
1:9f7e882:         rs = osOrderLineItems.executeQuery();
1:9f7e882:         int oli = 0;
1:9f7e882:         while (rs.next())
1:24e8abd:         {
1:9f7e882:             OrderLine ol = new OrderLine();
1:9f7e882:             ol.setI_id(rs.getInt("OL_I_ID"));
1:9f7e882:             ol.setSupply_w_id(rs.getShort("OL_SUPPLY_W_ID"));
1:9f7e882:             ol.setQuantity(rs.getShort("OL_QUANTITY"));
1:9f7e882:             ol.setAmount(rs.getString("OL_AMOUNT"));
1:9f7e882:             ol.setDelivery_d( rs.getTimestamp("OL_DELIVERY_D"));
1:8404f5d:             
1:9f7e882:             lineItems[oli++] = ol;
1:8404f5d:         }
5:9f7e882:         rs.close();
1:9f7e882:         conn.commit();
1:8404f5d:         
1:9f7e882:         if (display != null)
1:9f7e882:             display.displayOrderStatus(displayData,
1:9f7e882:                     byName, customer, order, lineItems);
1:8404f5d:     }
1:8404f5d:     
1:8404f5d:     /**
1:8404f5d:      * Payment by customer last name.
1:8404f5d:      * Section 2.5.2
1:8404f5d:      * The CUSTOMER row will be fetched and then updated.
1:8404f5d:      * This is due to the need to select the specific customer
1:8404f5d:      * first based upon last name (which will actually fetch and
1:8404f5d:      * hence lock a number of customers).
1:8404f5d:      */
1:38b4bbb:     public void payment(Display display, Object displayData, short w, short d,
1:38b4bbb:             short cw, short cd, String customerLast, String amount)
1:38b4bbb:             throws Exception {
1:85fc221:             
1:85fc221:         PreparedStatement pyCustomerByName = prepareStatement(
1:85fc221:                     "SELECT C_ID " +
1:85fc221:                     "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_LAST = ? " +
1:85fc221:                     "ORDER BY C_FIRST");
1:8404f5d:         
1:8404f5d:         // Since so much data is needed for the payment transaction
1:8404f5d:         // from the customer we don't fill it in as we select the
1:8404f5d:         // correct customer. Instead we just fetch the identifier
1:8404f5d:         // and then execute a payment by identifier.
1:8404f5d:         try {
1:8404f5d:             pyCustomerByName.setShort(1, cw);
1:8404f5d:             pyCustomerByName.setShort(2, cd);
1:8404f5d:             pyCustomerByName.setString(3, customerLast);
1:8404f5d:             ResultSet rs = pyCustomerByName.executeQuery();
1:31ad846: 
1:57403e7:             nameList.clear();
1:8404f5d:             while (rs.next())
1:8404f5d:             {           
1:57403e7:                 nameList.add(rs.getObject("C_ID"));            
1:8404f5d:             }
1:8404f5d:             reset(pyCustomerByName);
1:57403e7:             if (nameList.isEmpty())
1:8404f5d:                 throw new SQLException("Payment by name - no matching customer "
1:8404f5d:                         + customerLast);
1:8404f5d:             
1:8404f5d:             // Customer to use is midpoint (with round up) (see 2.5.2.2)
1:57403e7:             int mid = nameList.size()/2;
1:412e7b7:             if (mid != 0) {
1:57403e7:                 if (nameList.size()%2 == 1)
1:412e7b7:                     mid++;
1:412e7b7:             }
1:8404f5d:             
1:57403e7:             int c = ((Integer) nameList.get(mid)).intValue();
1:9f7e882: 
1:8404f5d:             paymentById(display, displayData, w, d, cw, cd, c, amount);
1:8404f5d:         } catch (SQLException e) {
1:8404f5d:             conn.rollback();
1:8404f5d:             throw e;
1:8404f5d:         }
1:8404f5d:         
1:8404f5d:         if (display != null)
1:8404f5d:             ;
1:8404f5d:     }
1:8404f5d: 
1:8404f5d:     /**
1:8404f5d:      * Payment by customer identifier.
1:8404f5d:      * Section 2.5.2.
1:8404f5d:      * The CUSTOMER row is update and then fetched.
1:72a917a:      * 
1:8404f5d:      */
1:38b4bbb:     public void payment(Display display, Object displayData, short w, short d,
1:8404f5d:             short cw, short cd, int c, final String amount) throws Exception {
1:8404f5d:         
1:8404f5d:         try {
1:8404f5d:             paymentById(display, displayData, w, d, cw, cd, c, amount);
1:8404f5d:         } catch (SQLException e) {
1:8404f5d:             conn.rollback();
1:8404f5d:             throw e;
1:8404f5d:         }
1:8404f5d:         
1:8404f5d:         if (display != null)
1:8404f5d:             ;
1:8404f5d:     }
1:8404f5d:     
1:8404f5d:     private void paymentById(Display display, Object displayData, short w, short d,
1:8404f5d:             short cw, short cd, int c, final String amount) throws Exception {
1:85fc221: 
1:85fc221:         PreparedStatement pyCustomerPayment = prepareStatement(
1:85fc221:                 "UPDATE CUSTOMER SET C_BALANCE = C_BALANCE - ?, " +
1:85fc221:                 "C_YTD_PAYMENT = C_YTD_PAYMENT + ?, " +
1:85fc221:                 "C_PAYMENT_CNT = C_PAYMENT_CNT + 1 " +
1:85fc221:                 "WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:85fc221:             
1:85fc221:         PreparedStatement pyCustomerInfoId = prepareStatement(
1:85fc221:                 "SELECT C_FIRST, C_MIDDLE, C_LAST, C_BALANCE, " +
1:85fc221:                 "C_STREET_1, C_STREET_2, C_CITY, C_STATE, C_ZIP, " +
1:85fc221:                 "C_PHONE, C_SINCE, C_CREDIT, C_CREDIT_LIM, C_DISCOUNT " +
1:85fc221:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:85fc221:         
1:85fc221:         PreparedStatement pyCustomerUpdateBadCredit = prepareStatement(
1:85fc221:                 "UPDATE CUSTOMER SET C_DATA = " +
1:85fc221:                 " BAD_CREDIT_DATA(C_DATA, ?, ?, C_W_ID, C_W_ID, C_ID, ?) " +
1:85fc221:                 "WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:85fc221:         PreparedStatement pyCustomerGetData = prepareStatement(
1:85fc221:                 "SELECT SUBSTR(C_DATA, 1, 200) AS C_DATA_200 " +
1:85fc221:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:85fc221:             
1:85fc221:         PreparedStatement pyDistrictUpdate = prepareStatement(
1:85fc221:                 "UPDATE DISTRICT SET D_YTD = D_YTD + ? WHERE D_W_ID = ? AND D_ID = ?");
1:85fc221:         PreparedStatement pyDistrictInfo = prepareStatement(
1:85fc221:                 "SELECT D_NAME, D_STREET_1, D_STREET_2, D_CITY, D_STATE, D_ZIP FROM DISTRICT WHERE D_W_ID = ? AND D_ID = ? ");
1:85fc221:         PreparedStatement pyWarehouseUpdate = prepareStatement(
1:85fc221:                 "UPDATE WAREHOUSE SET W_YTD = W_YTD + ? WHERE W_ID = ?");
1:85fc221:         PreparedStatement pyWarehouseInfo = prepareStatement(
1:85fc221:                     "SELECT W_NAME, W_STREET_1, W_STREET_2, W_CITY, W_STATE, W_ZIP " +
1:85fc221:                     "FROM WAREHOUSE WHERE W_ID = ?");
1:85fc221:             
1:85fc221:         PreparedStatement pyHistory = prepareStatement(
1:85fc221:                 "INSERT INTO HISTORY(H_C_ID, H_C_D_ID, H_C_W_ID, H_D_ID, H_W_ID, " +
1:85fc221:                 "H_DATE, H_AMOUNT, H_DATA) " +
1:85fc221:                 "VALUES (?, ?, ?, ?, ?, CURRENT TIMESTAMP, ?, ?)");
1:8404f5d:         
1:8404f5d:         Customer customer = new Customer();
1:8404f5d:         customer.setWarehouse(cw);
1:8404f5d:         customer.setDistrict(cd);
1:8404f5d:         customer.setId(c);
1:8404f5d:         
1:8404f5d:         // Update the customer assuming that they have good credit
1:8404f5d:         pyCustomerPayment.setString(1, amount);
1:8404f5d:         pyCustomerPayment.setString(2, amount);
1:8404f5d:         pyCustomerPayment.setShort(3, cw);
1:8404f5d:         pyCustomerPayment.setShort(4, cd);
1:8404f5d:         pyCustomerPayment.setInt(5, c);
1:8404f5d:         pyCustomerPayment.executeUpdate();
1:8404f5d:         
1:8404f5d:         // Get the customer information
1:8404f5d:         pyCustomerInfoId.setShort(1, cw);
1:8404f5d:         pyCustomerInfoId.setShort(2, cd);
1:8404f5d:         pyCustomerInfoId.setInt(3, c);
1:8404f5d:         ResultSet rs = pyCustomerInfoId.executeQuery();
1:8404f5d:         rs.next();
1:8404f5d:         
1:8404f5d:         customer.setFirst(rs.getString("C_FIRST"));
1:8404f5d:         customer.setMiddle(rs.getString("C_MIDDLE"));
1:8404f5d:         customer.setLast(rs.getString("C_LAST"));
1:8404f5d:         customer.setBalance(rs.getString("C_BALANCE"));
1:8404f5d:         
1:8404f5d:         customer.setAddress(getAddress(rs, "C_STREET_1"));
1:8404f5d: 
1:8404f5d:         customer.setPhone(rs.getString("C_PHONE"));
1:8404f5d:         customer.setSince(rs.getTimestamp("C_SINCE"));
1:8404f5d:         customer.setCredit(rs.getString("C_CREDIT"));
1:8404f5d:         customer.setCredit_lim(rs.getString("C_CREDIT_LIM"));
1:8404f5d:         customer.setDiscount(rs.getString("C_DISCOUNT"));
1:8404f5d:         reset(pyCustomerInfoId);
1:8404f5d:         
1:8404f5d:         // additional work for bad credit customers.
1:8404f5d:         if ("BC".equals(customer.getCredit()))
1:8404f5d:         {
1:8404f5d:             pyCustomerUpdateBadCredit.setShort(1, w);
1:8404f5d:             pyCustomerUpdateBadCredit.setShort(2, d);
1:8404f5d:             pyCustomerUpdateBadCredit.setString(3, amount);
1:8404f5d:             pyCustomerUpdateBadCredit.setShort(4, cw);
1:8404f5d:             pyCustomerUpdateBadCredit.setShort(5, cd);
1:8404f5d:             pyCustomerUpdateBadCredit.setInt(6, c);         
1:8404f5d:             pyCustomerUpdateBadCredit.executeUpdate();
1:8404f5d:             reset(pyCustomerUpdateBadCredit);
1:8404f5d:             
1:8404f5d:             // Need to display the first 200 characters
1:8404f5d:             // of C_DATA information if the customer has
1:8404f5d:             // bad credit.
1:8404f5d:             pyCustomerGetData.setShort(1, cw);
1:8404f5d:             pyCustomerGetData.setShort(2, cd);
1:8404f5d:             pyCustomerGetData.setInt(3, c);                     
1:8404f5d:             rs = pyCustomerGetData.executeQuery();
1:8404f5d:             rs.next();
1:8404f5d:             customer.setData(rs.getString("C_DATA_200"));
1:8404f5d:             reset(pyCustomerGetData);
1:8404f5d:         }
1:8404f5d: 
1:57403e7:         district.clear();
1:8404f5d:         district.setWarehouse(w);
1:8404f5d:         district.setId(d);
1:8404f5d: 
1:8404f5d:         // Update DISTRICT
1:8404f5d:         pyDistrictUpdate.setString(1, amount);
1:8404f5d:         pyDistrictUpdate.setShort(2, w);
1:8404f5d:         pyDistrictUpdate.setShort(3, d);
1:8404f5d:         pyDistrictUpdate.executeUpdate();
1:8404f5d:         reset(pyDistrictUpdate);
1:8404f5d: 
1:8404f5d:         // Get the required information from DISTRICT
1:8404f5d:         pyDistrictInfo.setShort(1, w);
1:8404f5d:         pyDistrictInfo.setShort(2, d);
1:8404f5d:         rs = pyDistrictInfo.executeQuery();
1:8404f5d:         rs.next();
1:8404f5d:         district.setName(rs.getString("D_NAME"));
1:8404f5d:         district.setAddress(getAddress(rs, "D_STREET_1"));
1:8404f5d:         reset(pyDistrictInfo);        
1:8404f5d:         
1:57403e7:         warehouse.clear();
1:8404f5d:         warehouse.setId(w);
1:8404f5d:         
1:8404f5d:         // Update WAREHOUSE
1:8404f5d:         pyWarehouseUpdate.setString(1, amount);
1:8404f5d:         pyWarehouseUpdate.setShort(2, w);
1:8404f5d:         pyWarehouseUpdate.executeUpdate();
1:8404f5d:         reset(pyWarehouseUpdate);
1:8404f5d:         
1:8404f5d:         // Get the required information from WAREHOUSE
1:8404f5d:         pyWarehouseInfo.setShort(1, w);
1:8404f5d:         rs = pyWarehouseInfo.executeQuery();
1:8404f5d:         rs.next();
1:8404f5d:         warehouse.setName(rs.getString("W_NAME"));
1:8404f5d:         warehouse.setAddress(getAddress(rs, "W_STREET_1"));
1:8404f5d:         reset(pyWarehouseInfo);
1:8404f5d:          
1:8404f5d:         // Insert HISTORY row
1:8404f5d:         pyHistory.setInt(1, c);
1:8404f5d:         pyHistory.setShort(2, cd);
1:8404f5d:         pyHistory.setShort(3, cw);
1:8404f5d:         pyHistory.setShort(4, d);
1:8404f5d:         pyHistory.setShort(5, w);
1:8404f5d:         pyHistory.setString(6, amount);
1:8404f5d:         StringBuffer hData = new StringBuffer(24);
1:8404f5d:         hData.append(warehouse.getName());
1:8404f5d:         hData.append("    ");
1:8404f5d:         hData.append(district.getName());
1:8404f5d:         pyHistory.setString(7, hData.toString());
1:8404f5d:         pyHistory.executeUpdate();
1:8404f5d:         reset(pyHistory);
1:8404f5d:         
1:8404f5d:         conn.commit();
1:8404f5d:   
1:9f7e882:     }
1:9f7e882:     
1:72a917a:     private static final String[] STOCK_INFO = {
1:72a917a:     "SELECT S_QUANTITY, S_DIST_01, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_02, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_03, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_04, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_05, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_06, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_07, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_08, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_09, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:     "SELECT S_QUANTITY, S_DIST_10, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:72a917a:        };
1:72a917a:     
1:38b4bbb:     public void newOrder(Display display, Object displayData, short w, short d,
1:38b4bbb:             int c, int[] items, short[] quantities, short[] supplyW)
1:38b4bbb:             throws Exception {
1:72a917a:         
1:72a917a:         // This transaction is subject to deadlocks since the
1:72a917a:         // stock table is read and then updated, and multiple
1:72a917a:         // stock items are read and updated in a random order.
1:72a917a:         // to avoid the deadlocks, the items are sorted here.
1:72a917a:         // If some engine did not require sorting then it could
1:72a917a:         // provide a different implementation of this class with
1:72a917a:         // the sort method a no-op.
1:72a917a:         sortOrderItems(items, quantities, supplyW);
1:72a917a:         
1:72a917a:         try {
1:72a917a:             // Get the warehouse tax
1:72a917a:             PreparedStatement psWarehouseTax = prepareStatement(
1:72a917a:                 "SELECT W_TAX FROM WAREHOUSE WHERE W_ID = ?");
1:72a917a:             psWarehouseTax.setShort(1, w);
1:72a917a:             ResultSet rs = psWarehouseTax.executeQuery();
1:1b6c3f0:             rs.next();
1:72a917a:             BigDecimal warehouseTax = (BigDecimal) rs.getObject(1);
1:72a917a:             reset(psWarehouseTax);
1:72a917a:             
1:72a917a:             // Get the district tax and order number including the update.            
1:72a917a:             PreparedStatement psDistrictUpdate = prepareStatement(
1:72a917a:                 "UPDATE DISTRICT SET D_NEXT_O_ID = D_NEXT_O_ID + 1 " +
1:72a917a:                 "WHERE D_W_ID = ? AND D_ID = ?");
1:72a917a:             psDistrictUpdate.setShort(1, w);
1:72a917a:             psDistrictUpdate.setShort(2, d);
1:72a917a:             psDistrictUpdate.executeUpdate();
1:72a917a:             reset(psDistrictUpdate);
1:72a917a: 
1:72a917a:             PreparedStatement psDistrict = prepareStatement(
1:72a917a:                 "SELECT D_NEXT_O_ID - 1, D_TAX " +
1:72a917a:                 "FROM DISTRICT WHERE D_W_ID = ? AND D_ID = ?");
1:72a917a:             psDistrict.setShort(1, w);
1:72a917a:             psDistrict.setShort(2, d);
1:72a917a:             rs = psDistrict.executeQuery();
1:72a917a:             rs.next();
1:72a917a:             int orderNumber = rs.getInt(1);
1:72a917a:             BigDecimal districtTax = (BigDecimal) rs.getObject(2);
1:72a917a:             reset(psDistrict);
1:72a917a:             
1:72a917a:             PreparedStatement psCustomer = prepareStatement(
1:72a917a:                 "SELECT C_LAST, C_DISCOUNT, C_CREDIT " +
1:72a917a:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:72a917a:             psCustomer.setShort(1, w);
1:72a917a:             psCustomer.setShort(2, d);
1:72a917a:             psCustomer.setInt(3, c);
1:72a917a:             rs = psCustomer.executeQuery();
1:72a917a:             rs.next();
1:72a917a:             // TODO fetch data
1:72a917a:             reset(psCustomer);
1:72a917a:             
1:72a917a:             // See if all the items are from the local warehouse.
1:72a917a:             short allLocal = 1;
1:72a917a:             for (int i = 0; i < supplyW.length; i++)
1:72a917a:             {
1:72a917a:                 if (supplyW[i] != w)
1:72a917a:                 {
1:72a917a:                     allLocal = 0;
1:72a917a:                     break;
1:72a917a:                 }
1:72a917a:             }
1:72a917a:             
1:72a917a:             PreparedStatement psOrder = prepareStatement(
1:72a917a:                 "INSERT INTO ORDERS VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, NULL, ?, ?)");
1:72a917a:             psOrder.setInt(1, orderNumber);
1:72a917a:             psOrder.setShort(2, d);
1:72a917a:             psOrder.setShort(3, w);
1:72a917a:             psOrder.setInt(4, c);
1:72a917a:             psOrder.setShort(5, (short) items.length);
1:72a917a:             psOrder.setShort(6, allLocal);
1:72a917a:             psOrder.executeUpdate();
1:72a917a:             reset(psOrder);
1:72a917a: 
1:72a917a:             PreparedStatement psNewOrder = prepareStatement(
1:72a917a:                 "INSERT INTO NEWORDERS VALUES(?, ?, ?)"); 
1:72a917a:             psNewOrder.setInt(1, orderNumber);
1:72a917a:             psNewOrder.setShort(2, d);
1:72a917a:             psNewOrder.setShort(3, w);
1:72a917a:             psNewOrder.executeUpdate();
1:72a917a:             reset(psNewOrder);
1:72a917a:             
1:72a917a:             /*
1:72a917a:              * Now all the processing for the order line items.
1:72a917a:              */
1:72a917a:             PreparedStatement psOrderLine = prepareStatement(
1:72a917a:                 "INSERT INTO ORDERLINE(OL_W_ID, OL_D_ID, OL_O_ID, OL_NUMBER, " +
1:72a917a:                 "OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, OL_DIST_INFO, " +
1:72a917a:                 "OL_DELIVERY_D) VALUES (?, ?, ?, ?, ?, ?, ?, " +
1:72a917a:                 "CAST (? AS DECIMAL(5,2)) * CAST (? AS SMALLINT), ?, NULL)");
1:72a917a:             
1:72a917a:             // These are constant across the order items
1:72a917a:             psOrderLine.setShort(1, w);
1:72a917a:             psOrderLine.setShort(2, d);
1:72a917a:             psOrderLine.setInt(3, orderNumber);
1:72a917a:             
1:72a917a:             PreparedStatement psItemPrice = prepareStatement(
1:72a917a:                     "SELECT I_PRICE, I_NAME, I_DATA FROM ITEM WHERE I_ID = ?");
1:72a917a:             
1:72a917a:             PreparedStatement psStockUpdate = prepareStatement(
1:72a917a:                     "UPDATE STOCK SET S_ORDER_CNT = S_ORDER_CNT + 1, " +
1:72a917a:                     "S_YTD = S_YTD + ?, S_REMOTE_CNT = S_REMOTE_CNT + ?, " +
1:72a917a:                     "S_QUANTITY = ? WHERE S_I_ID = ? AND S_W_ID = ?");
1:72a917a: 
1:72a917a:             for (int i = 0; i < items.length; i++)
1:72a917a:             {
1:72a917a:                 // Item details
1:72a917a:                 psItemPrice.setInt(1, items[i]);
1:72a917a:                 rs = psItemPrice.executeQuery();
1:72a917a:                 rs.next();
1:72a917a:                 BigDecimal itemPrice = (BigDecimal) rs.getObject(1);
1:72a917a:                 String itemName = rs.getString(2);
1:72a917a:                 String itemData = rs.getString(3);
1:72a917a:                 rs.close();
1:72a917a:                 
1:72a917a:                 // SELECT S_QUANTITY, S_DIST_XX, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?
1:72a917a:                 PreparedStatement psStockInfo = prepareStatement(STOCK_INFO[d-1]);
1:72a917a:                 psStockInfo.setInt(1, items[i]);
1:72a917a:                 psStockInfo.setShort(2, w);
1:72a917a:                 rs = psStockInfo.executeQuery();
1:72a917a:                 rs.next();
1:72a917a:                 int stockQuantity = rs.getInt(1);
1:72a917a:                 String stockDistInfo = rs.getString(2);
1:72a917a:                 String stockData = rs.getString(3);
1:72a917a:                 reset(psStockInfo);
1:72a917a: 
1:72a917a:                 psStockUpdate.setInt(1, quantities[i]);
1:72a917a:                 psStockUpdate.setInt(2, w == supplyW[i] ? 0 : 1);
1:72a917a:                 
1:72a917a:                 if ((stockQuantity - quantities[i]) > 10)
1:72a917a:                     stockQuantity -= quantities[i];
1:72a917a:                 else
1:72a917a:                     stockQuantity = (stockQuantity - quantities[i] + 91);
1:72a917a:                 psStockUpdate.setInt(3, stockQuantity);
1:72a917a:                 psStockUpdate.setInt(4, items[i]);
1:72a917a:                 psStockUpdate.setShort(5, w);
1:72a917a:                 psStockUpdate.executeUpdate();
1:72a917a: 
1:72a917a: 
1:72a917a:                 psOrderLine.setShort(4, (short) (i + 1));
1:72a917a:                 psOrderLine.setInt(5, items[i]);
1:72a917a:                 psOrderLine.setShort(6, supplyW[i]);
1:72a917a:                 psOrderLine.setShort(7, quantities[i]);
1:72a917a:                 psOrderLine.setObject(8, itemPrice, Types.DECIMAL);
1:72a917a:                 psOrderLine.setShort(9, quantities[i]);
1:72a917a:                 psOrderLine.setString(10, stockDistInfo);
1:72a917a:                 psOrderLine.executeUpdate();
1:72a917a:             }
1:72a917a:             
1:72a917a:             reset(psOrderLine);
1:72a917a:             reset(psItemPrice);
1:72a917a:             reset(psOrderLine);
1:72a917a:             reset(psStockUpdate);
1:72a917a:             
1:72a917a:             // get the sum of the order. This is done as a select rather than
1:72a917a:             // directly in this code so that all the DECIMAL arithmetic is made
1:72a917a:             // using the SQL engine (since this is a test of Derby).
1:72a917a:             //
1:72a917a: 
1:72a917a:             PreparedStatement psTotal = prepareStatement(
1:72a917a:                 "SELECT SUM(OL_AMOUNT) FROM ORDERLINE " +
1:72a917a:                 "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?");
1:72a917a: 
1:72a917a:             psTotal.setShort(1, w);
1:72a917a:             psTotal.setShort(2, d);
1:72a917a:             psTotal.setInt(3, orderNumber);
1:72a917a:             rs = psTotal.executeQuery();
1:72a917a:             rs.next();
1:72a917a:             BigDecimal orderTotal = (BigDecimal) rs.getObject(1);
1:72a917a:             reset(psTotal);
1:72a917a:  
1:72a917a:             conn.commit();
1:72a917a:         } catch (SQLException e) {
1:72a917a:             conn.rollback();
1:72a917a:         }
1:38b4bbb:     }
1:9f7e882:     
1:8404f5d:     /**
1:24e8abd:      * Schedule a delivery using the database as the queuing
1:24e8abd:      * mechanism and the results file.
1:24e8abd:      * See delivery.sql.
1:24e8abd:      */
1:38b4bbb:     public void scheduleDelivery(Display display, Object displayData, short w,
1:38b4bbb:             short carrier) throws Exception {
1:85fc221:         
1:85fc221:         PreparedStatement sdSchedule = prepareStatement(
1:85fc221:                 "INSERT INTO DELIVERY_REQUEST(DR_W_ID, DR_CARRIER_ID, DR_STATE) " +
1:85fc221:                 "VALUES(?, ?, 'Q')");
1:85fc221:         
1:24e8abd:         int isolation = conn.getTransactionIsolation(); 
1:24e8abd:         try {
1:24e8abd: 
1:24e8abd:             conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:24e8abd:             
1:24e8abd:             sdSchedule.setShort(1, w);
1:24e8abd:             sdSchedule.setShort(2, carrier);
1:24e8abd:             sdSchedule.executeUpdate();
1:24e8abd:             reset(sdSchedule);
1:24e8abd:             conn.commit();
1:24e8abd:         } finally {
1:24e8abd:             conn.setTransactionIsolation(isolation);
1:24e8abd:         }
1:24e8abd:         
1:24e8abd:         if (display != null)
1:24e8abd:             display.displayScheduleDelivery(displayData, w, carrier);
1:24e8abd:     }
1:24e8abd:     
1:24e8abd:     public void delivery() throws Exception {
1:24e8abd:         
1:85fc221:         PreparedStatement dlFindOldestRequest = prepareStatement(
1:85fc221:                 "SELECT DR_ID, DR_W_ID, DR_CARRIER_ID FROM DELIVERY_REQUEST " +
1:85fc221:                 "WHERE DR_STATE = 'Q' ORDER BY DR_QUEUED");
1:85fc221:             dlFindOldestRequest.setMaxRows(1);
1:85fc221:             
1:85fc221:             PreparedStatement dlSetRequestState = prepareStatement(
1:85fc221:                 "UPDATE DELIVERY_REQUEST SET DR_STATE = ? " +
1:85fc221:                 "WHERE DR_ID = ?");
1:85fc221:             PreparedStatement dlCompleteDelivery = prepareStatement(
1:85fc221:                 "UPDATE DELIVERY_REQUEST SET DR_STATE = 'C', DR_COMPLETED = CURRENT TIMESTAMP " +
1:85fc221:                 "WHERE DR_ID = ?");
1:85fc221:             
1:85fc221:             PreparedStatement dlFindOrderToDeliver = prepareStatement(
1:85fc221:                 "SELECT MIN(NO_O_ID) AS ORDER_TO_DELIVER FROM NEWORDERS " +
1:85fc221:                 "WHERE NO_W_ID = ? AND NO_D_ID = ?");
1:85fc221:             
1:85fc221:             PreparedStatement dlDeleteNewOrder = prepareStatement(
1:85fc221:                 "DELETE FROM NEWORDERS WHERE NO_W_ID = ? AND NO_D_ID = ? AND NO_O_ID = ?");
1:85fc221:             
1:85fc221:             PreparedStatement dlSetOrderCarrier = prepareStatement(
1:85fc221:                 "UPDATE ORDERS SET O_CARRIER_ID = ? " +
1:85fc221:                 "WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?");
1:85fc221:             
1:85fc221:             PreparedStatement dlSetOrderlineDate = prepareStatement(
1:85fc221:                 "UPDATE ORDERLINE SET OL_DELIVERY_D = CURRENT TIMESTAMP " +
1:85fc221:                 "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?");
1:85fc221:             
1:85fc221:             
1:85fc221:             PreparedStatement dlUpdateCustomer = prepareStatement(
1:85fc221:                 "UPDATE CUSTOMER SET " +
1:85fc221:                 "C_BALANCE = (SELECT SUM(OL_AMOUNT) FROM ORDERLINE " +
1:85fc221:                               "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?), " +
1:85fc221:                 "C_DELIVERY_CNT = C_DELIVERY_CNT + 1 " +
1:85fc221:                 "WHERE C_W_ID = ? AND C_D_ID = ? AND " +
1:85fc221:                 "C_ID = (SELECT O_C_ID FROM ORDERS " +
1:85fc221:                         "WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?)");
1:85fc221:             
1:85fc221:             PreparedStatement dlRecordDelivery = prepareStatement(
1:85fc221:                 "INSERT INTO DELIVERY_ORDERS(DO_DR_ID, DO_D_ID, DO_O_ID) " +
1:85fc221:                 "VALUES (?, ?, ?)");
1:85fc221: 
1:85fc221:         
1:24e8abd:         // Find the most oldest queued order (FIFO)
1:24e8abd:         ResultSet rs = dlFindOldestRequest.executeQuery();
1:24e8abd:         rs.next();
1:24e8abd:         int request = rs.getInt("DR_ID");
1:24e8abd:         short w = rs.getShort("DR_W_ID");
1:24e8abd:         short carrier = rs.getShort("DR_CARRIER_ID");
1:24e8abd:         reset(dlFindOldestRequest);
1:24e8abd:         
1:24e8abd:         // Mark it as in progress
1:24e8abd:         dlSetRequestState.setString(1, "I");
1:24e8abd:         dlSetRequestState.setInt(2, request);
1:24e8abd:         dlSetRequestState.executeUpdate();
1:24e8abd:         reset(dlSetRequestState);
1:24e8abd:         
1:24e8abd:         conn.commit();
1:24e8abd:         
1:24e8abd:         // This parameter remains invariant over
1:24e8abd:         // the batch we will insert.
1:24e8abd:         dlRecordDelivery.setInt(1, request);
1:24e8abd:         
1:24e8abd:         // Process one row per-district for this warehouse
1:24e8abd:         for (short d = 1; d <= 10; d++)
1:24e8abd:         {
1:24e8abd:             dlRecordDelivery.setShort(2, d);
1:24e8abd: 
1:24e8abd:             // Get the oldest NEWORDERS for this district
1:24e8abd:             dlFindOrderToDeliver.setShort(1, w);
1:24e8abd:             dlFindOrderToDeliver.setShort(2, d);
1:24e8abd:             rs = dlFindOrderToDeliver.executeQuery();
1:24e8abd:             rs.next();
1:24e8abd:             int order = rs.getInt("ORDER_TO_DELIVER");
1:24e8abd:             if (rs.wasNull()) {
1:24e8abd:                 // No orders to deliver
1:24e8abd:                 dlRecordDelivery.setNull(3, Types.INTEGER);
1:24e8abd:                 dlRecordDelivery.addBatch();
1:24e8abd:             }
1:24e8abd:             reset(dlFindOrderToDeliver);
1:24e8abd:             
1:24e8abd:             // Delete the NEWORDERS row
1:24e8abd:             dlDeleteNewOrder.setShort(1, w);
1:24e8abd:             dlDeleteNewOrder.setShort(2, d);
1:24e8abd:             dlDeleteNewOrder.setInt(3, order);
1:24e8abd:             dlDeleteNewOrder.executeUpdate();
1:24e8abd:             reset(dlDeleteNewOrder);
1:24e8abd:             
1:24e8abd:             // Set the carrier in ORDERS
1:24e8abd:             dlSetOrderCarrier.setShort(1, carrier);
1:24e8abd:             dlSetOrderCarrier.setShort(2, w);
1:24e8abd:             dlSetOrderCarrier.setShort(3, d);
1:24e8abd:             dlSetOrderCarrier.setInt(4, order);
1:24e8abd:             dlSetOrderCarrier.executeUpdate();
1:24e8abd:             reset(dlSetOrderCarrier);
1:24e8abd:             
1:24e8abd:             // Update ORDERLINE with the delivery date
1:24e8abd:             dlSetOrderlineDate.setShort(1, w);
1:24e8abd:             dlSetOrderlineDate.setShort(2, d);
1:24e8abd:             dlSetOrderlineDate.setInt(3, order);
1:24e8abd:             dlSetOrderlineDate.executeUpdate();
1:24e8abd:             reset(dlSetOrderlineDate);
1:24e8abd:             
1:24e8abd:             dlUpdateCustomer.setShort(1, w);
1:24e8abd:             dlUpdateCustomer.setShort(2, d);
1:24e8abd:             dlUpdateCustomer.setInt(3, order);
1:24e8abd:             dlUpdateCustomer.setShort(4, w);
1:24e8abd:             dlUpdateCustomer.setShort(5, d);
1:24e8abd:             dlUpdateCustomer.setShort(6, w);
1:24e8abd:             dlUpdateCustomer.setShort(7, d);
1:24e8abd:             dlUpdateCustomer.setInt(8, order);
1:24e8abd:             dlUpdateCustomer.executeUpdate();
1:24e8abd:             reset(dlUpdateCustomer);
1:24e8abd:                       
1:24e8abd:             conn.commit();
1:24e8abd:             
1:24e8abd:             dlRecordDelivery.setInt(3, order);
1:24e8abd:             dlRecordDelivery.addBatch();
1:24e8abd:         }
1:24e8abd:         
1:24e8abd:         // Record the delivery including the timestamp
1:24e8abd:         // 90% are meant to complete within 80 seconds
1:24e8abd:         // of them being queued.
1:24e8abd:         dlRecordDelivery.executeBatch();
1:24e8abd:         reset(dlRecordDelivery);
1:24e8abd:         dlCompleteDelivery.setInt(1, request);
1:24e8abd:         dlCompleteDelivery.executeUpdate();
1:24e8abd:         reset(dlCompleteDelivery);
1:24e8abd:         conn.commit();
1:24e8abd:         
1:24e8abd:     }
1:24e8abd: 
1:72a917a:     public void sortOrderItems(int[] items, short[] quantities, short[] supplyW) {
1:72a917a: 
1:72a917a:         OrderItem4Sort[] list = new OrderItem4Sort[items.length];
1:72a917a: 
1:72a917a:         for (int i = 0; i < items.length; i++)
1:72a917a:         {
1:72a917a:             list[i] = new OrderItem4Sort(items[i], quantities[i], supplyW[i]);
1:72a917a:         }
1:72a917a: 
1:72a917a:         java.util.Arrays.sort(list);
1:72a917a: 
1:72a917a:         for (int i = 0; i < items.length; i++)
1:72a917a:         {
1:72a917a:             items[i] = list[i].i;
1:72a917a:             quantities[i] = list[i].q;
1:72a917a:             supplyW[i] = list[i].w;
1:72a917a:         }
1:72a917a:     }
1:72a917a: }
1:72a917a: 
1:72a917a: class OrderItem4Sort implements Comparable {
1:72a917a: 
1:72a917a:     final int i;
1:72a917a:     final short q;
1:72a917a:     final short w;
1:72a917a: 
1:72a917a:     OrderItem4Sort(int i, short q, short w)
1:72a917a:     {
1:72a917a:         this.i = i;
1:72a917a:         this.q = q;
1:72a917a:         this.w = w;
1:72a917a:     }
1:72a917a: 
1:72a917a: 
1:72a917a:     public int compareTo(Object o) {
1:72a917a: 
1:72a917a:         OrderItem4Sort oo = (OrderItem4Sort) o;
1:72a917a: 
1:72a917a:         if (w < oo.w)
1:72a917a:             return -1;
1:72a917a:         if (w > oo.w)
1:72a917a:             return 1;
1:72a917a:         if (i < oo.i)
1:72a917a:             return -1;
1:72a917a:         if (i > oo.i)
1:72a917a:             return 1;
1:72a917a:         return 0;
1:72a917a:     }
1:24e8abd: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9d44c9e
/////////////////////////////////////////////////////////////////////////
1:     private final List<Object> nameList = new ArrayList<Object>();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a6358d6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class Standard extends StatementHelper implements Operations {
/////////////////////////////////////////////////////////////////////////
1:         super(conn, false, Connection.TRANSACTION_SERIALIZABLE);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:57403e7
/////////////////////////////////////////////////////////////////////////
1:  * <P>
1:  * Object is single threaded so it re-uses objects
1:  * where possible to avoid the garbage collection
1:  * due to the application affecting the results
1:  * too much since the purpose of the framework
1:  * is to test Derby's performance.
1:     
1:     /*
1:      * Objects for re-use within the transactions
1:      */
1:     
1:     private final Customer customer = new Customer();
1:     
1:     private final Warehouse warehouse = new Warehouse();
1:     
1:     private final District district = new District();
1:     
1:     private final Order order = new Order();
1:     
0:     private final List nameList = new ArrayList();
1: 
/////////////////////////////////////////////////////////////////////////
1:             nameList.clear();
/////////////////////////////////////////////////////////////////////////
1:                 nameList.add(customer);
1:             if (nameList.isEmpty())
1:             int mid = nameList.size()/2;
1:                 if (nameList.size()%2 == 1)
1:             Customer customer = (Customer) nameList.get(mid);
1:             nameList.clear();
/////////////////////////////////////////////////////////////////////////
1:         customer.clear();
/////////////////////////////////////////////////////////////////////////
1:         order.clear();
/////////////////////////////////////////////////////////////////////////
1:             nameList.clear();
1:                 nameList.add(rs.getObject("C_ID"));            
1:             if (nameList.isEmpty())
1:             int mid = nameList.size()/2;
1:                 if (nameList.size()%2 == 1)
1:             int c = ((Integer) nameList.get(mid)).intValue();
/////////////////////////////////////////////////////////////////////////
1:         district.clear();
/////////////////////////////////////////////////////////////////////////
1:         warehouse.clear();
commit:412e7b7
/////////////////////////////////////////////////////////////////////////
1:             if (mid != 0) {
0:                 if (list.size()%2 == 1)
1:                     mid++;
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (mid != 0) {
0:                 if (list.size()%2 == 1)
1:                     mid++;
1:             }
commit:31ad846
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             int mid = list.size()/2;
0:             if (list.size()%2 == 1)
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             int mid = list.size()/2;
0:             if (list.size()%2 == 1)
commit:1b6c3f0
/////////////////////////////////////////////////////////////////////////
1:      * Return an Operations implementation based upon
1:      * Standard with a single difference. In this implementation
1:      * the reset() executed after each PreparedStatement execute
1:      * does nothing. Sees if there is any performance impact
1:      * of explicitly closing each ResultSet and clearing the
1:      * parameters.
1:      * <P>
1:      * Each ResultSet will be closed implicitly either at commit
1:      * time or at the next execution of the same PreparedStatement object.
1:      */
1:     public static Operations noReset(final Connection conn)
1:         throws SQLException
1:     {
1:         return new Standard(conn) {
1:             protected void reset(PreparedStatement ps) {}
1:         };
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             rs.next();
/////////////////////////////////////////////////////////////////////////
0:     protected void reset(PreparedStatement ps) throws SQLException
/////////////////////////////////////////////////////////////////////////
commit:85fc221
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // Prepare all statements as forward-only, read-only, close at commit.
0:         ps = conn.prepareStatement(sql,
0:                 ResultSet.TYPE_FORWARD_ONLY,
0:                 ResultSet.CONCUR_READ_ONLY,
0:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:     /**
/////////////////////////////////////////////////////////////////////////
1:                 
1:                 PreparedStatement sl1 = prepareStatement(
1:                         "SELECT D_NEXT_O_ID FROM DISTRICT WHERE D_W_ID = ? AND D_ID = ?");
1: 
1:                 PreparedStatement sl2 = prepareStatement(
1:                         "SELECT COUNT(DISTINCT(S_I_ID)) AS LOW_STOCK FROM ORDERLINE, STOCK " +
1:                         "WHERE OL_W_ID = ? AND OL_D_ID = ? " +
1:                         "AND OL_O_ID < ? AND OL_O_ID >= ? " +
1:                         "AND S_W_ID = ? AND S_I_ID = OL_I_ID AND S_QUANTITY < ?");
/////////////////////////////////////////////////////////////////////////
1:             conn.setTransactionIsolation(isolation);
1:        
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement osCustomerByName = prepareStatement(
1:                 "SELECT C_ID, C_BALANCE, C_FIRST, C_MIDDLE " +
1:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_LAST = ? " +
1:                 "ORDER BY C_FIRST");
1:         
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement osCustomerById = prepareStatement(
1:                 "SELECT C_BALANCE, C_FIRST, C_MIDDLE, C_LAST " +
1:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:         
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement osLastOrderNumber = prepareStatement(
1:                 "SELECT MAX(O_ID) AS LAST_ORDER FROM ORDERS " +
1:                 "WHERE O_W_ID = ? AND O_D_ID = ? AND O_C_ID = ?");
1:         PreparedStatement osOrderDetails = prepareStatement(
1:                 "SELECT O_ENTRY_D, O_CARRIER_ID, O_OL_CNT " +
1:                 "FROM ORDERS WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?");
1:         PreparedStatement osOrderLineItems = prepareStatement(
1:                 "SELECT OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, " +
1:                 "OL_DELIVERY_D FROM ORDERLINE " +
1:                 "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?");
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             
1:         PreparedStatement pyCustomerByName = prepareStatement(
1:                     "SELECT C_ID " +
1:                     "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_LAST = ? " +
1:                     "ORDER BY C_FIRST");
/////////////////////////////////////////////////////////////////////////
1: 
1:         PreparedStatement pyCustomerPayment = prepareStatement(
1:                 "UPDATE CUSTOMER SET C_BALANCE = C_BALANCE - ?, " +
1:                 "C_YTD_PAYMENT = C_YTD_PAYMENT + ?, " +
1:                 "C_PAYMENT_CNT = C_PAYMENT_CNT + 1 " +
1:                 "WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:             
1:         PreparedStatement pyCustomerInfoId = prepareStatement(
1:                 "SELECT C_FIRST, C_MIDDLE, C_LAST, C_BALANCE, " +
1:                 "C_STREET_1, C_STREET_2, C_CITY, C_STATE, C_ZIP, " +
1:                 "C_PHONE, C_SINCE, C_CREDIT, C_CREDIT_LIM, C_DISCOUNT " +
1:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:         
1:         PreparedStatement pyCustomerUpdateBadCredit = prepareStatement(
1:                 "UPDATE CUSTOMER SET C_DATA = " +
1:                 " BAD_CREDIT_DATA(C_DATA, ?, ?, C_W_ID, C_W_ID, C_ID, ?) " +
1:                 "WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:         PreparedStatement pyCustomerGetData = prepareStatement(
1:                 "SELECT SUBSTR(C_DATA, 1, 200) AS C_DATA_200 " +
1:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:             
1:         PreparedStatement pyDistrictUpdate = prepareStatement(
1:                 "UPDATE DISTRICT SET D_YTD = D_YTD + ? WHERE D_W_ID = ? AND D_ID = ?");
1:         PreparedStatement pyDistrictInfo = prepareStatement(
1:                 "SELECT D_NAME, D_STREET_1, D_STREET_2, D_CITY, D_STATE, D_ZIP FROM DISTRICT WHERE D_W_ID = ? AND D_ID = ? ");
1:         PreparedStatement pyWarehouseUpdate = prepareStatement(
1:                 "UPDATE WAREHOUSE SET W_YTD = W_YTD + ? WHERE W_ID = ?");
1:         PreparedStatement pyWarehouseInfo = prepareStatement(
1:                     "SELECT W_NAME, W_STREET_1, W_STREET_2, W_CITY, W_STATE, W_ZIP " +
1:                     "FROM WAREHOUSE WHERE W_ID = ?");
1:             
1:         PreparedStatement pyHistory = prepareStatement(
1:                 "INSERT INTO HISTORY(H_C_ID, H_C_D_ID, H_C_W_ID, H_D_ID, H_W_ID, " +
1:                 "H_DATE, H_AMOUNT, H_DATA) " +
1:                 "VALUES (?, ?, ?, ?, ?, CURRENT TIMESTAMP, ?, ?)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
1:         PreparedStatement sdSchedule = prepareStatement(
1:                 "INSERT INTO DELIVERY_REQUEST(DR_W_ID, DR_CARRIER_ID, DR_STATE) " +
1:                 "VALUES(?, ?, 'Q')");
1:         
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement dlFindOldestRequest = prepareStatement(
1:                 "SELECT DR_ID, DR_W_ID, DR_CARRIER_ID FROM DELIVERY_REQUEST " +
1:                 "WHERE DR_STATE = 'Q' ORDER BY DR_QUEUED");
1:             dlFindOldestRequest.setMaxRows(1);
1:             
1:             PreparedStatement dlSetRequestState = prepareStatement(
1:                 "UPDATE DELIVERY_REQUEST SET DR_STATE = ? " +
1:                 "WHERE DR_ID = ?");
1:             PreparedStatement dlCompleteDelivery = prepareStatement(
1:                 "UPDATE DELIVERY_REQUEST SET DR_STATE = 'C', DR_COMPLETED = CURRENT TIMESTAMP " +
1:                 "WHERE DR_ID = ?");
1:             
1:             PreparedStatement dlFindOrderToDeliver = prepareStatement(
1:                 "SELECT MIN(NO_O_ID) AS ORDER_TO_DELIVER FROM NEWORDERS " +
1:                 "WHERE NO_W_ID = ? AND NO_D_ID = ?");
1:             
1:             PreparedStatement dlDeleteNewOrder = prepareStatement(
1:                 "DELETE FROM NEWORDERS WHERE NO_W_ID = ? AND NO_D_ID = ? AND NO_O_ID = ?");
1:             
1:             PreparedStatement dlSetOrderCarrier = prepareStatement(
1:                 "UPDATE ORDERS SET O_CARRIER_ID = ? " +
1:                 "WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?");
1:             
1:             PreparedStatement dlSetOrderlineDate = prepareStatement(
1:                 "UPDATE ORDERLINE SET OL_DELIVERY_D = CURRENT TIMESTAMP " +
1:                 "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?");
1:             
1:             
1:             PreparedStatement dlUpdateCustomer = prepareStatement(
1:                 "UPDATE CUSTOMER SET " +
1:                 "C_BALANCE = (SELECT SUM(OL_AMOUNT) FROM ORDERLINE " +
1:                               "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?), " +
1:                 "C_DELIVERY_CNT = C_DELIVERY_CNT + 1 " +
1:                 "WHERE C_W_ID = ? AND C_D_ID = ? AND " +
1:                 "C_ID = (SELECT O_C_ID FROM ORDERS " +
1:                         "WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?)");
1:             
1:             PreparedStatement dlRecordDelivery = prepareStatement(
1:                 "INSERT INTO DELIVERY_ORDERS(DO_DR_ID, DO_D_ID, DO_O_ID) " +
1:                 "VALUES (?, ?, ?)");
1: 
1:         
/////////////////////////////////////////////////////////////////////////
1:               
commit:72a917a
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
0: import java.util.IdentityHashMap;
0: import java.util.Iterator;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Map of SQL text to its PreparedStatement.
0:      * This allows the SQL text to be in-line with
0:      * code that sets the parameters and looks at 
0:      * the results. Map is on the identity of the SQL
0:      * string which assumes they are all constants
0:      * (and hence interned). Assumption is that this
0:      * will provide for a quicker lookup than by text
0:      * since the statements can be many characters.
0:      * Only the new order transaction uses this map
0:      * now, the others should be converted as need arises
0:      * to have a simple, single model. Then the setup methods
0:      * can be removed.
1:      * 
0:      * May also allow easier sharing with other implementations
0:      * such as a Java procedure which could have a different
0:      * prepareStatement method.
1:      */
0:     private Map statements = new IdentityHashMap();
1:     
1:     /**
0:      * Prepare a statement, looking in the map first.
0:      * If the statement does not exist in the map then
0:      * it is prepared and put into the map for future use.
1:      */
0:     PreparedStatement prepareStatement(String sql) throws SQLException {
0:         PreparedStatement ps = (PreparedStatement) statements.get(sql);
0:         if (ps != null)
0:             return ps;
1:         
0:         ps = prepare(sql);
0:         statements.put(sql, ps);
0:         return ps;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         
1:     private static final String[] STOCK_INFO = {
1:     "SELECT S_QUANTITY, S_DIST_01, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_02, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_03, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_04, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_05, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_06, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_07, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_08, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_09, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:     "SELECT S_QUANTITY, S_DIST_10, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?",
1:        };
1:     
1:         
1:         // This transaction is subject to deadlocks since the
1:         // stock table is read and then updated, and multiple
1:         // stock items are read and updated in a random order.
1:         // to avoid the deadlocks, the items are sorted here.
1:         // If some engine did not require sorting then it could
1:         // provide a different implementation of this class with
1:         // the sort method a no-op.
1:         sortOrderItems(items, quantities, supplyW);
1:         
1:         try {
1:             // Get the warehouse tax
1:             PreparedStatement psWarehouseTax = prepareStatement(
1:                 "SELECT W_TAX FROM WAREHOUSE WHERE W_ID = ?");
1:             psWarehouseTax.setShort(1, w);
1:             ResultSet rs = psWarehouseTax.executeQuery();
1:             BigDecimal warehouseTax = (BigDecimal) rs.getObject(1);
1:             reset(psWarehouseTax);
1:             
1:             // Get the district tax and order number including the update.            
1:             PreparedStatement psDistrictUpdate = prepareStatement(
1:                 "UPDATE DISTRICT SET D_NEXT_O_ID = D_NEXT_O_ID + 1 " +
1:                 "WHERE D_W_ID = ? AND D_ID = ?");
1:             psDistrictUpdate.setShort(1, w);
1:             psDistrictUpdate.setShort(2, d);
1:             psDistrictUpdate.executeUpdate();
1:             reset(psDistrictUpdate);
1: 
1:             PreparedStatement psDistrict = prepareStatement(
1:                 "SELECT D_NEXT_O_ID - 1, D_TAX " +
1:                 "FROM DISTRICT WHERE D_W_ID = ? AND D_ID = ?");
1:             psDistrict.setShort(1, w);
1:             psDistrict.setShort(2, d);
1:             rs = psDistrict.executeQuery();
1:             rs.next();
1:             int orderNumber = rs.getInt(1);
1:             BigDecimal districtTax = (BigDecimal) rs.getObject(2);
1:             reset(psDistrict);
1:             
1:             PreparedStatement psCustomer = prepareStatement(
1:                 "SELECT C_LAST, C_DISCOUNT, C_CREDIT " +
1:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:             psCustomer.setShort(1, w);
1:             psCustomer.setShort(2, d);
1:             psCustomer.setInt(3, c);
1:             rs = psCustomer.executeQuery();
1:             rs.next();
1:             // TODO fetch data
1:             reset(psCustomer);
1:             
1:             // See if all the items are from the local warehouse.
1:             short allLocal = 1;
1:             for (int i = 0; i < supplyW.length; i++)
1:             {
1:                 if (supplyW[i] != w)
1:                 {
1:                     allLocal = 0;
1:                     break;
1:                 }
1:             }
1:             
1:             PreparedStatement psOrder = prepareStatement(
1:                 "INSERT INTO ORDERS VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, NULL, ?, ?)");
1:             psOrder.setInt(1, orderNumber);
1:             psOrder.setShort(2, d);
1:             psOrder.setShort(3, w);
1:             psOrder.setInt(4, c);
1:             psOrder.setShort(5, (short) items.length);
1:             psOrder.setShort(6, allLocal);
1:             psOrder.executeUpdate();
1:             reset(psOrder);
1: 
1:             PreparedStatement psNewOrder = prepareStatement(
1:                 "INSERT INTO NEWORDERS VALUES(?, ?, ?)"); 
1:             psNewOrder.setInt(1, orderNumber);
1:             psNewOrder.setShort(2, d);
1:             psNewOrder.setShort(3, w);
1:             psNewOrder.executeUpdate();
1:             reset(psNewOrder);
1:             
1:             /*
1:              * Now all the processing for the order line items.
1:              */
1:             PreparedStatement psOrderLine = prepareStatement(
1:                 "INSERT INTO ORDERLINE(OL_W_ID, OL_D_ID, OL_O_ID, OL_NUMBER, " +
1:                 "OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, OL_DIST_INFO, " +
1:                 "OL_DELIVERY_D) VALUES (?, ?, ?, ?, ?, ?, ?, " +
1:                 "CAST (? AS DECIMAL(5,2)) * CAST (? AS SMALLINT), ?, NULL)");
1:             
1:             // These are constant across the order items
1:             psOrderLine.setShort(1, w);
1:             psOrderLine.setShort(2, d);
1:             psOrderLine.setInt(3, orderNumber);
1:             
1:             PreparedStatement psItemPrice = prepareStatement(
1:                     "SELECT I_PRICE, I_NAME, I_DATA FROM ITEM WHERE I_ID = ?");
1:             
1:             PreparedStatement psStockUpdate = prepareStatement(
1:                     "UPDATE STOCK SET S_ORDER_CNT = S_ORDER_CNT + 1, " +
1:                     "S_YTD = S_YTD + ?, S_REMOTE_CNT = S_REMOTE_CNT + ?, " +
1:                     "S_QUANTITY = ? WHERE S_I_ID = ? AND S_W_ID = ?");
1: 
1:             for (int i = 0; i < items.length; i++)
1:             {
1:                 // Item details
1:                 psItemPrice.setInt(1, items[i]);
1:                 rs = psItemPrice.executeQuery();
1:                 rs.next();
1:                 BigDecimal itemPrice = (BigDecimal) rs.getObject(1);
1:                 String itemName = rs.getString(2);
1:                 String itemData = rs.getString(3);
1:                 rs.close();
1:                 
1:                 // SELECT S_QUANTITY, S_DIST_XX, S_DATA FROM STOCK WHERE S_I_ID = ? AND S_W_ID = ?
1:                 PreparedStatement psStockInfo = prepareStatement(STOCK_INFO[d-1]);
1:                 psStockInfo.setInt(1, items[i]);
1:                 psStockInfo.setShort(2, w);
1:                 rs = psStockInfo.executeQuery();
1:                 rs.next();
1:                 int stockQuantity = rs.getInt(1);
1:                 String stockDistInfo = rs.getString(2);
1:                 String stockData = rs.getString(3);
1:                 reset(psStockInfo);
1: 
1:                 psStockUpdate.setInt(1, quantities[i]);
1:                 psStockUpdate.setInt(2, w == supplyW[i] ? 0 : 1);
1:                 
1:                 if ((stockQuantity - quantities[i]) > 10)
1:                     stockQuantity -= quantities[i];
1:                 else
1:                     stockQuantity = (stockQuantity - quantities[i] + 91);
1:                 psStockUpdate.setInt(3, stockQuantity);
1:                 psStockUpdate.setInt(4, items[i]);
1:                 psStockUpdate.setShort(5, w);
1:                 psStockUpdate.executeUpdate();
1: 
1: 
1:                 psOrderLine.setShort(4, (short) (i + 1));
1:                 psOrderLine.setInt(5, items[i]);
1:                 psOrderLine.setShort(6, supplyW[i]);
1:                 psOrderLine.setShort(7, quantities[i]);
1:                 psOrderLine.setObject(8, itemPrice, Types.DECIMAL);
1:                 psOrderLine.setShort(9, quantities[i]);
1:                 psOrderLine.setString(10, stockDistInfo);
1:                 psOrderLine.executeUpdate();
1:             }
1:             
1:             reset(psOrderLine);
1:             reset(psItemPrice);
1:             reset(psOrderLine);
1:             reset(psStockUpdate);
1:             
1:             // get the sum of the order. This is done as a select rather than
1:             // directly in this code so that all the DECIMAL arithmetic is made
1:             // using the SQL engine (since this is a test of Derby).
1:             //
1: 
1:             PreparedStatement psTotal = prepareStatement(
1:                 "SELECT SUM(OL_AMOUNT) FROM ORDERLINE " +
1:                 "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?");
1: 
1:             psTotal.setShort(1, w);
1:             psTotal.setShort(2, d);
1:             psTotal.setInt(3, orderNumber);
1:             rs = psTotal.executeQuery();
1:             rs.next();
1:             BigDecimal orderTotal = (BigDecimal) rs.getObject(1);
1:             reset(psTotal);
1:  
1:             conn.commit();
1:         } catch (SQLException e) {
1:             conn.rollback();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         
0:         for (Iterator i = statements.keySet().iterator(); i.hasNext(); )
1:         {
0:             String sql = (String) i.next();
0:             PreparedStatement ps = (PreparedStatement) statements.get(sql);
0:             ps.close();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     public void sortOrderItems(int[] items, short[] quantities, short[] supplyW) {
1: 
1:         OrderItem4Sort[] list = new OrderItem4Sort[items.length];
1: 
1:         for (int i = 0; i < items.length; i++)
1:         {
1:             list[i] = new OrderItem4Sort(items[i], quantities[i], supplyW[i]);
1:         }
1: 
1:         java.util.Arrays.sort(list);
1: 
1:         for (int i = 0; i < items.length; i++)
1:         {
1:             items[i] = list[i].i;
1:             quantities[i] = list[i].q;
1:             supplyW[i] = list[i].w;
1:         }
1:     }
1: }
1: 
1: class OrderItem4Sort implements Comparable {
1: 
1:     final int i;
1:     final short q;
1:     final short w;
1: 
1:     OrderItem4Sort(int i, short q, short w)
1:     {
1:         this.i = i;
1:         this.q = q;
1:         this.w = w;
1:     }
1: 
1: 
1:     public int compareTo(Object o) {
1: 
1:         OrderItem4Sort oo = (OrderItem4Sort) o;
1: 
1:         if (w < oo.w)
1:             return -1;
1:         if (w > oo.w)
1:             return 1;
1:         if (i < oo.i)
1:             return -1;
1:         if (i > oo.i)
1:             return 1;
1:         return 0;
1:     }
commit:24e8abd
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Field;
0: import java.sql.Statement;
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:         int lowStock;
/////////////////////////////////////////////////////////////////////////
1:                 lowStock = rs.getInt("LOW_STOCK");
/////////////////////////////////////////////////////////////////////////
1:             display.displayStockLevel(displayData, w, d, threshold, lowStock);
/////////////////////////////////////////////////////////////////////////
1:     
0:     private PreparedStatement sdSchedule;
1:     
0:         sdSchedule = prepare(
0:            "INSERT INTO DELIVERY_REQUEST(DR_W_ID, DR_CARRIER_ID, DR_STATE) " +
0:            "VALUES(?, ?, 'Q')");
1:     
1:     /**
1:      * Schedule a delivery using the database as the queuing
1:      * mechanism and the results file.
1:      * See delivery.sql.
1:      */
1:         int isolation = conn.getTransactionIsolation(); 
1:         try {
1: 
1:             conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:             
1:             sdSchedule.setShort(1, w);
1:             sdSchedule.setShort(2, carrier);
1:             sdSchedule.executeUpdate();
1:             reset(sdSchedule);
1:             conn.commit();
1:         } finally {
1:             conn.setTransactionIsolation(isolation);
1:         }
1:         
1:         if (display != null)
1:             display.displayScheduleDelivery(displayData, w, carrier);
1:     }
1:     
0:     private PreparedStatement dlFindOldestRequest;
0:     private PreparedStatement dlSetRequestState;
0:     private PreparedStatement dlFindOrderToDeliver;
0:     private PreparedStatement dlDeleteNewOrder;
0:     private PreparedStatement dlSetOrderCarrier;
0:     private PreparedStatement dlSetOrderlineDate;
0:     private PreparedStatement dlUpdateCustomer;
0:     private PreparedStatement dlRecordDelivery;
0:     private PreparedStatement dlCompleteDelivery;
1:     
1:     
0:     public void setupDelivery() throws Exception {
1: 
0:         dlFindOldestRequest = prepare(
0:             "SELECT DR_ID, DR_W_ID, DR_CARRIER_ID FROM DELIVERY_REQUEST " +
0:             "WHERE DR_STATE = 'Q' ORDER BY DR_QUEUED");
0:         dlFindOldestRequest.setMaxRows(1);
1:         
0:         dlSetRequestState = prepare(
0:             "UPDATE DELIVERY_REQUEST SET DR_STATE = ? " +
0:             "WHERE DR_ID = ?");
0:         dlCompleteDelivery = prepare(
0:             "UPDATE DELIVERY_REQUEST SET DR_STATE = 'C', DR_COMPLETED = CURRENT TIMESTAMP " +
0:             "WHERE DR_ID = ?");
1:         
0:         dlFindOrderToDeliver = prepare(
0:             "SELECT MIN(NO_O_ID) AS ORDER_TO_DELIVER FROM NEWORDERS " +
0:             "WHERE NO_W_ID = ? AND NO_D_ID = ?");
1:         
0:         dlDeleteNewOrder = prepare(
0:             "DELETE FROM NEWORDERS WHERE NO_W_ID = ? AND NO_D_ID = ? AND NO_O_ID = ?");
1:         
0:         dlSetOrderCarrier = prepare(
0:             "UPDATE ORDERS SET O_CARRIER_ID = ? " +
0:             "WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?");
1:         
0:         dlSetOrderlineDate = prepare(
0:             "UPDATE ORDERLINE SET OL_DELIVERY_D = CURRENT TIMESTAMP " +
0:             "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?");
1:         
1:         
0:         dlUpdateCustomer = prepare(
0:             "UPDATE CUSTOMER SET " +
0:             "C_BALANCE = (SELECT SUM(OL_AMOUNT) FROM ORDERLINE " +
0:                           "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?), " +
0:             "C_DELIVERY_CNT = C_DELIVERY_CNT + 1 " +
0:             "WHERE C_W_ID = ? AND C_D_ID = ? AND " +
0:             "C_ID = (SELECT O_C_ID FROM ORDERS " +
0:                     "WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?)");
1:         
0:         dlRecordDelivery = prepare(
0:             "INSERT INTO DELIVERY_ORDERS(DO_DR_ID, DO_D_ID, DO_O_ID) " +
0:             "VALUES (?, ?, ?)");
1:     public void delivery() throws Exception {
1:         
1:         // Find the most oldest queued order (FIFO)
1:         ResultSet rs = dlFindOldestRequest.executeQuery();
1:         rs.next();
1:         int request = rs.getInt("DR_ID");
1:         short w = rs.getShort("DR_W_ID");
1:         short carrier = rs.getShort("DR_CARRIER_ID");
1:         reset(dlFindOldestRequest);
1:         
1:         // Mark it as in progress
1:         dlSetRequestState.setString(1, "I");
1:         dlSetRequestState.setInt(2, request);
1:         dlSetRequestState.executeUpdate();
1:         reset(dlSetRequestState);
1:         
1:         conn.commit();
1:         
1:         // This parameter remains invariant over
1:         // the batch we will insert.
1:         dlRecordDelivery.setInt(1, request);
1:         
1:         // Process one row per-district for this warehouse
1:         for (short d = 1; d <= 10; d++)
1:         {
1:             dlRecordDelivery.setShort(2, d);
1: 
1:             // Get the oldest NEWORDERS for this district
1:             dlFindOrderToDeliver.setShort(1, w);
1:             dlFindOrderToDeliver.setShort(2, d);
1:             rs = dlFindOrderToDeliver.executeQuery();
1:             rs.next();
1:             int order = rs.getInt("ORDER_TO_DELIVER");
1:             if (rs.wasNull()) {
1:                 // No orders to deliver
1:                 dlRecordDelivery.setNull(3, Types.INTEGER);
1:                 dlRecordDelivery.addBatch();
1:             }
1:             reset(dlFindOrderToDeliver);
1:             
1:             // Delete the NEWORDERS row
1:             dlDeleteNewOrder.setShort(1, w);
1:             dlDeleteNewOrder.setShort(2, d);
1:             dlDeleteNewOrder.setInt(3, order);
1:             dlDeleteNewOrder.executeUpdate();
1:             reset(dlDeleteNewOrder);
1:             
1:             // Set the carrier in ORDERS
1:             dlSetOrderCarrier.setShort(1, carrier);
1:             dlSetOrderCarrier.setShort(2, w);
1:             dlSetOrderCarrier.setShort(3, d);
1:             dlSetOrderCarrier.setInt(4, order);
1:             dlSetOrderCarrier.executeUpdate();
1:             reset(dlSetOrderCarrier);
1:             
1:             // Update ORDERLINE with the delivery date
1:             dlSetOrderlineDate.setShort(1, w);
1:             dlSetOrderlineDate.setShort(2, d);
1:             dlSetOrderlineDate.setInt(3, order);
1:             dlSetOrderlineDate.executeUpdate();
1:             reset(dlSetOrderlineDate);
1:             
1:             dlUpdateCustomer.setShort(1, w);
1:             dlUpdateCustomer.setShort(2, d);
1:             dlUpdateCustomer.setInt(3, order);
1:             dlUpdateCustomer.setShort(4, w);
1:             dlUpdateCustomer.setShort(5, d);
1:             dlUpdateCustomer.setShort(6, w);
1:             dlUpdateCustomer.setShort(7, d);
1:             dlUpdateCustomer.setInt(8, order);
1:             dlUpdateCustomer.executeUpdate();
1:             reset(dlUpdateCustomer);
1:                       
1:             conn.commit();
1:             
1:             dlRecordDelivery.setInt(3, order);
1:             dlRecordDelivery.addBatch();
1:         }
1:         
1:         // Record the delivery including the timestamp
1:         // 90% are meant to complete within 80 seconds
1:         // of them being queued.
1:         dlRecordDelivery.executeBatch();
1:         reset(dlRecordDelivery);
1:         dlCompleteDelivery.setInt(1, request);
1:         dlCompleteDelivery.executeUpdate();
1:         reset(dlCompleteDelivery);
1:         conn.commit();
1:         
0:     public void close() throws Exception {
0:         // Close any instance field that is a PreparedStatement
0:         Field[] fields = getClass().getDeclaredFields();
0:         for (int i = 0; i < fields.length; i++) {
0:             Field f = fields[i];
1:                        
0:             if (PreparedStatement.class.isAssignableFrom(f.getType()))
1:             {
0:                 close((PreparedStatement) f.get(this));
1:             }
1:         }
commit:8404f5d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.system.oe.model.Address;
1: import org.apache.derbyTesting.system.oe.model.District;
1: import org.apache.derbyTesting.system.oe.model.Warehouse;
/////////////////////////////////////////////////////////////////////////
1:                 reset(sl1);
/////////////////////////////////////////////////////////////////////////
1:                 reset(sl2);
/////////////////////////////////////////////////////////////////////////
1:             reset(osCustomerByName);
/////////////////////////////////////////////////////////////////////////
1:             reset(osCustomerById);
/////////////////////////////////////////////////////////////////////////
1:         reset(osLastOrderNumber);
/////////////////////////////////////////////////////////////////////////
1:     
0:     private PreparedStatement pyCustomerPayment;
0:     private PreparedStatement pyCustomerInfoId;
0:     private PreparedStatement pyCustomerByName;
0:     private PreparedStatement pyCustomerUpdateBadCredit;
0:     private PreparedStatement pyCustomerGetData;
0:     private PreparedStatement pyDistrictUpdate;
0:     private PreparedStatement pyDistrictInfo;
0:     private PreparedStatement pyWarehouseUpdate;
0:     private PreparedStatement pyWarehouseInfo;
0:     private PreparedStatement pyHistory;
0:         pyCustomerPayment = prepare(
0:             "UPDATE CUSTOMER SET C_BALANCE = C_BALANCE - ?, " +
0:             "C_YTD_PAYMENT = C_YTD_PAYMENT + ?, " +
0:             "C_PAYMENT_CNT = C_PAYMENT_CNT + 1 " +
0:             "WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:         
0:         pyCustomerInfoId = prepare(
0:             "SELECT C_FIRST, C_MIDDLE, C_LAST, C_BALANCE, " +
0:             "C_STREET_1, C_STREET_2, C_CITY, C_STATE, C_ZIP, " +
0:             "C_PHONE, C_SINCE, C_CREDIT, C_CREDIT_LIM, C_DISCOUNT " +
0:             "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:         
0:         pyCustomerByName = prepare(
0:                 "SELECT C_ID " +
0:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_LAST = ? " +
0:                 "ORDER BY C_FIRST");
1:         
0:         pyCustomerUpdateBadCredit = prepare(
0:             "UPDATE CUSTOMER SET C_DATA = " +
0:             " BAD_CREDIT_DATA(C_DATA, ?, ?, C_W_ID, C_W_ID, C_ID, ?) " +
0:             "WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
0:         pyCustomerGetData = prepare(
0:             "SELECT SUBSTR(C_DATA, 1, 200) AS C_DATA_200 " +
0:             "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
1:         
0:         pyDistrictUpdate = prepare(
0:             "UPDATE DISTRICT SET D_YTD = D_YTD + ? WHERE D_W_ID = ? AND D_ID = ?");
0:         pyDistrictInfo = prepare(
0:             "SELECT D_NAME, D_STREET_1, D_STREET_2, D_CITY, D_STATE, D_ZIP FROM DISTRICT WHERE D_W_ID = ? AND D_ID = ? ");
0:         pyWarehouseUpdate = prepare(
0:             "UPDATE WAREHOUSE SET W_YTD = W_YTD + ? WHERE W_ID = ?");
0:         pyWarehouseInfo = prepare(
0:                 "SELECT W_NAME, W_STREET_1, W_STREET_2, W_CITY, W_STATE, W_ZIP " +
0:                 "FROM WAREHOUSE WHERE W_ID = ?");
1:         
0:         pyHistory = prepare(
0:             "INSERT INTO HISTORY(H_C_ID, H_C_D_ID, H_C_W_ID, H_D_ID, H_W_ID, " +
0:             "H_DATE, H_AMOUNT, H_DATA) " +
0:             "VALUES (?, ?, ?, ?, ?, CURRENT TIMESTAMP, ?, ?)");
1:      }
1:     /**
1:      * Payment by customer last name.
1:      * Section 2.5.2
1:      * The CUSTOMER row will be fetched and then updated.
1:      * This is due to the need to select the specific customer
1:      * first based upon last name (which will actually fetch and
1:      * hence lock a number of customers).
1:      */
1:         
1:         // Since so much data is needed for the payment transaction
1:         // from the customer we don't fill it in as we select the
1:         // correct customer. Instead we just fetch the identifier
1:         // and then execute a payment by identifier.
1:         try {
1:             pyCustomerByName.setShort(1, cw);
1:             pyCustomerByName.setShort(2, cd);
1:             pyCustomerByName.setString(3, customerLast);
1:             ResultSet rs = pyCustomerByName.executeQuery();
0:             int n = 0;
0:             List list = new ArrayList();
1:             while (rs.next())
1:             {           
0:                 list.add(rs.getObject("C_ID"));            
1:             }
1:             reset(pyCustomerByName);
0:             if (list.isEmpty())
1:                 throw new SQLException("Payment by name - no matching customer "
1:                         + customerLast);
1:             
1:             // Customer to use is midpoint (with round up) (see 2.5.2.2)
0:             int mid = n/2;
0:             if (n%2 == 1)
0:                 mid++;
1:             
0:             int c = ((Integer) list.get(mid)).intValue();
1:             paymentById(display, displayData, w, d, cw, cd, c, amount);
1:         } catch (SQLException e) {
1:             conn.rollback();
1:             throw e;
1:         }
1:         
1:         if (display != null)
1:             ;
1:     /**
1:      * Payment by customer identifier.
1:      * Section 2.5.2.
1:      * The CUSTOMER row is update and then fetched.
1:      * 
1:      */
1:             short cw, short cd, int c, final String amount) throws Exception {
1:         
1:         try {
1:             paymentById(display, displayData, w, d, cw, cd, c, amount);
1:         } catch (SQLException e) {
1:             conn.rollback();
1:             throw e;
1:         }
1:         
1:         if (display != null)
1:             ;
1:     }
1:     
1:     private void paymentById(Display display, Object displayData, short w, short d,
1:             short cw, short cd, int c, final String amount) throws Exception {
1:   
1:         
1:         Customer customer = new Customer();
1:         customer.setWarehouse(cw);
1:         customer.setDistrict(cd);
1:         customer.setId(c);
1:         
1:         // Update the customer assuming that they have good credit
1:         pyCustomerPayment.setString(1, amount);
1:         pyCustomerPayment.setString(2, amount);
1:         pyCustomerPayment.setShort(3, cw);
1:         pyCustomerPayment.setShort(4, cd);
1:         pyCustomerPayment.setInt(5, c);
1:         pyCustomerPayment.executeUpdate();
1:         
1:         // Get the customer information
1:         pyCustomerInfoId.setShort(1, cw);
1:         pyCustomerInfoId.setShort(2, cd);
1:         pyCustomerInfoId.setInt(3, c);
1:         ResultSet rs = pyCustomerInfoId.executeQuery();
1:         rs.next();
1:         
1:         customer.setFirst(rs.getString("C_FIRST"));
1:         customer.setMiddle(rs.getString("C_MIDDLE"));
1:         customer.setLast(rs.getString("C_LAST"));
1:         customer.setBalance(rs.getString("C_BALANCE"));
1:         
1:         customer.setAddress(getAddress(rs, "C_STREET_1"));
1:         customer.setPhone(rs.getString("C_PHONE"));
1:         customer.setSince(rs.getTimestamp("C_SINCE"));
1:         customer.setCredit(rs.getString("C_CREDIT"));
1:         customer.setCredit_lim(rs.getString("C_CREDIT_LIM"));
1:         customer.setDiscount(rs.getString("C_DISCOUNT"));
1:         reset(pyCustomerInfoId);
1:         
1:         // additional work for bad credit customers.
1:         if ("BC".equals(customer.getCredit()))
1:         {
1:             pyCustomerUpdateBadCredit.setShort(1, w);
1:             pyCustomerUpdateBadCredit.setShort(2, d);
1:             pyCustomerUpdateBadCredit.setString(3, amount);
1:             pyCustomerUpdateBadCredit.setShort(4, cw);
1:             pyCustomerUpdateBadCredit.setShort(5, cd);
1:             pyCustomerUpdateBadCredit.setInt(6, c);         
1:             pyCustomerUpdateBadCredit.executeUpdate();
1:             reset(pyCustomerUpdateBadCredit);
1:             
1:             // Need to display the first 200 characters
1:             // of C_DATA information if the customer has
1:             // bad credit.
1:             pyCustomerGetData.setShort(1, cw);
1:             pyCustomerGetData.setShort(2, cd);
1:             pyCustomerGetData.setInt(3, c);                     
1:             rs = pyCustomerGetData.executeQuery();
1:             rs.next();
1:             customer.setData(rs.getString("C_DATA_200"));
1:             reset(pyCustomerGetData);
1:         }
1: 
0:         District district = new District();
1:         district.setWarehouse(w);
1:         district.setId(d);
1: 
1:         // Update DISTRICT
1:         pyDistrictUpdate.setString(1, amount);
1:         pyDistrictUpdate.setShort(2, w);
1:         pyDistrictUpdate.setShort(3, d);
1:         pyDistrictUpdate.executeUpdate();
1:         reset(pyDistrictUpdate);
1: 
1:         // Get the required information from DISTRICT
1:         pyDistrictInfo.setShort(1, w);
1:         pyDistrictInfo.setShort(2, d);
1:         rs = pyDistrictInfo.executeQuery();
1:         rs.next();
1:         district.setName(rs.getString("D_NAME"));
1:         district.setAddress(getAddress(rs, "D_STREET_1"));
1:         reset(pyDistrictInfo);        
1:         
0:         Warehouse warehouse = new Warehouse();
1:         warehouse.setId(w);
1:         
1:         // Update WAREHOUSE
1:         pyWarehouseUpdate.setString(1, amount);
1:         pyWarehouseUpdate.setShort(2, w);
1:         pyWarehouseUpdate.executeUpdate();
1:         reset(pyWarehouseUpdate);
1:         
1:         // Get the required information from WAREHOUSE
1:         pyWarehouseInfo.setShort(1, w);
1:         rs = pyWarehouseInfo.executeQuery();
1:         rs.next();
1:         warehouse.setName(rs.getString("W_NAME"));
1:         warehouse.setAddress(getAddress(rs, "W_STREET_1"));
1:         reset(pyWarehouseInfo);
1:          
1:         // Insert HISTORY row
1:         pyHistory.setInt(1, c);
1:         pyHistory.setShort(2, cd);
1:         pyHistory.setShort(3, cw);
1:         pyHistory.setShort(4, d);
1:         pyHistory.setShort(5, w);
1:         pyHistory.setString(6, amount);
1:         StringBuffer hData = new StringBuffer(24);
1:         hData.append(warehouse.getName());
1:         hData.append("    ");
1:         hData.append(district.getName());
1:         pyHistory.setString(7, hData.toString());
1:         pyHistory.executeUpdate();
1:         reset(pyHistory);
1:         
1:         conn.commit();
1:   
/////////////////////////////////////////////////////////////////////////
0:         close(pyCustomerPayment);
0:         close(pyCustomerInfoId);
0:         close(pyCustomerUpdateBadCredit);
0:         close(pyDistrictUpdate);
0:         close(pyDistrictInfo);
0:         close(pyWarehouseUpdate);
0:         close(pyWarehouseInfo);
0:         close(pyHistory);
1:         
1:     
1:     /**
0:      * Reset a PreparedStatement. Closes its open ResultSet
0:      * and clears the parameters. While clearing the parameters
0:      * is not required since any future execution will override
0:      * them, it is done here to reduce the chance of errors.
0:      * E.g. using the wrong prepared statement for a operation
0:      * or not setting all the parameters.
0:      * It is assumed the prepared statement was just executed.
0:      * @throws SQLException 
1:      */
0:     private static void reset(PreparedStatement ps) throws SQLException
1:     {
0:         ResultSet rs = ps.getResultSet();
0:         if (rs != null)
1:             rs.close();
0:         ps.clearParameters();
1:     }
1:     
1:     /**
0:      * Close a PreparedStatement if it was opened.
1:      */
1:     
0:     private Address getAddress(ResultSet rs, String firstColumnName) throws SQLException
1:     {
0:         Address address = new Address();
1:         
0:         int col = rs.findColumn(firstColumnName);
0:         address.setStreet1(rs.getString(col++));
0:         address.setStreet2(rs.getString(col++));
0:         address.setCity(rs.getString(col++));
0:         address.setState(rs.getString(col++));
0:         address.setZip(rs.getString(col));
1:         
0:         return address;
1:     }
commit:9f7e882
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
1: import org.apache.derbyTesting.system.oe.model.Customer;
1: import org.apache.derbyTesting.system.oe.model.Order;
1: import org.apache.derbyTesting.system.oe.model.OrderLine;
/////////////////////////////////////////////////////////////////////////
0:             "SELECT COUNT(DISTINCT(S_I_ID)) AS LOW_STOCK FROM ORDERLINE, STOCK " +
/////////////////////////////////////////////////////////////////////////
1:                 int nextOrder = rs.getInt("D_NEXT_O_ID");
/////////////////////////////////////////////////////////////////////////
0:                 level = rs.getInt("LOW_STOCK");
/////////////////////////////////////////////////////////////////////////
1:     
0:     private PreparedStatement osCustomerById;
0:     private PreparedStatement osLastOrderNumber;
0:     private PreparedStatement osOrderDetails;
0:     private PreparedStatement osOrderLineItems;
1:     
0:     private PreparedStatement osCustomerByName;
0:         osCustomerById = prepare(
0:                 "SELECT C_BALANCE, C_FIRST, C_MIDDLE, C_LAST " +
0:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_ID = ?");
0:         osLastOrderNumber = prepare(
0:                 "SELECT MAX(O_ID) AS LAST_ORDER FROM ORDERS " +
0:                 "WHERE O_W_ID = ? AND O_D_ID = ? AND O_C_ID = ?");
0:         osOrderDetails = prepare(
0:                 "SELECT O_ENTRY_D, O_CARRIER_ID, O_OL_CNT " +
0:                 "FROM ORDERS WHERE O_W_ID = ? AND O_D_ID = ? AND O_ID = ?");
0:         osOrderLineItems = prepare(
0:                 "SELECT OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, " +
0:                 "OL_DELIVERY_D FROM ORDERLINE " +
0:                 "WHERE OL_W_ID = ? AND OL_D_ID = ? AND OL_O_ID = ?");
1: 
0:         osCustomerByName = prepare(
0:                 "SELECT C_ID, C_BALANCE, C_FIRST, C_MIDDLE " +
0:                 "FROM CUSTOMER WHERE C_W_ID = ? AND C_D_ID = ? AND C_LAST = ? " +
0:                 "ORDER BY C_FIRST");
1:     
1:     /**
1:      * Order status by customer last name.
1:      * Based up the example SQL queries in appendix A.3
1:      */
1:         
1:        
1:         try {
1:             osCustomerByName.setShort(1, w);
1:             osCustomerByName.setShort(2, d);
1:             osCustomerByName.setString(3, customerLast);
1:             ResultSet rs = osCustomerByName.executeQuery();
0:             int n = 0;
0:             List list = new ArrayList();
1:             while (rs.next())
0:             {
1:                 Customer customer = new Customer();
1:                 customer.setWarehouse(w);
1:                 customer.setDistrict(d);
1:                 customer.setLast(customerLast);
1:                 
1:                 customer.setId(rs.getInt("C_ID"));
1:                 customer.setBalance(rs.getString("C_BALANCE"));
1:                 customer.setFirst(rs.getString("C_FIRST"));
1:                 customer.setMiddle(rs.getString("C_MIDDLE"));
1:                 
0:                 list.add(customer);
1:             }
1:             rs.close();
0:             if (list.isEmpty())
1:                 throw new SQLException("Order Status by name - no matching customer "
1:                         + customerLast);
1:             
1:             // Customer to use is midpoint (with round up) (see 2.6.2.2)
0:             int mid = n/2;
0:             if (n%2 == 1)
0:                 mid++;
1: 
0:             Customer customer = (Customer) list.get(mid);
0:             list = null;
1:             
1:             getOrderStatusForCustomer(display, displayData, true, customer);
1:         } catch (SQLException e) {
1:             conn.rollback();
1:             throw e;
1:         }
1:     /**
1:      * Order status by customer identifier.
1:      * Based up the example SQL queries in appendix A.3
1:      */
1:         
1:         Customer customer = new Customer();
1:         customer.setWarehouse(w);
1:         customer.setDistrict(d);
1:         customer.setId(c);
1:         
1:         try {
1:             // Get the customer information
1:             osCustomerById.setShort(1, w);
1:             osCustomerById.setShort(2, d);
1:             osCustomerById.setInt(3, c);
1:             ResultSet rs = osCustomerById.executeQuery();
1:             rs.next();
1:             customer.setBalance(rs.getString("C_BALANCE"));
1:             customer.setFirst(rs.getString("C_FIRST"));
1:             customer.setMiddle(rs.getString("C_MIDDLE"));
1:             customer.setLast(rs.getString("C_LAST"));    
1:             rs.close();
1:             getOrderStatusForCustomer(display, displayData, false, customer);
1:         } catch (SQLException e) {
1:             conn.rollback();
1:             throw e;
1:         }
1:     }
1:     
1:     /**
1:      * Fetch the order details having obtained the customer information
1:      * and display it.
1:      */
1:     private void getOrderStatusForCustomer(Display display, Object displayData,
1:             boolean byName, Customer customer) throws Exception
0:     {
0:         Order order = new Order();
1:         order.setWarehouse(customer.getWarehouse());
1:         order.setDistrict(customer.getDistrict());
1:         
1:         // Find the most recent order number for this customer
1:         osLastOrderNumber.setShort(1, customer.getWarehouse());
1:         osLastOrderNumber.setShort(2, customer.getDistrict());
1:         osLastOrderNumber.setInt(3, customer.getId());
1:         ResultSet rs = osLastOrderNumber.executeQuery();
1:         rs.next();
1:         order.setId(rs.getInt("LAST_ORDER"));
1:         rs.close();
1:         
1:         // Details for the order.
1:         osOrderDetails.setShort(1, customer.getWarehouse());
1:         osOrderDetails.setShort(2, customer.getDistrict());
1:         osOrderDetails.setInt(3, order.getId());
1:         rs = osOrderDetails.executeQuery();
1:         rs.next();
1:         order.setEntry_d(rs.getTimestamp("O_ENTRY_D"));
1:         order.setCarrier_id((Integer) rs.getObject("O_CARRIER_ID"));
1:         order.setOl_cnt(rs.getInt("O_OL_CNT"));
1:         rs.close();
1: 
1:         OrderLine[] lineItems = new OrderLine[order.getOl_cnt()];
1:         
1:         osOrderLineItems.setShort(1, order.getWarehouse());
1:         osOrderLineItems.setShort(2, order.getDistrict());
1:         osOrderLineItems.setInt(3, order.getId());
1:         rs = osOrderLineItems.executeQuery();
1:         int oli = 0;
1:         while (rs.next())
0:         {
1:             OrderLine ol = new OrderLine();
1:             ol.setI_id(rs.getInt("OL_I_ID"));
1:             ol.setSupply_w_id(rs.getShort("OL_SUPPLY_W_ID"));
1:             ol.setQuantity(rs.getShort("OL_QUANTITY"));
1:             ol.setAmount(rs.getString("OL_AMOUNT"));
1:             ol.setDelivery_d( rs.getTimestamp("OL_DELIVERY_D"));
1:             
1:             lineItems[oli++] = ol;
1:         }
1:         rs.close();
1:         conn.commit();
1:         
1:         if (display != null)
1:             display.displayOrderStatus(displayData,
1:                     byName, customer, order, lineItems);
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void close() throws SQLException {
0:         
0:         close(sl1);
0:         close(sl2);
0:         
0:         close(osCustomerById);
0:         close(osCustomerByName);
0:         close(osLastOrderNumber);
0:         close(osOrderDetails);
0:         close(osOrderLineItems);
0:         
1:     }
0:     private static void close(PreparedStatement ps)
0:        throws SQLException
0:     {
0:         if (ps != null)
0:             ps.close();
1:     }
commit:38b4bbb
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.system.oe.direct.Standard
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
0:  */
1: package org.apache.derbyTesting.system.oe.direct;
0: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
0: 
1: import org.apache.derbyTesting.system.oe.client.Display;
1: import org.apache.derbyTesting.system.oe.client.Operations;
0: 
0: /**
1:  * Implement the transactions following the TPC-C specification
1:  * using client side prepared statements. Thus all the logic
1:  * is contained within this class. The client, through this
1:  * object, holds onto PreparedStatements for all the SQL
1:  * for its lifetime.
1:  * <P>
1:  * This standard implementation is based upon the sample
1:  * programs in the appendix of the TPC-C specification.
1:  * <P>
1:  * More specific direct (client side) implementations
1:  * could extend this class overriding methods as needed.
0:  */
0: public class Standard implements Operations {
0:     
0:     private final Connection conn;
0: 
0:     /**
1:      * Create an instance of this implementation.
1:      * Connection will be set to non auto commit
1:      * mode and SERIZIALZABLE isolation.
0:      */
1:     public Standard(Connection conn) throws SQLException
0:     {
0:         this.conn = conn;
0:         conn.setAutoCommit(false);
0:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:     }
0:     
0:     /**
0:      * Prepare all statements as forward-only, read-only, close at commit.
0:      */
0:     PreparedStatement prepare(String sql) throws SQLException
0:     {
0:         return conn.prepareStatement(sql,
0:                 ResultSet.TYPE_FORWARD_ONLY,
0:                 ResultSet.CONCUR_READ_ONLY,
0:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:     }
0:     
1:     /*
1:      *  Stock Level transaction.
1:      *  Described in section 2.8.2.
1:      *  SQL based upon sample prgram in appendix A.5.
0:      */
0:     
0:     private PreparedStatement sl1;
0:     private PreparedStatement sl2;
0:     
0:     public void setupStockLevel() throws Exception {
0:         sl1 = prepare(
0:             "SELECT D_NEXT_O_ID FROM DISTRICT WHERE D_W_ID = ? AND D_ID = ?");
0:         
0:         sl2 = prepare(
0:             "SELECT COUNT(DISTINCT(S_I_ID)) FROM ORDERLINE, STOCK " +
0:             "WHERE OL_W_ID = ? AND OL_D_ID = ? " +
0:             "AND OL_O_ID < ? AND OL_O_ID >= ? " +
0:             "AND S_W_ID = ? AND S_I_ID = OL_I_ID AND S_QUANTITY < ?");
1:     }
0:     
1:     public void stockLevel(Display display, Object displayData, short w,
1:             short d, int threshold) throws Exception {
0:         
1:         int isolation = conn.getTransactionIsolation();
0: 
0:         int level;
1:         try {
0: 
1:             try {
0: 
1:                 conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
0:                          
1:                 sl1.setShort(1, w);
1:                 sl1.setShort(2, d);
0: 
1:                 sl2.setShort(1, w);
1:                 sl2.setShort(2, d);
0: 
1:                 sl2.setShort(5, w);
1:                 sl2.setInt(6, threshold);
0: 
1:                 ResultSet rs = sl1.executeQuery();
0: 
1:                 rs.next();
0:                 int nextOrder = rs.getInt(1);
0:                 rs.close();
0: 
1:                 sl2.setInt(3, nextOrder);
1:                 sl2.setInt(4, nextOrder - 20);
0: 
1:                 rs = sl2.executeQuery();
1:                 rs.next();
0:                 level = rs.getInt(1);
0:                 rs.close();
0: 
1:                 conn.commit();
1:             } finally {
1:                 conn.setTransactionIsolation(isolation);
1:             }
0: 
1:         } catch (SQLException sqle) {
0: 
1:             conn.rollback();
1:             throw sqle;
1:         }
0: 
1:         if (display != null)
0:             display.displayStockLevel(displayData, w, d, threshold, level);
1:     }
0:     
1:     /*
0:      * Order Status transaction.
0:      */
0: 
0:     public void setupOrderStatus() throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
1:     public void orderStatus(Display display, Object displayData, short w,
1:             short d, String customerLast) throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
0: 
1:     public void orderStatus(Display display, Object displayData, short w,
1:             short d, int c) throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
0: 
0:     public void setupPayment() throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
0: 
1:     public void payment(Display display, Object displayData, short w, short d,
1:             short cw, short cd, String customerLast, String amount)
1:             throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
0: 
1:     public void payment(Display display, Object displayData, short w, short d,
0:             short cw, short cd, int c, String amount) throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
0:     
0:     public void setupNewOrder() throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
1:     public void newOrder(Display display, Object displayData, short w, short d,
1:             int c, int[] items, short[] quantities, short[] supplyW)
1:             throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
0:     public void setupScheduleDelivery() throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
1:     public void scheduleDelivery(Display display, Object displayData, short w,
1:             short carrier) throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
0:     
0:     public void setupDelivery() throws Exception {
0:         // TODO Auto-generated method stub
0: 
1:     }
0:     public int delivery() throws Exception {
0:         // TODO Auto-generated method stub
0:         return 0;
1:     }
1: }
============================================================================