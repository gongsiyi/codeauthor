1:d847ced: /*
1:0b71ff5: 
1:d847ced:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest
6:d847ced: 
1:d847ced:    Licensed to the Apache Software Foundation (ASF) under one or more
1:d847ced:    contributor license agreements.  See the NOTICE file distributed with
1:d847ced:    this work for additional information regarding copyright ownership.
1:d847ced:    The ASF licenses this file to you under the Apache License, Version 2.0
1:d847ced:    (the "License"); you may not use this file except in compliance with
1:d847ced:    the License.  You may obtain a copy of the License at
1:d847ced: 
1:d847ced:      http://www.apache.org/licenses/LICENSE-2.0
1:d847ced: 
1:d847ced:    Unless required by applicable law or agreed to in writing, software
1:d847ced:    distributed under the License is distributed on an "AS IS" BASIS,
1:d847ced:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d847ced:    See the License for the specific language governing permissions and
1:d847ced:    limitations under the License.
1:d847ced: 
1:d847ced:  */
1:d847ced: 
1:d847ced: package org.apache.derbyTesting.functionTests.tests.lang;
1:d847ced: 
1:d847ced: import java.io.File;
1:d847ced: import java.io.IOException;
1:d847ced: import java.math.BigDecimal;
1:d847ced: import java.security.AccessController;
1:d847ced: import java.security.PrivilegedActionException;
1:d847ced: import java.security.PrivilegedExceptionAction;
1:d847ced: import java.sql.Connection;
1:d847ced: import java.sql.Date;
1:502ed2e: import java.sql.DriverManager;
1:d847ced: import java.sql.PreparedStatement;
1:d847ced: import java.sql.SQLException;
1:d847ced: import java.sql.Time;
1:d847ced: import java.sql.Timestamp;
1:d847ced: import java.sql.Types;
1:d847ced: import java.util.Arrays;
1:2277df2: import java.util.Locale;
1:d847ced: import junit.framework.Test;
1:2277df2: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1:a4e6298: import org.apache.derby.optional.api.LuceneIndexDescriptor;
1:a4e6298: import org.apache.derby.optional.api.LuceneUtils;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:d847ced: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:2277df2: import org.apache.derbyTesting.junit.LocaleTestSetup;
1:d847ced: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:d847ced: import org.apache.derbyTesting.junit.TestConfiguration;
1:0b71ff5: import org.apache.lucene.analysis.Analyzer;
1:a4e6298: import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;
1:0b71ff5: import org.apache.lucene.queryparser.classic.ParseException;
1:0b71ff5: import org.apache.lucene.queryparser.classic.QueryParser;
1:0b71ff5: import org.apache.lucene.search.Query;
1:0b71ff5: import org.apache.lucene.util.Version;
1:a4e6298: 
1:d847ced: /**
1:d847ced:  * <p>
1:d847ced:  * Test permissions on objects created by the optional Lucene support tool.
1:d847ced:  * </p>
1:d847ced:  */
1:d847ced: public class LuceneSupportPermsTest extends GeneratedColumnsHelper
2:d847ced: {
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     // CONSTANTS
1:d847ced:     //
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:0b71ff5: 
1:7d889ca:     private static  final   String      LUCENE_VERSION_PROPERTY = "derby.tests.lucene.version";
1:5658bae:     private static  String              LUCENE_VERSION = "LUCENE_47";
1:7d889ca: 
1:435459e:     private static  final   String      DB_NAME = "lucenesupportpermsdb";
1:435459e: 
1:d847ced:     private static  final   String      TEST_DBO = "TEST_DBO";
1:d847ced:     private static  final   String      RUTH = "RUTH";
1:d847ced:     private static  final   String      ALICE = "ALICE";
1:d847ced:     private static  final   String      FRANK = "FRANK";
1:d847ced:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, ALICE, RUTH, FRANK  };
1:0b71ff5: 
1:d847ced: 	private static  final   String      AUTH_NO_ACCESS_NOT_OWNER    = "42507";
1:d847ced: 	private static  final   String      DBO_ONLY                                = "4251D";
1:d847ced:     private static  final   String      FUNCTION_EXISTS                 = "X0Y68";
1:d847ced: 
1:d847ced:     private static  final   String      NOT_INDEXABLE                   = "42XBA";
1:d847ced:     private static  final   String      NO_PRIMARY_KEY              = "42XBB";
1:d847ced:     // LUCENE_UNSUPPORTED_TYPE = "42XBC": only raised if key type is unsupported. but all indexable types are supported.
1:d847ced:     // LUCENE_INVALID_CHARACTER = "42XBD" is tested by LuceneSupportTest.
1:d847ced:     private static  final   String      NONEXISTENT_INDEX           = "42XBE";
1:d847ced: 	private static  final   String      NO_DDL_PRIV                    = "42XBF";
1:d847ced: 	private static  final   String      DOUBLE_LOAD_ILLEGAL         = "42XBG";
1:d847ced: 	private static  final   String      DOUBLE_UNLOAD_ILLEGAL       = "42XBH";
1:d847ced: 	private static  final   String      BAD_DIRECTORY                      = "42XBI";
1:cbdf827: 	private static  final   String      BAD_COLUMN_NAME                 = "42XBJ";
1:5cf7a46:     private static  final   String      NONEXISTENT_TABLE_FUNCTION  ="42ZB4";
1:502ed2e:     private static  final   String      INCOMPATIBLE_ENCRYPTION = "42XBL";
1:4f7c143:     private static  final   String      ILLEGAL_NULL_ARG = "42XBM";
1:7e538ec:     private static  final   String      BAD_FIELD_NAME = "42XBN";
1:7e538ec:     private static  final   String      DUPLICATE_FIELD_NAME = "42XBO";
1:4f7c143:     private static  final   String      NULL_PRIMITIVE_ARG = "39004";
1:d847ced: 
1:d847ced:     private static  final   String      POLICY_FILE = "org/apache/derbyTesting/functionTests/tests/lang/luceneSupport.policy";
1:d847ced: 
1:d847ced:     private static  final   String      LOAD_TOOL = "call syscs_util.syscs_register_tool( 'luceneSupport', true )";
1:d847ced:     private static  final   String      UNLOAD_TOOL = "call syscs_util.syscs_register_tool( 'luceneSupport', false )";
1:2277df2:     private static  final   String      INDEX_POEMS = "call LuceneSupport.createIndex( 'ruth', 'poems', 'poemText', null )";
1:2277df2:     private static  final   String      UPDATE_POEMS_INDEX = "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText', null )";
1:d847ced:     private static  final   String      DROP_POEMS_INDEX = "call LuceneSupport.dropIndex( 'ruth', 'poems', 'poemText' )";
1:fcf3e6d:     private static  final   String      DROP_PRIMARY_KEY = "alter table poems drop constraint poemsKey";
1:d847ced: 
1:d847ced:     private static  final   long        MILLIS_IN_HOUR = 1000L * 60L * 60L;
1:d847ced:     private static  final   long        MILLIS_IN_DAY = MILLIS_IN_HOUR * 24L;
1:d847ced: 
1:2277df2:     private static  final   String      LANGUAGE = "en";
1:2277df2:     private static  final   String      COUNTRY = "US";
1:2277df2: 
1:a4e6298:     private static  final   String      DEFAULT_INDEX_DESCRIPTOR = "org.apache.derby.optional.api.LuceneUtils.defaultIndexDescriptor";
1:a4e6298:     private static  final   String      CONSTANT_QUERY_PARSER = "org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.constantStringIndexDescriptor";
1:a4e6298:     
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     // STATE
1:d847ced:     //
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced: 
1:7e538ec:     static  String[]    _fieldNames;
1:7e538ec: 
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     // CONSTRUCTOR
1:d847ced:     //
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced: 
1:d847ced:     /**
1:d847ced:      * Create a new instance.
1:d847ced:      */
1:d847ced: 
1:d847ced:     public LuceneSupportPermsTest(String name)
1:d847ced:     {
1:d847ced:         super(name);
2:d847ced:     }
1:d847ced: 
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     // JUnit BEHAVIOR
1:d847ced:     //
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced: 
1:d847ced: 
1:d847ced:     /**
1:d847ced:      * Construct top level suite in this JUnit test
1:d847ced:      */
1:d847ced:     public static Test suite()
1:d847ced:     {
1:7d889ca:         String      luceneVersion = getSystemProperty( LUCENE_VERSION_PROPERTY );
1:7d889ca:         if ( luceneVersion != null ) { LUCENE_VERSION = luceneVersion; }
1:7d889ca:         
1:1ae02c9:         BaseTestSuite suite = (BaseTestSuite)TestConfiguration.embeddedSuite(
1:1ae02c9:             LuceneSupportPermsTest.class);
1:d847ced: 
1:561e69f:         Test        secureTest = new SecurityManagerSetup( suite, POLICY_FILE );
1:d847ced:         Test        authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:d847ced:             ( secureTest, LEGAL_USERS, "LuceneSupportPermissions" );
1:689206c:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecoratorSingleUse( authenticatedTest, DB_NAME, true );
1:561e69f:         Test        localizedTest = new LocaleTestSetup( authorizedTest, new Locale( LANGUAGE, COUNTRY ) );
1:d847ced: 
1:561e69f:         return localizedTest;
1:435459e:     }
1:435459e: 
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     // TESTS
1:d847ced:     //
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced: 
1:d847ced:     /**
1:d847ced:      * <p>
1:d847ced:      * Test baseline permissions where no grants are made.
1:d847ced:      * </p>
1:d847ced:      */
1:d847ced:     public  void    test_001_basicNoGrant()
1:435459e:         throws Exception
1:435459e:     {
1:d847ced:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:d847ced:         Connection  ruthConnection = openUserConnection( RUTH );
1:d847ced:         Connection  aliceConnection = openUserConnection( ALICE );
1:d847ced: 
1:6aeea9c:         createSchema( ruthConnection, Types.INTEGER );
1:6aeea9c: 
1:d847ced:         // ruth does not have permission to load the tool
1:d847ced:         expectExecutionError( ruthConnection, LACK_EXECUTE_PRIV, LOAD_TOOL );
1:d847ced: 
1:d847ced:         // but the dbo has permission
1:d847ced:         goodStatement( dboConnection, LOAD_TOOL );
1:d847ced: 
1:d847ced:         // can't update a non-existent index
1:2277df2:         expectExecutionError
1:2277df2:             ( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText', null )" );
1:d847ced: 
1:d847ced:         // alice does not have permission to index a table owned by ruth
1:d847ced:         expectExecutionError( aliceConnection, LACK_COLUMN_PRIV, INDEX_POEMS );
1:d847ced: 
1:d847ced:         // but ruth can
1:d847ced:         goodStatement( ruthConnection, INDEX_POEMS );
1:d847ced: 
1:d847ced:         // redundant index creation fails
1:d847ced:         expectExecutionError( ruthConnection, FUNCTION_EXISTS, INDEX_POEMS );
1:d847ced: 
1:d847ced:         // can't update a non-existent index
1:2277df2:         expectExecutionError( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'foo', null )" );
1:2277df2:         expectExecutionError
1:2277df2:             ( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'originalAuthor', null )" );
1:d847ced: 
1:d847ced:         // alice can't view an index created by ruth
1:a4e6298:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 1000, null ) ) luceneResults order by poemID";
1:d847ced:         expectExecutionError( aliceConnection, LACK_EXECUTE_PRIV, viewPoemsIndex );
1:d847ced: 
1:d847ced:         // but ruth can
1:d847ced:         assertResults
1:0b71ff5:             (
1:d847ced:              ruthConnection,
1:d847ced:              viewPoemsIndex,
1:d847ced:              new String[][]
1:d847ced:              {
1:2277df2:                  { "3", "3", "2", "0.22933942" },
1:2277df2:                  { "4", "4", "3", "0.22933942" },
1:2277df2:                  { "5", "5", "4", "0.26756266" },
1:d847ced:              },
1:d847ced:              false
1:2277df2:              );
1:d847ced: 
1:d847ced:         // alice can list indexes even on tables owned by ruth
1:cb62199:         String  listIndexes = "select schemaName, tableName, columnName from table ( LuceneSupport.listIndexes() ) listindexes";
1:d847ced:         assertResults
2:d847ced:             (
1:d847ced:              aliceConnection,
1:d847ced:              listIndexes,
1:d847ced:              new String[][]
1:d847ced:              {
1:cb62199:                  { "RUTH", "POEMS", "POEMTEXT" },
1:d847ced:              },
1:d847ced:              false
4:d847ced:              );
1:d847ced: 
1:d847ced:         // alice cannot update an index owned by ruth
1:d847ced:         expectExecutionError( aliceConnection, NO_DDL_PRIV, UPDATE_POEMS_INDEX );
1:d847ced:         
1:d847ced:         // alice cannot drop an index owned by ruth
1:d847ced:         expectExecutionError( aliceConnection, AUTH_NO_ACCESS_NOT_OWNER, DROP_POEMS_INDEX );
1:d847ced: 
1:d847ced:         // ruth can update the index
1:d847ced:         goodStatement( ruthConnection, UPDATE_POEMS_INDEX );
1:d847ced: 
1:fcf3e6d:         // dropping the key does NOT prevent you from re-indexing
1:fcf3e6d:         goodStatement( ruthConnection, DROP_PRIMARY_KEY );
1:fcf3e6d:         goodStatement( ruthConnection, UPDATE_POEMS_INDEX );
1:fcf3e6d: 
1:fcf3e6d:         // but dropping a key column DOES prevent you from re-indexing and from selecting
1:fcf3e6d:         goodStatement( ruthConnection, "alter table poems drop column versionStamp" );
1:fcf3e6d:         expectExecutionError( ruthConnection, COLUMN_OUT_OF_SCOPE, UPDATE_POEMS_INDEX );
1:fcf3e6d:         expectExecutionError( ruthConnection, COLUMN_OUT_OF_SCOPE, viewPoemsIndex );
1:d847ced:         
1:d847ced:         // ruth can drop the index
1:d847ced:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:d847ced:         assertResults
1:d847ced:             (
1:d847ced:              ruthConnection,
1:d847ced:              listIndexes,
1:d847ced:              new String[][] {},
1:d847ced:              false
1:d847ced:              );
1:d847ced: 
1:d847ced:         // redundant drop fails, however
1:d847ced:         expectExecutionError( ruthConnection, NONEXISTENT_OBJECT, DROP_POEMS_INDEX );
1:d847ced: 
1:fcf3e6d:         // verify that a primary key is necessary in order to index a table
1:fcf3e6d:         dropSchema( ruthConnection );
1:fcf3e6d:         createSchema( ruthConnection, Types.INTEGER );
1:fcf3e6d:         goodStatement( ruthConnection, DROP_PRIMARY_KEY );
1:fcf3e6d:         expectExecutionError( ruthConnection, NO_PRIMARY_KEY, INDEX_POEMS );
1:fcf3e6d: 
1:d847ced:         // ruth cannot unload the tool
1:d847ced:         expectExecutionError( ruthConnection, LACK_EXECUTE_PRIV, UNLOAD_TOOL );
1:d847ced: 
1:d847ced:         // but the dbo can
1:d847ced:         goodStatement( dboConnection, UNLOAD_TOOL );
1:d847ced: 
1:d847ced:         dropSchema( ruthConnection );
1:d847ced:     }
1:d847ced: 
1:3240e21:     /**
1:3240e21:      * <p>
1:d847ced:      * Test that a user can grant access to her indexes.
1:d847ced:      * </p>
1:d847ced:      */
1:d847ced:     public  void    test_002_userGrant()
2:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:d847ced:         Connection  ruthConnection = openUserConnection( RUTH );
1:d847ced:         Connection  aliceConnection = openUserConnection( ALICE );
1:d847ced: 
1:d847ced:         createSchema( ruthConnection, Types.INTEGER );
1:d847ced: 
1:d847ced:         // load the Lucene plugin
1:d847ced:         goodStatement( dboConnection, LOAD_TOOL );
1:d847ced: 
1:d847ced:         // ruth indexes her table and grants alice privilege to run the index reading function
1:d847ced:         goodStatement( ruthConnection, INDEX_POEMS );
1:d847ced: 
1:d847ced:         Permission[]    permissions = new Permission[]
1:d847ced:         {
1:d847ced:             new Permission( "execute on function poems__poemText", NO_GENERIC_PERMISSION ),
1:d847ced:             new Permission( "select ( poemID ) on poems", NO_SELECT_OR_UPDATE_PERMISSION ),
1:d847ced:             new Permission( "select ( versionStamp ) on poems", NO_SELECT_OR_UPDATE_PERMISSION ),
1:d847ced:             new Permission( "select ( poemText ) on poems", NO_SELECT_OR_UPDATE_PERMISSION ),
1:d847ced:         };
1:d847ced:         for ( Permission permission : permissions )
1:d847ced:         {
1:d847ced:             grantPermission( ruthConnection, permission.text, ALICE );
1:d847ced:         }
1:d847ced: 
1:d847ced:         // but alice still needs select privilege on the base table columns
1:a4e6298:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 1000, null ) ) luceneResults order by poemid";
1:d847ced:         String[][]  viewPoemsIndexResults = new String[][]
1:d847ced:             {
1:2277df2:                 { "3", "3", "2", "0.22933942" },
1:2277df2:                 { "4", "4", "3", "0.22933942" },
1:2277df2:                 { "5", "5", "4", "0.26756266" },
1:d847ced:             };
1:d847ced: 
1:d847ced:         // now alice can view the index
1:d847ced:         assertResults( aliceConnection, viewPoemsIndex, viewPoemsIndexResults, false );
1:d847ced: 
1:d847ced:         // now revoke each permission and verify that it is needed
1:d847ced:         for ( Permission permission : permissions )
1:d847ced:         {
1:d847ced:             vetPermission_002( permission, ruthConnection, aliceConnection, viewPoemsIndex, viewPoemsIndexResults );
1:d847ced:         }
1:d847ced: 
1:d847ced:         // but alice still can't drop an index owned by ruth
1:d847ced:         expectExecutionError( aliceConnection, AUTH_NO_ACCESS_NOT_OWNER, DROP_POEMS_INDEX );
1:d847ced: 
1:d847ced:         // unload the plugin
1:d847ced:         goodStatement( dboConnection, UNLOAD_TOOL );
1:d847ced: 
1:d847ced:         dropSchema( ruthConnection );
1:d847ced:     }
1:d847ced:     private void    vetPermission_002
1:d847ced:         (
1:d847ced:          Permission permission,
1:d847ced:          Connection ruthConnection,
1:d847ced:          Connection aliceConnection,
1:d847ced:          String statement,
1:d847ced:          String[][] expectedResults
1:0b71ff5:          )
1:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         revokePermission( ruthConnection, permission.text, ALICE );
1:d847ced:         expectExecutionError( aliceConnection, permission.sqlStateWhenMissing, statement );
1:d847ced:         grantPermission( ruthConnection, permission.text, ALICE );
1:d847ced:         assertResults( aliceConnection, statement, expectedResults, false );
1:d847ced:     }
1:d847ced:     private void    grantPermission( Connection conn, String permission, String grantee )
1:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         String  command = "grant " + permission + " to " + grantee;
1:d847ced: 
1:d847ced:         goodStatement( conn, command );
1:d847ced:     }
1:d847ced:     private void    revokePermission( Connection conn, String permission, String grantee )
1:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         String  command = "revoke " + permission + " from " + grantee;
1:d847ced:         if ( permission.startsWith( "execute" ) || permission.startsWith( "usage" ) )   { command += " restrict"; }
1:d847ced: 
1:d847ced:         goodStatement( conn, command );
1:d847ced:     }
1:d847ced: 
1:502ed2e:     /**
1:502ed2e:      * <p>
1:d847ced:      * Test that only the DBO can (un)load the tool and the tool
1:d847ced:      * can't be (un)loaded twice.
1:d847ced:      * </p>
1:d847ced:      */
1:d847ced:     public  void    test_003_loading()
1:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:d847ced:         Connection  ruthConnection = openUserConnection( RUTH );
1:d847ced: 
1:d847ced:         createSchema( ruthConnection, Types.INTEGER );
1:d847ced: 
1:d847ced:         goodStatement( dboConnection, "grant execute on procedure syscs_util.syscs_register_tool to public" );
1:d847ced: 
1:d847ced:         // only the DBO can load the tool
1:d847ced:         expectExecutionError( ruthConnection, DBO_ONLY, LOAD_TOOL );
1:d847ced: 
1:d847ced:         goodStatement( dboConnection, LOAD_TOOL );
1:d847ced:         expectExecutionError( dboConnection, DOUBLE_LOAD_ILLEGAL, LOAD_TOOL );
1:d847ced: 
1:d847ced:         // cannot index non-existent table or column
1:2277df2:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'foo', 'poemText', null )" );
1:2277df2:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'poems', 'fooText', null )" );
1:2277df2:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'poems', 'versionStamp', null )" );
1:d847ced: 
1:d847ced:         // cannot drop non-existent index
1:d847ced:         expectExecutionError( ruthConnection, NONEXISTENT_OBJECT, "call LuceneSupport.dropIndex( 'ruth', 'foo', 'poemText' )" );
1:d847ced:         expectExecutionError( ruthConnection, NONEXISTENT_OBJECT, "call LuceneSupport.dropIndex( 'ruth', 'poems', 'versionStamp' )" );
1:d847ced:         
1:d847ced:         // only the DBO can unload the tool
1:d847ced:         expectExecutionError( ruthConnection, DBO_ONLY, UNLOAD_TOOL );
1:d847ced: 
1:d847ced:         goodStatement( dboConnection, "revoke execute on procedure syscs_util.syscs_register_tool from public restrict" );
1:d847ced: 
1:d847ced:         goodStatement( dboConnection, UNLOAD_TOOL );
1:d847ced:         expectExecutionError( dboConnection, DOUBLE_UNLOAD_ILLEGAL, UNLOAD_TOOL );
1:d847ced: 
1:d847ced:         // try loading and unloading again for good measure
1:d847ced:         goodStatement( dboConnection, LOAD_TOOL );
1:d847ced:         goodStatement( dboConnection, UNLOAD_TOOL );
1:6aeea9c:         dropSchema( ruthConnection );
1:d847ced:     }
1:d847ced:     
1:cbdf827:     /**
1:cbdf827:      * <p>
1:d847ced:      * Test all datatypes as key types.
1:d847ced:      * </p>
1:d847ced:      */
1:d847ced:     public  void    test_004_datatypes()
1:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:d847ced:         Connection  ruthConnection = openUserConnection( RUTH );
1:d847ced: 
1:d847ced:         goodStatement( dboConnection, LOAD_TOOL );
1:d847ced: 
1:d847ced:         vet_004( ruthConnection, Types.BIGINT );
1:d847ced:         vet_004( ruthConnection, Types.BOOLEAN );
1:d847ced:         vet_004( ruthConnection, Types.CHAR );
1:d847ced:         vet_004( ruthConnection, Types.BINARY );
1:d847ced:         vet_004( ruthConnection, Types.DATE );
1:d847ced:         vet_004( ruthConnection, Types.DECIMAL );
1:d847ced:         vet_004( ruthConnection, Types.DOUBLE );
1:d847ced:         vet_004( ruthConnection, Types.FLOAT );
1:d847ced:         vet_004( ruthConnection, Types.INTEGER );
1:d847ced:         vet_004( ruthConnection, Types.NUMERIC );
1:d847ced:         vet_004( ruthConnection, Types.REAL );
1:d847ced:         vet_004( ruthConnection, Types.SMALLINT );
1:d847ced:         vet_004( ruthConnection, Types.TIME );
1:d847ced:         vet_004( ruthConnection, Types.TIMESTAMP );
1:d847ced:         vet_004( ruthConnection, Types.VARCHAR );
1:d847ced:         vet_004( ruthConnection, Types.VARBINARY );
1:d847ced: 
1:d847ced:         goodStatement( dboConnection, UNLOAD_TOOL );
1:d847ced:     }
1:d847ced:     private void    vet_004( Connection ruthConnection, int jdbcType )
1:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         createSchema( ruthConnection, jdbcType );
1:d847ced:         goodStatement( ruthConnection, INDEX_POEMS );
1:d847ced: 
1:d847ced:         // make sure that we can de-serialize the key
1:d847ced:         assertResults
1:d847ced:             (
1:d847ced:              ruthConnection,
1:cbdf827:              "select p.originalAuthor, i.score\n" +
1:a4e6298:              "from ruth.poems p, table ( ruth.poems__poemText( 'star', 1000, null ) ) i\n" +
1:d847ced:              "where p.poemID = i.poemID and p.versionStamp = i.versionStamp\n" +
1:cbdf827:              "order by i.score desc\n",
1:d847ced:              new String[][]
1:d847ced:              {
1:2277df2:                  { "Walt Whitman", "0.26756266" },
1:2277df2:                  { "Lord Byron", "0.22933942" },
1:2277df2:                  { "John Milton", "0.22933942" },
1:d847ced:              },
1:d847ced:              false
1:d847ced:              );
1:d847ced: 
1:d847ced:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:d847ced:         dropSchema( ruthConnection );
1:d847ced:     }
1:d847ced: 
1:fcf3e6d:     /**
1:fcf3e6d:      * <p>
1:d847ced:      * Test error messages when a lucene directory has been deleted.
1:d847ced:      * </p>
1:d847ced:      */
1:d847ced:     public  void    test_005_deleteDirectory()
1:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:d847ced:         Connection  ruthConnection = openUserConnection( RUTH );
1:d847ced: 
1:d847ced:         createSchema( ruthConnection, Types.INTEGER );
1:d847ced:         goodStatement( dboConnection, LOAD_TOOL );
1:d847ced:         goodStatement( ruthConnection, INDEX_POEMS );
1:d847ced: 
1:d847ced:         TestConfiguration   config = getTestConfiguration();
1:d847ced: 
1:d847ced:         String  dbName = config.getDefaultDatabaseName();
1:d847ced:         String  physicalDBName = config.getPhysicalDatabaseName( dbName );
1:d847ced:         String  dbPath = config.getDatabasePath( physicalDBName );
1:d847ced:         File    dbDirectory = new File( dbPath );
1:faa9027:         File    luceneDirectory = new File( dbDirectory, "LUCENE" );
1:d847ced:         File    ruthDirectory = new File( luceneDirectory, "RUTH" );
1:d847ced:         File    poemsDirectory = new File( ruthDirectory, "POEMS" );
1:d847ced:         File    poemTextIndexDirectory = new File( poemsDirectory, "POEMTEXT" );
1:d847ced: 
1:d847ced:         assertTrue( deleteFile( poemTextIndexDirectory ) );
1:d847ced: 
1:5cf7a46:         // but that doesn't stop you from deleting the index
1:5cf7a46:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:5cf7a46:         expectCompilationError
1:5cf7a46:             (
1:5cf7a46:              ruthConnection, NONEXISTENT_TABLE_FUNCTION,
1:a4e6298:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 100, null ) ) t"
1:5cf7a46:              );
1:d847ced: 
1:d847ced:         goodStatement( dboConnection, UNLOAD_TOOL );
1:d847ced:         dropSchema( ruthConnection );
1:d847ced:     }
1:d847ced:     
1:2277df2:     /**
1:2277df2:      * <p>
1:2277df2:      * Test that you can change the Analyzer.
1:2277df2:      * </p>
1:2277df2:      */
1:2277df2:     public  void    test_006_changeAnalyzer()
1:2277df2:         throws Exception
1:2277df2:     {
1:2277df2:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:2277df2:         Connection  ruthConnection = openUserConnection( RUTH );
1:2277df2: 
1:2277df2:         createSchema( ruthConnection, Types.INTEGER );
1:2277df2:         goodStatement( dboConnection, LOAD_TOOL );
1:2277df2:         goodStatement( ruthConnection, INDEX_POEMS );
1:2277df2: 
1:2277df2:         // verify that we are the correct locale
1:2277df2:         assertResults
1:2277df2:             (
1:2277df2:              ruthConnection,
1:1a8d034:              "values ( substr( getDatabaseLocale(), 1, 2 ) )",
1:2277df2:              new String[][]
1:2277df2:              {
1:1a8d034:                  { LANGUAGE },
1:2277df2:              },
1:2277df2:              false
1:2277df2:              );
1:2277df2:         
1:2277df2: 
1:2277df2:         String  query =
1:cbdf827:             "select p.originalAuthor, i.score\n" +
1:a4e6298:             "from ruth.poems p, table ( ruth.poems__poemText( 'star', 1000, null ) ) i\n" +
1:2277df2:             "where p.poemID = i.poemID and p.versionStamp = i.versionStamp\n" +
1:cbdf827:             "order by i.score desc\n";
1:2277df2: 
1:2277df2:         assertResults
1:2277df2:             (
1:2277df2:              ruthConnection,
1:2277df2:              query,
1:2277df2:              new String[][]
1:2277df2:              {
1:2277df2:                  { "Walt Whitman", "0.26756266" },
1:2277df2:                  { "Lord Byron", "0.22933942" },
1:2277df2:                  { "John Milton", "0.22933942" },
1:2277df2:              },
1:2277df2:              false
1:2277df2:              );
1:2277df2: 
1:2277df2:         // now switch the Analyzer and re-run the query
1:fcf3e6d:         goodStatement
1:2277df2:             ( ruthConnection,
1:a4e6298:               "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText', '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:2277df2: 
1:2277df2:         assertResults
1:2277df2:             (
1:2277df2:              ruthConnection,
1:2277df2:              query,
1:2277df2:              new String[][]
1:2277df2:              {
1:2277df2:                  { "Walt Whitman", "0.3304931" },
1:2277df2:                  { "John Milton", "0.2832798" },
1:2277df2:              },
1:2277df2:              false
1:2277df2:              );
1:2277df2: 
1:0b71ff5:         //
1:2277df2:         // Add another index and inspect the values of listIndexes()
1:2277df2:         //
1:2277df2:         goodStatement( ruthConnection, "call LuceneSupport.createIndex( 'ruth', 'poems', 'originalAuthor', null )" );
1:2277df2:         assertResults
1:2277df2:             (
1:2277df2:              ruthConnection,
1:a4e6298:              "select schemaName, tableName, columnName, luceneVersion, analyzer, indexDescriptorMaker\n" +
1:2277df2:              "from table( LuceneSupport.listIndexes() ) l\n" +
1:2277df2:              "order by schemaName, tableName, columnName\n",
1:2277df2:              new String[][]
1:2277df2:              {
1:2277df2:                  {
1:2277df2:                      "RUTH", "POEMS", "ORIGINALAUTHOR", LUCENE_VERSION,
1:2277df2:                      "org.apache.lucene.analysis.en.EnglishAnalyzer",
1:a4e6298:                      DEFAULT_INDEX_DESCRIPTOR
1:2277df2:                  },
1:2277df2:                  {
1:2277df2:                      "RUTH", "POEMS", "POEMTEXT", LUCENE_VERSION,
1:2277df2:                      "org.apache.lucene.analysis.standard.StandardAnalyzer",
1:a4e6298:                      LuceneCoarseAuthorizationTest.STANDARD_ANALYZER
1:2277df2:                  },
1:2277df2:              },
1:2277df2:              false
1:2277df2:              );
1:2277df2: 
1:2277df2:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:2277df2:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'poems', 'originalAuthor' )" );
1:2277df2:         goodStatement( dboConnection, UNLOAD_TOOL );
1:2277df2:         dropSchema( ruthConnection );
1:2277df2:     }
1:2277df2: 
1:d847ced:     /**
1:d847ced:      * <p>
1:fcf3e6d:      * Test that you can index views and index tables with alternative column lists.
1:fcf3e6d:      * </p>
1:fcf3e6d:      */
1:fcf3e6d:     public  void    test_007_indexViews()
1:fcf3e6d:         throws Exception
1:fcf3e6d:     {
1:fcf3e6d:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:fcf3e6d:         Connection  ruthConnection = openUserConnection( RUTH );
1:fcf3e6d: 
1:fcf3e6d:         createSchema( ruthConnection, Types.INTEGER );
1:fcf3e6d:         createPoemView( ruthConnection );
1:fcf3e6d:         goodStatement( dboConnection, LOAD_TOOL );
1:fcf3e6d:         goodStatement( ruthConnection, INDEX_POEMS );
1:fcf3e6d: 
1:fcf3e6d:         // must supply some key columns if you're going to index a view
1:fcf3e6d:         expectExecutionError
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              NO_PRIMARY_KEY,
1:fcf3e6d:              "call LuceneSupport.createIndex( 'ruth', 'poemView', 'poemText', null )"
1:fcf3e6d:              );
1:fcf3e6d: 
1:fcf3e6d:         // now index the view
1:fcf3e6d:         goodStatement
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              "call LuceneSupport.createIndex( 'ruth', 'poemView', 'poemText', null, 'poemID', 'versionStamp' )"
1:fcf3e6d:              );
1:fcf3e6d: 
1:fcf3e6d:         // can't create a second index by the same name
1:fcf3e6d:         expectExecutionError
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              FUNCTION_EXISTS,
1:fcf3e6d:              "call LuceneSupport.createIndex( 'ruth', 'poemView', 'poemText', null, 'poemID' )"
1:fcf3e6d:              );
1:fcf3e6d: 
1:fcf3e6d:         // vet index contents
1:fcf3e6d:         String  selectFromViewIndex =
1:cbdf827:             "select p.originalAuthor, i.score\n" +
1:a4e6298:             "from ruth.poems p, table ( ruth.poemView__poemText( 'star', 1000, null ) ) i\n" +
1:fcf3e6d:             "where p.poemID = i.poemID and p.versionStamp = i.versionStamp\n" +
1:cbdf827:             "order by i.score desc\n";
1:fcf3e6d:         assertResults
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              selectFromViewIndex,
1:fcf3e6d:              new String[][]
1:fcf3e6d:              {
1:fcf3e6d:                  { "Walt Whitman", "0.26756266" },
1:fcf3e6d:                  { "Lord Byron", "0.22933942" },
1:fcf3e6d:                  { "John Milton", "0.22933942" },
1:fcf3e6d:              },
1:fcf3e6d:              false
1:fcf3e6d:              );
1:fcf3e6d: 
1:fcf3e6d:         // vet index list
1:fcf3e6d:         String  selectIndexes =
1:a4e6298:             "select schemaName, tableName, columnName, indexDescriptorMaker\n" +
1:fcf3e6d:             "from table( LuceneSupport.listIndexes() ) l\n" +
1:fcf3e6d:             "order by schemaName, tableName, columnName\n";
1:fcf3e6d:         assertResults
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              selectIndexes,
1:fcf3e6d:              new String[][]
1:fcf3e6d:              {
1:fcf3e6d:                  {
1:fcf3e6d:                      "RUTH", "POEMS", "POEMTEXT",
1:a4e6298:                      DEFAULT_INDEX_DESCRIPTOR
1:fcf3e6d:                  },
1:fcf3e6d:                  {
1:fcf3e6d:                      "RUTH", "POEMVIEW", "POEMTEXT",
1:a4e6298:                      DEFAULT_INDEX_DESCRIPTOR
1:fcf3e6d:                  },
1:fcf3e6d:              },
1:fcf3e6d:              false
1:fcf3e6d:              );
1:fcf3e6d: 
1:fcf3e6d:         // update the view index, changing its analyzer
1:fcf3e6d:         goodStatement
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:a4e6298:              "call LuceneSupport.updateIndex( 'ruth', 'poemView', 'poemText', '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )"
1:fcf3e6d:              );
1:fcf3e6d:         assertResults
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              selectFromViewIndex,
1:fcf3e6d:              new String[][]
1:fcf3e6d:              {
1:fcf3e6d:                  { "Walt Whitman", "0.3304931" },
1:fcf3e6d:                  { "John Milton", "0.2832798" },
1:fcf3e6d:              },
1:fcf3e6d:              false
1:fcf3e6d:              );
1:fcf3e6d:         assertResults
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              selectIndexes,
1:fcf3e6d:              new String[][]
1:fcf3e6d:              {
1:fcf3e6d:                  {
1:fcf3e6d:                      "RUTH", "POEMS", "POEMTEXT",
1:a4e6298:                      DEFAULT_INDEX_DESCRIPTOR
1:fcf3e6d:                  },
1:fcf3e6d:                  {
1:fcf3e6d:                      "RUTH", "POEMVIEW", "POEMTEXT",
1:a4e6298:                      LuceneCoarseAuthorizationTest.STANDARD_ANALYZER
1:fcf3e6d:                  },
1:fcf3e6d:              },
1:fcf3e6d:              false
1:fcf3e6d:              );
1:fcf3e6d: 
1:fcf3e6d:         // drop the index on the view
1:fcf3e6d:         goodStatement
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              "call LuceneSupport.dropIndex( 'ruth', 'poemView', 'poemText' )"
1:fcf3e6d:              );
1:fcf3e6d:         assertResults
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              selectIndexes,
1:fcf3e6d:              new String[][]
1:fcf3e6d:              {
1:fcf3e6d:                  {
1:fcf3e6d:                      "RUTH", "POEMS", "POEMTEXT",
1:a4e6298:                      DEFAULT_INDEX_DESCRIPTOR
1:fcf3e6d:                  },
1:fcf3e6d:              },
1:fcf3e6d:              false
1:fcf3e6d:              );
1:fcf3e6d: 
1:fcf3e6d:         // now drop the index on the table and create one with just one key column
1:fcf3e6d:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:fcf3e6d:         goodStatement
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              "call LuceneSupport.createIndex( 'ruth', 'poems', 'poemText', null, 'poemID' )"
1:fcf3e6d:              );
1:fcf3e6d:         assertResults
1:fcf3e6d:             (
1:fcf3e6d:              ruthConnection,
1:fcf3e6d:              "select *\n" +
1:a4e6298:              "from table ( ruth.poems__poemText( 'star', 1000, null ) ) i\n" +
1:cbdf827:              "order by i.score desc\n",
1:fcf3e6d:              new String[][]
1:fcf3e6d:              {
1:fcf3e6d:                  { "5", "4", "0.26756266" },
1:fcf3e6d:                  { "4", "3", "0.22933942" },
1:fcf3e6d:                  { "3", "2", "0.22933942" },
1:fcf3e6d:              },
1:fcf3e6d:              false
1:fcf3e6d:              );
1:fcf3e6d:         
1:fcf3e6d:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:fcf3e6d:         goodStatement( dboConnection, UNLOAD_TOOL );
1:fcf3e6d:         goodStatement( ruthConnection, "drop view poemView" );
1:fcf3e6d:         dropSchema( ruthConnection );
1:fcf3e6d:     }
1:fcf3e6d: 
1:d847ced:     /**
1:d847ced:      * <p>
1:cbdf827:      * Test that you can't create an index involving a column with the same name
1:cbdf827:      * as one of the system-supplied column names (documentID and score).
1:cbdf827:      * </p>
1:cbdf827:      */
1:cbdf827:     public  void    test_008_columnNames()
1:cbdf827:         throws Exception
1:cbdf827:     {
1:cbdf827:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:cbdf827:         Connection  ruthConnection = openUserConnection( RUTH );
1:cbdf827: 
1:cbdf827:         goodStatement( dboConnection, LOAD_TOOL );
1:fcf3e6d: 
1:cbdf827:         goodStatement( ruthConnection, "create table badTable1( keyCol int primary key, score clob )" );
1:cbdf827:         goodStatement( ruthConnection, "create table badTable2( keyCol int primary key, documentID clob )" );
1:cbdf827:         goodStatement( ruthConnection, "create table badTable3( score int primary key, textCol clob )" );
1:cbdf827:         goodStatement( ruthConnection, "create table badTable4( documentID int primary key, textCol clob )" );
1:cbdf827: 
1:cbdf827:         expectExecutionError
1:cbdf827:             (
1:cbdf827:              ruthConnection, BAD_COLUMN_NAME,
1:cbdf827:              "call LuceneSupport.createIndex( 'ruth', 'badTable1', 'score', null )"
1:cbdf827:              );
1:cbdf827:         expectExecutionError
1:cbdf827:             (
1:cbdf827:              ruthConnection, BAD_COLUMN_NAME,
1:cbdf827:              "call LuceneSupport.createIndex( 'ruth', 'badTable2', 'documentID', null )"
1:cbdf827:              );
1:cbdf827:         expectExecutionError
1:cbdf827:             (
1:cbdf827:              ruthConnection, BAD_COLUMN_NAME,
1:cbdf827:              "call LuceneSupport.createIndex( 'ruth', 'badTable3', 'textCol', null )"
1:cbdf827:              );
1:cbdf827:         expectExecutionError
1:cbdf827:             (
1:cbdf827:              ruthConnection, BAD_COLUMN_NAME,
1:cbdf827:              "call LuceneSupport.createIndex( 'ruth', 'badTable4', 'textCol', null )"
1:cbdf827:              );
1:cbdf827: 
1:cbdf827:         goodStatement( dboConnection, UNLOAD_TOOL );
1:cbdf827:         goodStatement( ruthConnection, "drop table badTable1" );
1:cbdf827:         goodStatement( ruthConnection, "drop table badTable2" );
1:cbdf827:         goodStatement( ruthConnection, "drop table badTable3" );
1:cbdf827:         goodStatement( ruthConnection, "drop table badTable4" );
1:cbdf827:     }
1:cbdf827:     
1:0b71ff5:    /**
1:0b71ff5:      * <p>
1:0b71ff5:      * Test changes to the arguments to the searching table function.
1:0b71ff5:      * </p>
1:0b71ff5:      */
1:0b71ff5:     public  void    test_009_searchArgs()
1:0b71ff5:         throws Exception
1:0b71ff5:     {
1:0b71ff5:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:0b71ff5:         Connection  ruthConnection = openUserConnection( RUTH );
1:0b71ff5: 
1:0b71ff5:         loadTestTable( ruthConnection );
1:0b71ff5:         
1:0b71ff5:         goodStatement( dboConnection, LOAD_TOOL );
1:0b71ff5:         goodStatement( ruthConnection, "call LuceneSupport.createIndex( 'ruth', 'textTable', 'textCol', null )" );
1:0b71ff5: 
1:0b71ff5:         // get all the matches
1:0b71ff5:         assertResults
1:0b71ff5:             (
1:0b71ff5:              ruthConnection,
1:a4e6298:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 100, null ) ) t",
1:0b71ff5:              new String[][]
1:0b71ff5:              {
1:0b71ff5:                  { "10", "9", "2.2791052" },
1:0b71ff5:                  { "9", "8", "1.6305782" },
1:0b71ff5:                  { "8", "7", "1.1616905" },
1:0b71ff5:                  { "7", "6", "0.97469425" },
1:0b71ff5:                  { "6", "5", "0.6597747" },
1:0b71ff5:                  { "5", "4", "0.49575216" },
1:0b71ff5:                  { "4", "3", "0.33803377" },
1:0b71ff5:                  { "3", "2", "0.17799875" },
1:0b71ff5:                  { "2", "1", "0.09289266" },
1:0b71ff5:                  { "1", "0", "0.035006654" },
1:0b71ff5:              },
1:0b71ff5:              false
1:0b71ff5:              );
1:0b71ff5:         
1:0b71ff5:         // get an initial 3-row window of the top results
1:0b71ff5:         assertResults
1:0b71ff5:             (
1:0b71ff5:              ruthConnection,
1:a4e6298:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 3, null ) ) t",
1:0b71ff5:              new String[][]
1:0b71ff5:              {
1:0b71ff5:                  { "10", "9", "2.2791052" },
1:0b71ff5:                  { "9", "8", "1.6305782" },
1:0b71ff5:                  { "8", "7", "1.1616905" },
1:0b71ff5:              },
1:0b71ff5:              false
1:0b71ff5:              );
1:0b71ff5:         
1:0b71ff5:         // get the next 4-row window of results
1:0b71ff5:         assertResults
1:0b71ff5:             (
1:0b71ff5:              ruthConnection,
1:a4e6298:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 4, 1.0 ) ) t",
1:0b71ff5:              new String[][]
1:0b71ff5:              {
1:0b71ff5:                  { "7", "6", "0.97469425" },
1:0b71ff5:                  { "6", "5", "0.6597747" },
1:0b71ff5:                  { "5", "4", "0.49575216" },
1:0b71ff5:                  { "4", "3", "0.33803377" },
1:0b71ff5:              },
1:0b71ff5:              false
1:0b71ff5:              );
1:0b71ff5: 
1:0b71ff5:         // get the final window of results
1:0b71ff5:         assertResults
1:0b71ff5:             (
1:0b71ff5:              ruthConnection,
1:a4e6298:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 100, 0.2 ) ) t",
1:0b71ff5:              new String[][]
1:0b71ff5:              {
1:0b71ff5:                  { "3", "2", "0.17799875" },
1:0b71ff5:                  { "2", "1", "0.09289266" },
1:0b71ff5:                  { "1", "0", "0.035006654" },
1:0b71ff5:              },
1:0b71ff5:              false
1:0b71ff5:              );
1:0b71ff5:         
1:0b71ff5:         // try a different query parser
1:a4e6298:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'textTable', 'textCol' )" );
1:a4e6298:         goodStatement
1:a4e6298:             (
1:a4e6298:              ruthConnection,
1:a4e6298:              "call LuceneSupport.createIndex( 'ruth', 'textTable', 'textCol', '" + CONSTANT_QUERY_PARSER + "' )"
1:a4e6298:              );
1:0b71ff5:         assertResults
1:0b71ff5:             (
1:0b71ff5:              ruthConnection,
1:a4e6298:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 100, null ) ) t",
1:0b71ff5:              new String[][]
1:0b71ff5:              {
1:0b71ff5:                  { "1", "0", "1.597837" },
1:0b71ff5:                  { "2", "1", "0.9986481" },
1:0b71ff5:                  { "3", "2", "0.7989185" },
1:0b71ff5:                  { "4", "3", "0.7989185" },
1:0b71ff5:                  { "5", "4", "0.69905365" },
1:0b71ff5:                  { "6", "5", "0.59918886" },
1:0b71ff5:                  { "7", "6", "0.59918886" },
1:0b71ff5:                  { "8", "7", "0.49932405" },
1:0b71ff5:                  { "9", "8", "0.49932405" },
1:0b71ff5:                  { "10", "9", "0.49932405" },
1:0b71ff5:              },
1:0b71ff5:              false
1:0b71ff5:              );
1:0b71ff5:         
1:0b71ff5:         goodStatement( dboConnection, UNLOAD_TOOL );
1:0b71ff5:         unloadTestTable( ruthConnection );
1:0b71ff5:     }
1:a409436:     static  void    loadTestTable( Connection conn ) throws Exception
1:0b71ff5:     {
1:a409436:         conn.prepareStatement
1:0b71ff5:             (
1:0b71ff5:              "create table textTable( keyCol int primary key, textCol clob )"
1:a409436:              ).execute();
1:a409436:         conn.prepareStatement
1:0b71ff5:             (
1:0b71ff5:              "insert into textTable values\n" +
1:0b71ff5:              "( 1, 'one' ),\n" +
1:0b71ff5:              "( 2, 'one two' ),\n" +
1:0b71ff5:              "( 3, 'one two three' ),\n" +
1:0b71ff5:              "( 4, 'one two three four' ),\n" +
1:0b71ff5:              "( 5, 'one two three four five' ),\n" +
1:0b71ff5:              "( 6, 'one two three four five six' ),\n" +
1:0b71ff5:              "( 7, 'one two three four five six seven' ),\n" +
1:0b71ff5:              "( 8, 'one two three four five six seven eight' ),\n" +
1:0b71ff5:              "( 9, 'one two three four five six seven eight nine' ),\n" +
1:0b71ff5:              "( 10, 'one two three four five six seven eight nine ten' ),\n" +
1:0b71ff5:              "( 101, 'bricks' ),\n" +
1:0b71ff5:              "( 102, 'bricks and mortar' ),\n" +
1:0b71ff5:              "( 103, 'bricks and mortar, tea' ),\n" +
1:0b71ff5:              "( 104, 'bricks and mortar, tea, tears' ),\n" +
1:0b71ff5:              "( 105, 'bricks and mortar, tea, tears, turtle' ),\n" +
1:0b71ff5:              "( 106, 'bricks and mortar, tea, tears, turtle, soup' ),\n" +
1:0b71ff5:              "( 107, 'bricks and mortar, tea, tears, turtle, soup, when in the course' ),\n" +
1:0b71ff5:              "( 108, 'bricks and mortar, tea, tears, turtle, soup, when in the course of human events' ),\n" +
1:0b71ff5:              "( 109, 'bricks and mortar, tea, tears, turtle, soup, when in the course of human events you want' ),\n" +
1:0b71ff5:              "( 110, 'bricks and mortar, tea, tears, turtle, soup, when in the course of human events you want better cell coverage' )\n"
1:a409436:              ).execute();
1:0b71ff5:     }
1:a409436:     static  void    unloadTestTable( Connection conn ) throws Exception
1:0b71ff5:     {
1:a409436:         conn.prepareStatement
1:0b71ff5:             (
1:0b71ff5:              "drop table textTable"
1:a409436:              ).execute();
1:d847ced:     }
1:d847ced: 
1:d847ced:    /**
1:d847ced:      * <p>
1:502ed2e:      * Test that encryption and the Lucene plugin are incompatible.
1:502ed2e:      * </p>
1:502ed2e:      */
1:502ed2e:     public  void    test_010_encryption()
1:502ed2e:         throws Exception
1:502ed2e:     {
1:502ed2e:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:502ed2e:         String      password = getTestConfiguration().getPassword( TEST_DBO );
1:502ed2e:         String      encryptDatabaseURL = "jdbc:derby:" + DB_NAME + ";user=" + TEST_DBO + ";password=" + password +
1:502ed2e:                 ";dataEncryption=true;bootPassword=tryToGuessThis";
1:502ed2e:         String      decryptDatabaseURL = "jdbc:derby:" + DB_NAME + ";user=" + TEST_DBO + ";password=" + password +
1:502ed2e:                 ";decryptDatabase=true;bootPassword=tryToGuessThis";
1:502ed2e: 
1:502ed2e:         goodStatement( dboConnection, LOAD_TOOL );
1:502ed2e:         getTestConfiguration().shutdownDatabase();
1:502ed2e: 
1:502ed2e:         // verify that you can't encrypt the database now
1:502ed2e:         try {
1:502ed2e:             DriverManager.getConnection( encryptDatabaseURL );
1:502ed2e:             fail( "Should not have been able to get a connection!" );
1:502ed2e:         }
1:502ed2e:         catch (SQLException se)
1:502ed2e:         {
1:502ed2e:             assertSQLState( INCOMPATIBLE_ENCRYPTION, se );
1:502ed2e:         }
1:502ed2e: 
1:502ed2e:         // now unload the tool and encrypt the database
1:502ed2e:         dboConnection = openUserConnection( TEST_DBO );
1:502ed2e:         goodStatement( dboConnection, UNLOAD_TOOL );
1:502ed2e:         getTestConfiguration().shutdownDatabase();
1:502ed2e:         dboConnection = DriverManager.getConnection( encryptDatabaseURL );
1:502ed2e: 
1:502ed2e:         // now you can't load the plugin
1:502ed2e:         expectExecutionError( dboConnection, INCOMPATIBLE_ENCRYPTION, LOAD_TOOL );
1:502ed2e: 
1:502ed2e:         // turn off encryption
1:502ed2e:         getTestConfiguration().shutdownDatabase();
1:502ed2e:         dboConnection = DriverManager.getConnection( decryptDatabaseURL );
1:502ed2e:     }
1:502ed2e:     
1:abb2084:    /**
1:abb2084:      * <p>
1:7e538ec:      * Test restrictions on field names.
1:7e538ec:      * </p>
1:7e538ec:      */
1:7e538ec:     public  void    test_011_fieldNames()
1:7e538ec:         throws Exception
1:7e538ec:     {
1:7e538ec:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:7e538ec:         Connection  ruthConnection = openUserConnection( RUTH );
1:7e538ec: 
1:7e538ec:         loadTestTable( ruthConnection );
1:7e538ec:         goodStatement( dboConnection, LOAD_TOOL );
1:7e538ec: 
1:7e538ec:         String  indexTestTable =
1:7e538ec:             "call LuceneSupport.createIndex\n" +
1:7e538ec:             "(\n" +
1:7e538ec:             "    'ruth', 'textTable', 'textCol',\n" +
1:7e538ec:             "    'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.makeFieldNameIndexDescriptor'\n" +
1:7e538ec:             ")\n";
1:7e538ec:         
1:7e538ec:         goodStatement
1:7e538ec:             (
1:7e538ec:              ruthConnection,
1:7e538ec:              "create procedure setFieldNames( fieldName varchar( 32672 )... )\n" +
1:7e538ec:              "language java parameter style derby no sql\n" +
1:7e538ec:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.setFieldNames'\n"
1:7e538ec:              );
1:7e538ec: 
1:7e538ec:         // Field and key name conflict.
1:7e538ec:         goodStatement( ruthConnection, "call setFieldNames( 'KEYCOL' )" );
1:7e538ec:         expectExecutionError( ruthConnection, BAD_FIELD_NAME, indexTestTable );
1:7e538ec: 
1:7e538ec:         // Duplicate field names.
1:7e538ec:         goodStatement( ruthConnection, "call setFieldNames( 'FOO', 'FOO' )" );
1:7e538ec:         expectExecutionError( ruthConnection, DUPLICATE_FIELD_NAME, indexTestTable );
1:7e538ec: 
1:7e538ec:         // Null field name.
1:7e538ec:         goodStatement( ruthConnection, "call setFieldNames( 'FOO', null )" );
1:7e538ec:         expectExecutionError( ruthConnection, DUPLICATE_FIELD_NAME, indexTestTable );
1:7e538ec:         goodStatement( ruthConnection, "call setFieldNames( null, 'FOO' )" );
1:7e538ec:         expectExecutionError( ruthConnection, DUPLICATE_FIELD_NAME, indexTestTable );
1:7e538ec: 
1:7e538ec:         goodStatement( ruthConnection, "drop procedure setFieldNames" );
1:7e538ec:         goodStatement( dboConnection, UNLOAD_TOOL );
1:7e538ec:         unloadTestTable( ruthConnection );
1:7e538ec:     }
1:7e538ec: 
1:7e538ec:    /**
1:7e538ec:      * <p>
1:abb2084:      * Test that nulls are allowed in keys. See DERBY-6602.
1:abb2084:      * </p>
1:abb2084:      */
1:abb2084:     public  void    test_6602()
1:abb2084:         throws Exception
1:abb2084:     {
1:abb2084:         CD[]    columnDescriptors = new CD[]
1:abb2084:         {
1:abb2084:             new CD( "bigintCol", "bigint" ),
1:abb2084:             new CD( "blobCol", "blob" ),
1:abb2084:             new CD( "booleanCol", "boolean" ),
1:abb2084:             new CD( "charCol", "char( 10 )" ),
1:abb2084:             new CD( "clobCol", "clob" ),
1:abb2084:             new CD( "dataCol", "date" ),
1:abb2084:             new CD( "decimalCol", "decimal" ),
1:abb2084:             new CD( "doubleCol", "double" ),
1:abb2084:             new CD( "floatCol", "float" ),
1:abb2084:             new CD( "intCol", "int" ),
1:abb2084:             new CD( "longvarcharCol", "long varchar" ),
1:abb2084:             new CD( "longvarcharforbitdataCol", "long varchar for bit data" ),
1:abb2084:             new CD( "numericCol", "numeric" ),
1:abb2084:             new CD( "realCol", "real" ),
1:abb2084:             new CD( "smallintCol", "smallint" ),
1:abb2084:             new CD( "timeCol", "time" ),
1:abb2084:             new CD( "varcharCol", "varchar( 10 )" ),
1:abb2084:             new CD( "varcharforbitdataCol", "varchar( 10 ) for bit data" ),
1:abb2084:         };
1:abb2084: 
1:abb2084:         StringBuilder   buffer = new StringBuilder();
1:abb2084:         buffer.append( "create table t_6602\n(\ttextcol clob" );
1:abb2084:         for ( CD cd : columnDescriptors )
1:abb2084:         {
1:abb2084:             buffer.append( ",\n\t" + cd.name + " " + cd.type );
1:abb2084:         }
1:abb2084:         buffer.append( "\n)" );
1:abb2084:         
1:abb2084:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:abb2084:         
1:abb2084:         goodStatement( dboConnection, LOAD_TOOL );
1:abb2084:         goodStatement( dboConnection, buffer.toString() );
1:abb2084:         goodStatement( dboConnection, "insert into t_6602( textcol ) values ( 'abc'), ( 'def')" );
1:abb2084: 
1:abb2084:         for ( CD cd : columnDescriptors )
1:abb2084:         {
1:abb2084:             vet6602( dboConnection, cd );
1:abb2084:         }
1:abb2084: 
1:abb2084:         goodStatement( dboConnection, "drop table t_6602" );
1:abb2084:         goodStatement( dboConnection, UNLOAD_TOOL );
1:abb2084:     }
1:abb2084:     private void    vet6602( Connection conn, CD cd )   throws Exception
1:abb2084:     {
1:abb2084:         PreparedStatement   ps = chattyPrepare
1:abb2084:             (
1:abb2084:              conn,
1:abb2084:              "call lucenesupport.createindex\n" +
1:a4e6298:              "( 'TEST_DBO', 't_6602', 'textcol', '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "', ? )"
1:abb2084:              );
1:abb2084:         ps.setString( 1, cd.name );
1:abb2084:         ps.execute();
1:abb2084: 
1:abb2084:         assertResults
1:abb2084:             (
1:abb2084:              conn,
1:a4e6298:              "select * from table( t_6602__textcol( 'abc or def', 3, null ) ) tc order by documentid",
1:abb2084:              new String[][]
1:abb2084:              {
1:abb2084:                  { null, "0", "0.35355338" },
1:abb2084:                  { null, "1", "0.35355338" },
1:abb2084:              },
1:abb2084:              false
1:abb2084:              );
1:abb2084: 
1:abb2084:         goodStatement( conn, "call lucenesupport.dropIndex( 'TEST_DBO', 't_6602', 'textcol' )" );
1:abb2084:     }
1:abb2084:     
1:4f7c143:    /**
1:4f7c143:      * <p>
1:4f7c143:      * Test that nulls are not allowed as the values of certain arguments. See DERBY-6596.
1:4f7c143:      * </p>
1:4f7c143:      */
1:4f7c143:     public  void    test_6596_null_args()
1:4f7c143:         throws Exception
1:4f7c143:     {
1:4f7c143:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:4f7c143:         
1:4f7c143:         goodStatement( dboConnection, LOAD_TOOL );
1:4f7c143:         goodStatement( dboConnection, "create table t_6596( x int primary key, c clob )" );
1:4f7c143:         goodStatement( dboConnection, "insert into t_6596 values ( 1, 'abc' ), ( 2, 'def' )" );
1:4f7c143: 
1:4f7c143:         // create index errors
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "call lucenesupport.createindex( null, 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "call lucenesupport.createindex( 'TEST_DBO', null, 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', null,  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "', null )" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "', 'x', null )" );
1:4f7c143: 
1:a4e6298:         goodStatement( dboConnection, "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:4f7c143:         assertResults
1:4f7c143:             (
1:4f7c143:              dboConnection,
1:a4e6298:              "select * from table( t_6596__c( 'abc or def', 3, null ) ) tc order by documentid",
1:4f7c143:              new String[][]
1:4f7c143:              {
1:4f7c143:                  { "1", "0", "0.35355338" },
1:4f7c143:                  { "2", "1", "0.35355338" },
1:4f7c143:              },
1:4f7c143:              false
1:4f7c143:              );
1:a4e6298:         goodStatement( dboConnection, "call lucenesupport.updateindex( 'TEST_DBO', 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:4f7c143:         
1:4f7c143:         // update index errors
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "call lucenesupport.updateindex( null, 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "call lucenesupport.updateindex( 'TEST_DBO', null, 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "call lucenesupport.updateindex( 'TEST_DBO', 't_6596', null,  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:4f7c143: 
1:4f7c143:         // query errors
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:a4e6298:               "select * from table( t_6596__c( null, 3, null ) ) tc order by documentid" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, NULL_PRIMITIVE_ARG,
1:a4e6298:               "select * from table( t_6596__c( 'abc or def', null, null ) ) tc order by documentid" );
1:4f7c143: 
1:4f7c143:         // drop index errors
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:4f7c143:               "call lucenesupport.dropindex( null, 't_6596', 'c' )" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:4f7c143:               "call lucenesupport.dropindex( 'TEST_DBO', null, 'c' )" );
1:4f7c143:         expectExecutionError
1:4f7c143:             ( dboConnection, ILLEGAL_NULL_ARG,
1:4f7c143:               "call lucenesupport.dropindex( 'TEST_DBO', 't_6596', null )" );
1:4f7c143: 
1:4f7c143:         goodStatement( dboConnection, "call lucenesupport.dropindex( 'TEST_DBO', 't_6596', 'c' )" );
1:4f7c143:         goodStatement( dboConnection, "drop table t_6596" );
1:4f7c143:         goodStatement( dboConnection, UNLOAD_TOOL );
1:4f7c143:     }
1:4f7c143:     
1:d847ced:     /**
1:d847ced:      * <p>
1:3240e21:      * Test identifier casing for keys and text columns. See DERBY-6730.
1:3240e21:      * </p>
1:3240e21:      */
1:3240e21:     public  void    test_6730()
1:3240e21:         throws Exception
1:3240e21:     {
1:3240e21:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:3240e21:         Connection  ruthConnection = openUserConnection( RUTH );
1:3240e21: 
1:3240e21:         createSchema( ruthConnection, Types.INTEGER );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "create view v_6730_1 ( poemID, poemText ) as select poemID, poemText from ruth.poems"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "create view v_6730_2 ( poemID, \"poemText\" ) as select poemID, poemText from ruth.poems"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "create view v_6730_3 ( \"poemID\", poemText ) as select poemID, poemText from ruth.poems"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "create view v_6730_4 ( \"poemID\", \"poemText\" ) as select poemID, poemText from ruth.poems"
1:3240e21:              );
1:19ca71c:         goodStatement
1:19ca71c:             (
1:19ca71c:              ruthConnection,
1:19ca71c:              "create view v_6730_5 ( poemID, \"c l o b\" ) as select poemID, poemText from ruth.poems"
1:19ca71c:              );
1:19ca71c:         goodStatement
1:19ca71c:             (
1:19ca71c:              ruthConnection,
1:19ca71c:              "create view v_6730_6 ( \"k e y\", poemText ) as select poemID, poemText from ruth.poems"
1:19ca71c:              );
1:3240e21: 
1:3240e21:         goodStatement( dboConnection, LOAD_TOOL );
1:3240e21: 
1:3240e21:         // Index the views
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "call luceneSupport.createIndex\n" +
1:3240e21:              "(\n" +
1:3240e21:              "  'ruth',\n" +
1:3240e21:              "  'v_6730_1',\n" +
1:3240e21:              "  'poemText',\n" +
1:3240e21:              "  null,\n" +
1:3240e21:              "  'poemID'\n" +
1:3240e21:              ")\n"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "call luceneSupport.createIndex\n" +
1:3240e21:              "(\n" +
1:3240e21:              "  'ruth',\n" +
1:3240e21:              "  'v_6730_2',\n" +
1:3240e21:              "  '\"poemText\"',\n" +
1:3240e21:              "  null,\n" +
1:3240e21:              "  'poemID'\n" +
1:3240e21:              ")\n"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "call luceneSupport.createIndex\n" +
1:3240e21:              "(\n" +
1:3240e21:              "  'ruth',\n" +
1:3240e21:              "  'v_6730_3',\n" +
1:3240e21:              "  'poemText',\n" +
1:3240e21:              "  null,\n" +
1:3240e21:              "  '\"poemID\"'\n" +
1:3240e21:              ")\n"
1:3240e21:              );
1:19ca71c:         goodStatement
1:19ca71c:             (
1:19ca71c:              ruthConnection,
1:19ca71c:              "call luceneSupport.createIndex\n" +
1:19ca71c:              "(\n" +
1:19ca71c:              "  'ruth',\n" +
1:3240e21:              "  'v_6730_4',\n" +
1:3240e21:              "  '\"poemText\"',\n" +
1:3240e21:              "  null,\n" +
1:3240e21:              "  '\"poemID\"'\n" +
1:3240e21:              ")\n"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "call luceneSupport.createIndex\n" +
1:3240e21:              "(\n" +
1:3240e21:              "  'ruth',\n" +
1:19ca71c:              "  'v_6730_5',\n" +
1:19ca71c:              "  '\"c l o b\"',\n" +
1:19ca71c:              "  null,\n" +
1:19ca71c:              "  'poemID'\n" +
1:19ca71c:              ")\n"
1:19ca71c:              );
1:19ca71c:         goodStatement
1:19ca71c:             (
1:19ca71c:              ruthConnection,
1:19ca71c:              "call luceneSupport.createIndex\n" +
1:19ca71c:              "(\n" +
1:19ca71c:              "  'ruth',\n" +
1:19ca71c:              "  'v_6730_6',\n" +
1:19ca71c:              "  'poemText',\n" +
1:19ca71c:              "  null,\n" +
1:19ca71c:              "  '\"k e y\"'\n" +
1:19ca71c:              ")\n"
1:19ca71c:              );
1:3240e21: 
1:3240e21:         // Verify the expected casing of identifiers
1:3240e21:         vet6730( ruthConnection );
1:3240e21: 
1:3240e21:         // Update the indexes and re-verify
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "call luceneSupport.updateIndex\n" +
1:3240e21:              "(\n" +
1:3240e21:              "  'ruth',\n" +
1:3240e21:              "  'v_6730_1',\n" +
1:3240e21:              "  'poemText',\n" +
1:3240e21:              "  null\n" +
1:19ca71c:              ")\n"
1:19ca71c:              );
1:19ca71c:         goodStatement
1:19ca71c:             (
1:19ca71c:              ruthConnection,
1:19ca71c:              "call luceneSupport.updateIndex\n" +
1:19ca71c:              "(\n" +
1:19ca71c:              "  'ruth',\n" +
1:3240e21:              "  'v_6730_2',\n" +
1:3240e21:              "  '\"poemText\"',\n" +
1:19ca71c:              "  null\n" +
1:19ca71c:              ")\n"
1:19ca71c:              );
1:19ca71c:         goodStatement
1:19ca71c:             (
1:19ca71c:              ruthConnection,
1:19ca71c:              "call luceneSupport.updateIndex\n" +
1:19ca71c:              "(\n" +
1:19ca71c:              "  'ruth',\n" +
1:3240e21:              "  'v_6730_3',\n" +
1:19ca71c:              "  'poemText',\n" +
1:19ca71c:              "  null\n" +
1:3240e21:              ")\n"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "call luceneSupport.updateIndex\n" +
1:3240e21:              "(\n" +
1:3240e21:              "  'ruth',\n" +
1:3240e21:              "  'v_6730_4',\n" +
1:3240e21:              "  '\"poemText\"',\n" +
1:3240e21:              "  null\n" +
1:3240e21:              ")\n"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "call luceneSupport.updateIndex\n" +
1:3240e21:              "(\n" +
1:3240e21:              "  'ruth',\n" +
1:19ca71c:              "  'v_6730_5',\n" +
1:19ca71c:              "  '\"c l o b\"',\n" +
1:3240e21:              "  null\n" +
1:3240e21:              ")\n"
1:3240e21:              );
1:3240e21:         goodStatement
1:3240e21:             (
1:3240e21:              ruthConnection,
1:3240e21:              "call luceneSupport.updateIndex\n" +
1:3240e21:              "(\n" +
1:3240e21:              "  'ruth',\n" +
1:19ca71c:              "  'v_6730_6',\n" +
1:3240e21:              "  'poemText',\n" +
1:3240e21:              "  null\n" +
1:3240e21:              ")\n"
1:3240e21:              );
1:3240e21:         vet6730( ruthConnection );
1:3240e21: 
1:3240e21:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_1', 'poemText' )" );
1:3240e21:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_2', '\"poemText\"' )" );
1:3240e21:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_3', 'poemText' )" );
1:3240e21:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_4', '\"poemText\"' )" );
1:19ca71c:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_5', '\"c l o b\"' )" );
1:19ca71c:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_6', 'poemText' )" );
1:3240e21:         goodStatement( dboConnection, UNLOAD_TOOL );
1:19ca71c:         goodStatement( ruthConnection, "drop view v_6730_6" );
1:19ca71c:         goodStatement( ruthConnection, "drop view v_6730_5" );
1:3240e21:         goodStatement( ruthConnection, "drop view v_6730_4" );
1:3240e21:         goodStatement( ruthConnection, "drop view v_6730_3" );
1:3240e21:         goodStatement( ruthConnection, "drop view v_6730_2" );
1:3240e21:         goodStatement( ruthConnection, "drop view v_6730_1" );
1:3240e21:         dropSchema( ruthConnection );
1:3240e21:     }
1:3240e21:     private void vet6730( Connection conn ) throws Exception
1:3240e21:     {
1:3240e21:         // Verify the expected casing of identifiers
1:3240e21:         String[][]  expectedResults = new String[][]
1:3240e21:         {
1:3240e21:             { "5", "0.26756266" },
1:3240e21:             { "4", "0.22933942" },
1:3240e21:             { "3", "0.22933942" },
1:3240e21:         };
1:3240e21:         assertResults
1:3240e21:             (
1:3240e21:              conn,
1:3240e21:              "select i.poemID, i.score\n" +
1:3240e21:              "from table ( ruth.v_6730_1__poemText( 'star', 1000, null ) ) i\n" +
1:3240e21:              "order by i.score desc\n",
1:3240e21:              expectedResults,
1:3240e21:              false
1:3240e21:              );
1:19ca71c:         assertResults
1:19ca71c:             (
1:19ca71c:              conn,
1:19ca71c:              "select i.poemID, i.score\n" +
1:3240e21:              "from table ( ruth.\"V_6730_2__poemText\"( 'star', 1000, null ) ) i\n" +
1:3240e21:              "order by i.score desc\n",
1:3240e21:              expectedResults,
1:3240e21:              false
1:3240e21:              );
1:3240e21:         assertResults
1:3240e21:             (
1:3240e21:              conn,
1:3240e21:              "select i.\"poemID\", i.score\n" +
1:3240e21:              "from table ( ruth.v_6730_3__poemText( 'star', 1000, null ) ) i\n" +
1:3240e21:              "order by i.score desc\n",
1:3240e21:              expectedResults,
1:3240e21:              false
1:3240e21:              );
1:3240e21:         assertResults
1:3240e21:             (
1:3240e21:              conn,
1:3240e21:              "select i.\"poemID\", i.score\n" +
1:3240e21:              "from table ( ruth.\"V_6730_4__poemText\"( 'star', 1000, null ) ) i\n" +
1:3240e21:              "order by i.score desc\n",
1:3240e21:              expectedResults,
1:3240e21:              false
1:3240e21:              );
1:3240e21:         assertResults
1:3240e21:             (
1:3240e21:              conn,
1:3240e21:              "select i.poemID, i.score\n" +
1:19ca71c:              "from table ( ruth.\"V_6730_5__c l o b\"( 'star', 1000, null ) ) i\n" +
1:19ca71c:              "order by i.score desc\n",
1:19ca71c:             expectedResults,
1:19ca71c:              false
1:19ca71c:              );
1:19ca71c:         assertResults
1:19ca71c:             (
1:19ca71c:              conn,
1:19ca71c:              "select i.\"k e y\", i.score\n" +
1:19ca71c:              "from table ( ruth.v_6730_6__poemText( 'star', 1000, null ) ) i\n" +
1:19ca71c:              "order by i.score desc\n",
1:19ca71c:              expectedResults,
1:19ca71c:              false
1:19ca71c:              );
1:3240e21:         
1:3240e21:         String[][]  expectedListResults = new String[][]
1:3240e21:         {
1:3240e21:             { "RUTH", "V_6730_1", "POEMTEXT", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:3240e21:             { "RUTH", "V_6730_2", "poemText", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:3240e21:             { "RUTH", "V_6730_3", "POEMTEXT", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:3240e21:             { "RUTH", "V_6730_4", "poemText", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:19ca71c:             { "RUTH", "V_6730_5", "c l o b", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:19ca71c:             { "RUTH", "V_6730_6", "POEMTEXT", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:3240e21:         };
1:3240e21:         assertResults
1:3240e21:             (
1:3240e21:              conn,
1:3240e21:              "select schemaName, tableName, columnName, analyzer\n" +
1:3240e21:              "from table( lucenesupport.listIndexes() ) t\n" +
1:3240e21:              "order by schemaName, tableName, columnName\n",
1:3240e21:              expectedListResults,
1:3240e21:              false
1:3240e21:              );
1:3240e21:     }
1:3240e21: 
1:0b71ff5:     ///////////////////////////////////////////////////////////////////////////////////
1:2277df2:     //
1:d847ced:     // MINIONS
1:d847ced:     //
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:0b71ff5: 
1:d847ced:     private void    createSchema( Connection ruthConnection, int jdbcType )  throws Exception
1:d847ced:     {
1:d847ced:         createPoemsTable( ruthConnection, jdbcType );
1:2277df2:         createLocaleFunction( ruthConnection );
1:0b71ff5:     }
1:d847ced:     private void    createPoemsTable( Connection conn, int jdbcType )
1:d847ced:         throws Exception
1:d847ced:     {
1:0b71ff5:         goodStatement
1:d847ced:             (
1:0b71ff5:              conn,
1:d847ced:              "create table poems\n" +
1:d847ced:              "(\n" +
1:d847ced:              "    poemID " + getType( jdbcType ) + ",\n" +
1:d847ced:              "    versionStamp int not null,\n" +
1:d847ced:              "    originalAuthor       varchar( 50 ),\n" +
1:d847ced:              "    lastEditor           varchar( 50 ),\n" +
1:d847ced:              "    poemText            clob,\n" +
1:d847ced:              "    constraint poemsKey primary key( poemID, versionStamp )\n" +
1:d847ced:              ")\n"
1:0b71ff5:              );
1:d847ced: 
1:d847ced:         PreparedStatement   ps = conn.prepareStatement( "insert into poems values ( ?, ?, ?, ?, ? )" );
1:d847ced: 
1:d847ced:         int     poemID = 1;
1:d847ced:         int     versionStamp = 1;
1:d847ced: 
1:d847ced:         setNextPoemID( ps, jdbcType, poemID++ );
1:d847ced:         ps.setInt( 2, versionStamp++ );
1:d847ced:         ps.setString( 3, "Geoffrey Chaucer" );
1:d847ced:         ps.setString( 4, "Geoffrey Chaucer" );
1:d847ced:         ps.setString( 5, "Whan that Aprill, with his shoures soote The droghte of March hath perced to the roote And bathed every veyne in swich licour, Of which vertu engendred is the flour;" );
1:d847ced:         ps.executeUpdate();
1:d847ced: 
1:d847ced:         setNextPoemID( ps, jdbcType, poemID++ );
1:d847ced:         ps.setInt( 2, versionStamp++ );
1:d847ced:         ps.setString( 3, "Andrew Marvell" );
1:d847ced:         ps.setString( 4, "Andrew Marvell" );
1:d847ced:         ps.setString( 5, "Had we but world enough, and time, This coyness, lady, were no crime." );
1:d847ced:         ps.executeUpdate();
1:d847ced: 
1:d847ced:         setNextPoemID( ps, jdbcType, poemID++ );
1:d847ced:         ps.setInt( 2, versionStamp++ );
1:d847ced:         ps.setString( 3, "John Milton" );
1:d847ced:         ps.setString( 4, "John Milton" );
1:d847ced:         ps.setString( 5, "From morn to noon he fell, from noon to dewy eve, a summers day, and with the setting sun dropped from the ze4ith like a falling star on Lemnos, the Aegean isle" );
1:d847ced:         ps.executeUpdate();
1:d847ced: 
1:d847ced:         setNextPoemID( ps, jdbcType, poemID++ );
1:d847ced:         ps.setInt( 2, versionStamp++ );
1:d847ced:         ps.setString( 3, "Lord Byron" );
1:d847ced:         ps.setString( 4, "Lord Byron" );
1:d847ced:         ps.setString( 5, "The Assyrian came down like the wolf on the fold, And his cohorts were gleaming in purple and gold; And the sheen of their spears was like stars on the sea, When the blue wave rolls nightly on deep Galilee." );
1:d847ced:         ps.executeUpdate();
1:d847ced: 
1:d847ced:         setNextPoemID( ps, jdbcType, poemID++ );
1:d847ced:         ps.setInt( 2, versionStamp++ );
1:d847ced:         ps.setString( 3, "Walt Whitman" );
1:d847ced:         ps.setString( 4, "Walt Whitman" );
1:d847ced:         ps.setString( 5, "When lilacs last in the dooryard bloomd, And the great star early droopd in the western sky in the night, I mournd, and yet shall mourn with ever-returning spring." );
1:d847ced:         ps.executeUpdate();
1:d847ced: 
1:d847ced:         ps.close();
1:d847ced:     }
1:d847ced: 
1:fcf3e6d:     private void    createPoemView( Connection conn )
1:fcf3e6d:         throws Exception
1:fcf3e6d:     {
1:0b71ff5:         goodStatement
1:fcf3e6d:             (
1:0b71ff5:              conn,
1:fcf3e6d:              "create view poemView as select poemID, versionStamp, poemText from poems"
1:0b71ff5:              );
1:fcf3e6d:     }
1:fcf3e6d:     
1:2277df2:     private void    createLocaleFunction( Connection conn )
1:2277df2:         throws Exception
1:2277df2:     {
1:0b71ff5:         goodStatement
1:2277df2:             (
1:0b71ff5:              conn,
1:2277df2:              "create function getDatabaseLocale() returns varchar( 20 )\n" +
1:2277df2:              "language java parameter style java reads sql data\n" +
1:2277df2:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.getDatabaseLocale()'\n"
1:0b71ff5:              );
1:2277df2:     }
1:2277df2:     
1:d847ced:     private String  getType( int jdbcType ) throws Exception
1:d847ced:     {
1:d847ced:         switch( jdbcType )
1:d847ced:         {
1:d847ced:         case Types.BINARY: return "char( 100 ) for bit data";
1:d847ced:         case Types.BOOLEAN: return "boolean";
1:d847ced:         case Types.DECIMAL: return "decimal";
1:d847ced:         case Types.INTEGER: return "int";
1:d847ced:         case Types.BIGINT: return "bigint";
1:d847ced:         case Types.SMALLINT: return "smallint";
1:d847ced:         case Types.DOUBLE: return "double";
1:d847ced:         case Types.FLOAT: return "real";
1:d847ced:         case Types.NUMERIC: return "numeric";
1:d847ced:         case Types.CHAR: return "char( 5 )";
1:d847ced:         case Types.REAL: return "real";
1:d847ced:         case Types.VARCHAR: return "varchar( 5 )";
1:d847ced:         case Types.VARBINARY: return "varchar( 256 ) for bit data";
1:d847ced:         case Types.DATE: return "date";
1:d847ced:         case Types.TIME: return "time";
1:d847ced:         case Types.TIMESTAMP: return "timestamp";
1:d847ced: 
1:d847ced:         default:    throw new Exception( "Unsupported datatype: " + jdbcType );
1:d847ced:         }
1:d847ced:     }
1:d847ced: 
1:d847ced:     private void    setNextPoemID( PreparedStatement ps, int jdbcType, int intPoemID )
1:d847ced:         throws Exception
1:d847ced:     {
1:d847ced:         switch( jdbcType )
1:d847ced:         {
1:d847ced:         case Types.BINARY:
1:d847ced:             ps.setBytes( 1, makeBytes( intPoemID ) );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.BOOLEAN:
1:d847ced:             ps.setBoolean( 1, (intPoemID % 2 == 0) ? true : false );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.DECIMAL:
1:d847ced:         case Types.NUMERIC:
1:d847ced:             ps.setBigDecimal( 1, new BigDecimal( intPoemID ) );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.INTEGER:
1:d847ced:             ps.setInt( 1, intPoemID );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.BIGINT:
1:d847ced:             ps.setLong( 1, (long) intPoemID + (long) Integer.MAX_VALUE );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.SMALLINT:
1:d847ced:             ps.setShort( 1, (short) intPoemID );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.DOUBLE:
1:d847ced:             ps.setDouble( 1, (double) intPoemID );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.FLOAT:
1:d847ced:         case Types.REAL:
1:d847ced:             ps.setFloat( 1, (float) intPoemID );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.CHAR:
1:d847ced:         case Types.VARCHAR:
1:d847ced:             ps.setString( 1, makeStringKey( intPoemID ) );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.VARBINARY:
1:d847ced:             ps.setBytes( 1, makeAllBytes( intPoemID ) );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.DATE:
1:d847ced:             ps.setDate( 1, new Date( MILLIS_IN_DAY * (long)(500 + intPoemID) ) );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.TIME:
1:d847ced:             ps.setTime( 1, new Time( MILLIS_IN_HOUR * (long)(intPoemID) ) );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         case Types.TIMESTAMP:
1:d847ced:             ps.setTimestamp( 1, new Timestamp( MILLIS_IN_DAY * (long)(500 + intPoemID) ) );
1:d847ced:             break;
1:d847ced: 
1:d847ced:         default:    throw new Exception( "Unsupported datatype: " + jdbcType );
1:d847ced:         }
1:d847ced:     }
1:d847ced:     private String  makeStringKey( int key )
1:d847ced:     {
1:d847ced:         String  digit = Integer.toString( key );
1:d847ced:         return digit + digit + digit + digit + digit;
1:d847ced:     }
1:d847ced: 
1:d847ced:     private void    dropSchema( Connection ruthConnection )    throws Exception
1:d847ced:     {
1:d847ced:         goodStatement( ruthConnection, "drop table poems" );
1:2277df2:         goodStatement( ruthConnection, "drop function getDatabaseLocale" );
1:d847ced:     }
1:d847ced:     
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:d847ced:     // PROCEDURES AND FUNCTIONS
1:d847ced:     //
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced: 
1:2277df2:     /** Get the database locale */
1:2277df2:     public  static  String  getDatabaseLocale()
1:2277df2:         throws SQLException
1:2277df2:     {
1:2277df2:         return ConnectionUtil.getCurrentLCC().getDatabase().getLocale().toString();
1:2277df2:     }
1:2277df2:     
1:d847ced:     public  static  String  toString( byte[] value )
1:d847ced:     {
1:d847ced:         if ( value == null ) { return null; }
1:d847ced: 
1:d847ced:         return Arrays.toString( value );
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Make a byte array with all possible byte values in it */
1:d847ced:     public  static  byte[]  makeAllBytes( int initialValue )
1:d847ced:     {
1:d847ced:         int     size = 2 * ( -Byte.MIN_VALUE );
1:d847ced:         byte[]  result = new byte[ size ];
1:d847ced:         int     value = initialValue;
1:d847ced: 
1:d847ced:         if ( value < Byte.MIN_VALUE ) { value = Byte.MIN_VALUE; }
1:d847ced:         if ( value > Byte.MAX_VALUE ) { value = Byte.MAX_VALUE; }
1:d847ced: 
1:d847ced:         for ( int idx = 0; idx < size; idx++ )
1:d847ced:         {
1:d847ced:             result[ idx ] = (byte) (value++);
1:d847ced: 
1:d847ced:             if ( value > Byte.MAX_VALUE ) { value = Byte.MIN_VALUE; }
1:d847ced:         }
1:d847ced: 
1:d847ced:         return result;
1:d847ced:     }
1:0b71ff5:     
1:d847ced:     /** Make a byte array starting with the given byte */
1:d847ced:     public  static  byte[]  makeBytes( int initialValue )
1:d847ced:     {
1:d847ced:         byte[]  result = new byte[ initialValue ];
1:d847ced: 
1:d847ced:         for ( int idx = 0; idx < initialValue; idx++ )
1:d847ced:         {
1:d847ced:             result[ idx ] = (byte) initialValue;
1:d847ced:         }
1:d847ced: 
1:d847ced:         return result;
1:d847ced:     }
1:d847ced: 
1:0b71ff5:     /** Alternative QueryParser maker, which forces the text to be a constant string */
1:a4e6298:     public  static  LuceneIndexDescriptor constantStringIndexDescriptor()
1:0b71ff5:     {
1:a4e6298:         return new ConstantIndexDescriptor();
1:0b71ff5:     }
1:d847ced:     
1:d847ced:     /**
1:d847ced:      * Delete a file. If it's a directory, recursively delete all directories
1:d847ced:      * and files underneath it first.
1:d847ced:      */
1:d847ced:     private boolean deleteFile( File file )
1:d847ced:         throws IOException, PrivilegedActionException
1:d847ced:     {
1:d847ced:         boolean retval = true;
1:d847ced:         
1:d847ced:         if ( isDirectory( file ) )
1:d847ced:         {
1:d847ced:             for ( File child : listFiles( file ) ) { retval = retval && deleteFile( child ); }
1:d847ced:         }
1:d847ced: 
1:d847ced:         return retval && clobberFile( file );
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Return true if the file is a directory */
1:d847ced:     private boolean isDirectory( final File file )
1:d847ced:         throws IOException, PrivilegedActionException
1:d847ced:     {
1:d847ced:         return AccessController.doPrivileged
1:d847ced:             (
1:d847ced:              new PrivilegedExceptionAction<Boolean>()
1:d847ced:              {
1:d847ced:                 public Boolean run() throws IOException
1:d847ced:                 {
1:d847ced:                     if ( file == null ) { return false; }
1:d847ced:                     else { return file.isDirectory(); }
1:d847ced:                 }
1:d847ced:              }
1:d847ced:              ).booleanValue();
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** Really delete a file */
1:d847ced:     private boolean clobberFile( final File file )
1:d847ced:         throws IOException, PrivilegedActionException
1:d847ced:     {
1:d847ced:         return AccessController.doPrivileged
1:d847ced:             (
1:d847ced:              new PrivilegedExceptionAction<Boolean>()
1:d847ced:              {
1:d847ced:                 public Boolean run() throws IOException
1:d847ced:                 {
1:d847ced:                     return file.delete();
1:d847ced:                 }
1:d847ced:              }
1:d847ced:              ).booleanValue();
1:d847ced:     }
1:d847ced: 
1:d847ced:     /** List files */
1:d847ced:     private File[]  listFiles( final File file )
1:d847ced:         throws IOException, PrivilegedActionException
1:d847ced:     {
1:d847ced:         return AccessController.doPrivileged
1:d847ced:             (
1:d847ced:              new PrivilegedExceptionAction<File[]>()
1:d847ced:              {
1:d847ced:                 public File[] run() throws IOException
1:d847ced:                 {
1:d847ced:                     return file.listFiles();
1:d847ced:                 }
1:d847ced:              }
1:fcf3e6d:              );
1:d847ced:     }
1:d847ced: 
1:7e538ec:     public  static  void    setFieldNames( String... fieldNames ) { _fieldNames = fieldNames; }
1:7e538ec: 
1:7e538ec:     public  static  LuceneIndexDescriptor   makeFieldNameIndexDescriptor() { return new FieldNameIndexDescriptor(); }
1:7e538ec: 
1:d847ced:     ///////////////////////////////////////////////////////////////////////////////////
1:d847ced:     //
1:0b71ff5:     // NESTED CLASSES
1:0b71ff5:     //
1:0b71ff5:     ///////////////////////////////////////////////////////////////////////////////////
1:0b71ff5: 
1:a4e6298:     public  static  class   ConstantQueryParser extends MultiFieldQueryParser
1:0b71ff5:     {
1:0b71ff5:         public  ConstantQueryParser
1:0b71ff5:             (
1:0b71ff5:              Version version,
1:a4e6298:              String[] fieldNames,
1:0b71ff5:              Analyzer analyzer
1:0b71ff5:              )
1:0b71ff5:         {
1:a4e6298:             super( version, fieldNames, analyzer );
1:0b71ff5:         }
1:0b71ff5: 
1:0b71ff5:         public Query parse( String query )  throws ParseException
1:0b71ff5:         {
1:0b71ff5:             return super.parse( "one" );
1:0b71ff5:         }
1:0b71ff5:     }
1:0b71ff5: 
1:abb2084:     public  static  class   CD
1:abb2084:     {
1:abb2084:         public  final   String  name;
1:abb2084:         public  final   String  type;
1:abb2084: 
1:abb2084:         public  CD( String Name, String Type )
1:abb2084:         {
1:abb2084:             name = Name;
1:abb2084:             type = Type;
1:abb2084:         }
1:abb2084: 
1:abb2084:         public  String  toString() { return "[ " + name + ", " + type + " ]"; }
1:abb2084:     }
1:abb2084: 
1:a4e6298:     public  static  class   ConstantIndexDescriptor extends LuceneUtils.DefaultIndexDescriptor
1:a4e6298:     {
1:a4e6298:         public  ConstantIndexDescriptor() { super(); }
1:a4e6298:         
1:a4e6298:         public  QueryParser getQueryParser()
1:a4e6298:             throws SQLException
1:a4e6298:         {
1:a4e6298:             return new ConstantQueryParser
1:a4e6298:                 (
1:a4e6298:                  LuceneUtils.currentVersion(),
1:a4e6298:                  getFieldNames(),
1:a4e6298:                  getAnalyzer()
1:a4e6298:                  );
1:a4e6298:         }
1:a4e6298:     }
1:a4e6298: 
1:7e538ec:     public  static  class   FieldNameIndexDescriptor extends LuceneUtils.DefaultIndexDescriptor
1:7e538ec:     {
1:7e538ec:         public  FieldNameIndexDescriptor() { super(); }
1:7e538ec:         public  String[]    getFieldNames() { return LuceneSupportPermsTest._fieldNames; }
1:7e538ec:     }
1:7e538ec:     
1:d847ced: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:19ca71c
/////////////////////////////////////////////////////////////////////////
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create view v_6730_5 ( poemID, \"c l o b\" ) as select poemID, poemText from ruth.poems"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create view v_6730_6 ( \"k e y\", poemText ) as select poemID, poemText from ruth.poems"
1:              );
/////////////////////////////////////////////////////////////////////////
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.createIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_5',\n" +
1:              "  '\"c l o b\"',\n" +
1:              "  null,\n" +
1:              "  'poemID'\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.createIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_6',\n" +
1:              "  'poemText',\n" +
1:              "  null,\n" +
1:              "  '\"k e y\"'\n" +
1:              ")\n"
1:              );
/////////////////////////////////////////////////////////////////////////
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.updateIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_5',\n" +
1:              "  '\"c l o b\"',\n" +
1:              "  null\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.updateIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_6',\n" +
1:              "  'poemText',\n" +
1:              "  null\n" +
1:              ")\n"
1:              );
1:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_5', '\"c l o b\"' )" );
1:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_6', 'poemText' )" );
1:         goodStatement( ruthConnection, "drop view v_6730_6" );
1:         goodStatement( ruthConnection, "drop view v_6730_5" );
/////////////////////////////////////////////////////////////////////////
1:         assertResults
1:             (
1:              conn,
1:              "select i.poemID, i.score\n" +
1:              "from table ( ruth.\"V_6730_5__c l o b\"( 'star', 1000, null ) ) i\n" +
1:              "order by i.score desc\n",
1:             expectedResults,
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "select i.\"k e y\", i.score\n" +
1:              "from table ( ruth.v_6730_6__poemText( 'star', 1000, null ) ) i\n" +
1:              "order by i.score desc\n",
1:              expectedResults,
1:              false
1:              );
/////////////////////////////////////////////////////////////////////////
1:             { "RUTH", "V_6730_5", "c l o b", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:             { "RUTH", "V_6730_6", "POEMTEXT", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
commit:3240e21
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test identifier casing for keys and text columns. See DERBY-6730.
1:      * </p>
1:      */
1:     public  void    test_6730()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         createSchema( ruthConnection, Types.INTEGER );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create view v_6730_1 ( poemID, poemText ) as select poemID, poemText from ruth.poems"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create view v_6730_2 ( poemID, \"poemText\" ) as select poemID, poemText from ruth.poems"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create view v_6730_3 ( \"poemID\", poemText ) as select poemID, poemText from ruth.poems"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create view v_6730_4 ( \"poemID\", \"poemText\" ) as select poemID, poemText from ruth.poems"
1:              );
1: 
1:         goodStatement( dboConnection, LOAD_TOOL );
1: 
1:         // Index the views
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.createIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_1',\n" +
1:              "  'poemText',\n" +
1:              "  null,\n" +
1:              "  'poemID'\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.createIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_2',\n" +
1:              "  '\"poemText\"',\n" +
1:              "  null,\n" +
1:              "  'poemID'\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.createIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_3',\n" +
1:              "  'poemText',\n" +
1:              "  null,\n" +
1:              "  '\"poemID\"'\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.createIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_4',\n" +
1:              "  '\"poemText\"',\n" +
1:              "  null,\n" +
1:              "  '\"poemID\"'\n" +
1:              ")\n"
1:              );
1: 
1:         // Verify the expected casing of identifiers
1:         vet6730( ruthConnection );
1: 
1:         // Update the indexes and re-verify
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.updateIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_1',\n" +
1:              "  'poemText',\n" +
1:              "  null\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.updateIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_2',\n" +
1:              "  '\"poemText\"',\n" +
1:              "  null\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.updateIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_3',\n" +
1:              "  'poemText',\n" +
1:              "  null\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call luceneSupport.updateIndex\n" +
1:              "(\n" +
1:              "  'ruth',\n" +
1:              "  'v_6730_4',\n" +
1:              "  '\"poemText\"',\n" +
1:              "  null\n" +
1:              ")\n"
1:              );
1:         vet6730( ruthConnection );
1: 
1:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_1', 'poemText' )" );
1:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_2', '\"poemText\"' )" );
1:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_3', 'poemText' )" );
1:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'v_6730_4', '\"poemText\"' )" );
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         goodStatement( ruthConnection, "drop view v_6730_4" );
1:         goodStatement( ruthConnection, "drop view v_6730_3" );
1:         goodStatement( ruthConnection, "drop view v_6730_2" );
1:         goodStatement( ruthConnection, "drop view v_6730_1" );
1:         dropSchema( ruthConnection );
1:     }
1:     private void vet6730( Connection conn ) throws Exception
1:     {
1:         // Verify the expected casing of identifiers
1:         String[][]  expectedResults = new String[][]
1:         {
1:             { "5", "0.26756266" },
1:             { "4", "0.22933942" },
1:             { "3", "0.22933942" },
1:         };
1:         assertResults
1:             (
1:              conn,
1:              "select i.poemID, i.score\n" +
1:              "from table ( ruth.v_6730_1__poemText( 'star', 1000, null ) ) i\n" +
1:              "order by i.score desc\n",
1:              expectedResults,
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "select i.poemID, i.score\n" +
1:              "from table ( ruth.\"V_6730_2__poemText\"( 'star', 1000, null ) ) i\n" +
1:              "order by i.score desc\n",
1:              expectedResults,
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "select i.\"poemID\", i.score\n" +
1:              "from table ( ruth.v_6730_3__poemText( 'star', 1000, null ) ) i\n" +
1:              "order by i.score desc\n",
1:              expectedResults,
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "select i.\"poemID\", i.score\n" +
1:              "from table ( ruth.\"V_6730_4__poemText\"( 'star', 1000, null ) ) i\n" +
1:              "order by i.score desc\n",
1:              expectedResults,
1:              false
1:              );
1:         
1:         String[][]  expectedListResults = new String[][]
1:         {
1:             { "RUTH", "V_6730_1", "POEMTEXT", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:             { "RUTH", "V_6730_2", "poemText", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:             { "RUTH", "V_6730_3", "POEMTEXT", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:             { "RUTH", "V_6730_4", "poemText", "org.apache.lucene.analysis.en.EnglishAnalyzer" },
1:         };
1:         assertResults
1:             (
1:              conn,
1:              "select schemaName, tableName, columnName, analyzer\n" +
1:              "from table( lucenesupport.listIndexes() ) t\n" +
1:              "order by schemaName, tableName, columnName\n",
1:              expectedListResults,
1:              false
1:              );
1:     }
1: 
commit:7e538ec
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      BAD_FIELD_NAME = "42XBN";
1:     private static  final   String      DUPLICATE_FIELD_NAME = "42XBO";
/////////////////////////////////////////////////////////////////////////
1:     static  String[]    _fieldNames;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Test restrictions on field names.
1:      * </p>
1:      */
1:     public  void    test_011_fieldNames()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         loadTestTable( ruthConnection );
1:         goodStatement( dboConnection, LOAD_TOOL );
1: 
1:         String  indexTestTable =
1:             "call LuceneSupport.createIndex\n" +
1:             "(\n" +
1:             "    'ruth', 'textTable', 'textCol',\n" +
1:             "    'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.makeFieldNameIndexDescriptor'\n" +
1:             ")\n";
1:         
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create procedure setFieldNames( fieldName varchar( 32672 )... )\n" +
1:              "language java parameter style derby no sql\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.setFieldNames'\n"
1:              );
1: 
1:         // Field and key name conflict.
1:         goodStatement( ruthConnection, "call setFieldNames( 'KEYCOL' )" );
1:         expectExecutionError( ruthConnection, BAD_FIELD_NAME, indexTestTable );
1: 
1:         // Duplicate field names.
1:         goodStatement( ruthConnection, "call setFieldNames( 'FOO', 'FOO' )" );
1:         expectExecutionError( ruthConnection, DUPLICATE_FIELD_NAME, indexTestTable );
1: 
1:         // Null field name.
1:         goodStatement( ruthConnection, "call setFieldNames( 'FOO', null )" );
1:         expectExecutionError( ruthConnection, DUPLICATE_FIELD_NAME, indexTestTable );
1:         goodStatement( ruthConnection, "call setFieldNames( null, 'FOO' )" );
1:         expectExecutionError( ruthConnection, DUPLICATE_FIELD_NAME, indexTestTable );
1: 
1:         goodStatement( ruthConnection, "drop procedure setFieldNames" );
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         unloadTestTable( ruthConnection );
1:     }
1: 
1:    /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:     public  static  void    setFieldNames( String... fieldNames ) { _fieldNames = fieldNames; }
1: 
1:     public  static  LuceneIndexDescriptor   makeFieldNameIndexDescriptor() { return new FieldNameIndexDescriptor(); }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public  static  class   FieldNameIndexDescriptor extends LuceneUtils.DefaultIndexDescriptor
1:     {
1:         public  FieldNameIndexDescriptor() { super(); }
1:         public  String[]    getFieldNames() { return LuceneSupportPermsTest._fieldNames; }
1:     }
1:     
commit:a4e6298
/////////////////////////////////////////////////////////////////////////
1: import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.optional.api.LuceneIndexDescriptor;
1: import org.apache.derby.optional.api.LuceneUtils;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      DEFAULT_INDEX_DESCRIPTOR = "org.apache.derby.optional.api.LuceneUtils.defaultIndexDescriptor";
1:     private static  final   String      CONSTANT_QUERY_PARSER = "org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.constantStringIndexDescriptor";
1:     
/////////////////////////////////////////////////////////////////////////
1:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 1000, null ) ) luceneResults order by poemID";
/////////////////////////////////////////////////////////////////////////
1:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 1000, null ) ) luceneResults order by poemid";
/////////////////////////////////////////////////////////////////////////
1:              "from ruth.poems p, table ( ruth.poems__poemText( 'star', 1000, null ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
1:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 100, null ) ) t"
/////////////////////////////////////////////////////////////////////////
1:             "from ruth.poems p, table ( ruth.poems__poemText( 'star', 1000, null ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
1:               "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText', '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
/////////////////////////////////////////////////////////////////////////
1:              "select schemaName, tableName, columnName, luceneVersion, analyzer, indexDescriptorMaker\n" +
/////////////////////////////////////////////////////////////////////////
1:                      DEFAULT_INDEX_DESCRIPTOR
1:                      LuceneCoarseAuthorizationTest.STANDARD_ANALYZER
/////////////////////////////////////////////////////////////////////////
1:             "from ruth.poems p, table ( ruth.poemView__poemText( 'star', 1000, null ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
1:             "select schemaName, tableName, columnName, indexDescriptorMaker\n" +
/////////////////////////////////////////////////////////////////////////
1:                      DEFAULT_INDEX_DESCRIPTOR
1:                      DEFAULT_INDEX_DESCRIPTOR
/////////////////////////////////////////////////////////////////////////
1:              "call LuceneSupport.updateIndex( 'ruth', 'poemView', 'poemText', '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )"
/////////////////////////////////////////////////////////////////////////
1:                      DEFAULT_INDEX_DESCRIPTOR
1:                      LuceneCoarseAuthorizationTest.STANDARD_ANALYZER
/////////////////////////////////////////////////////////////////////////
1:                      DEFAULT_INDEX_DESCRIPTOR
/////////////////////////////////////////////////////////////////////////
1:              "from table ( ruth.poems__poemText( 'star', 1000, null ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
1:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 100, null ) ) t",
/////////////////////////////////////////////////////////////////////////
1:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 3, null ) ) t",
/////////////////////////////////////////////////////////////////////////
1:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 4, 1.0 ) ) t",
/////////////////////////////////////////////////////////////////////////
1:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 100, 0.2 ) ) t",
/////////////////////////////////////////////////////////////////////////
1:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'textTable', 'textCol' )" );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call LuceneSupport.createIndex( 'ruth', 'textTable', 'textCol', '" + CONSTANT_QUERY_PARSER + "' )"
1:              );
1:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 100, null ) ) t",
/////////////////////////////////////////////////////////////////////////
1:              "( 'TEST_DBO', 't_6602', 'textcol', '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "', ? )"
/////////////////////////////////////////////////////////////////////////
1:              "select * from table( t_6602__textcol( 'abc or def', 3, null ) ) tc order by documentid",
/////////////////////////////////////////////////////////////////////////
1:               "call lucenesupport.createindex( null, 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:               "call lucenesupport.createindex( 'TEST_DBO', null, 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', null,  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "', null )" );
1:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "', 'x', null )" );
1:         goodStatement( dboConnection, "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:              "select * from table( t_6596__c( 'abc or def', 3, null ) ) tc order by documentid",
/////////////////////////////////////////////////////////////////////////
1:         goodStatement( dboConnection, "call lucenesupport.updateindex( 'TEST_DBO', 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:               "call lucenesupport.updateindex( null, 't_6596', 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:               "call lucenesupport.updateindex( 'TEST_DBO', null, 'c',  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:               "call lucenesupport.updateindex( 'TEST_DBO', 't_6596', null,  '" + LuceneCoarseAuthorizationTest.STANDARD_ANALYZER + "' )" );
1:               "select * from table( t_6596__c( null, 3, null ) ) tc order by documentid" );
1:               "select * from table( t_6596__c( 'abc or def', null, null ) ) tc order by documentid" );
/////////////////////////////////////////////////////////////////////////
1:     public  static  LuceneIndexDescriptor constantStringIndexDescriptor()
1:         return new ConstantIndexDescriptor();
/////////////////////////////////////////////////////////////////////////
1:     public  static  class   ConstantQueryParser extends MultiFieldQueryParser
1:              String[] fieldNames,
1:             super( version, fieldNames, analyzer );
/////////////////////////////////////////////////////////////////////////
1:     public  static  class   ConstantIndexDescriptor extends LuceneUtils.DefaultIndexDescriptor
1:     {
1:         public  ConstantIndexDescriptor() { super(); }
1:         
1:         public  QueryParser getQueryParser()
1:             throws SQLException
1:         {
1:             return new ConstantQueryParser
1:                 (
1:                  LuceneUtils.currentVersion(),
1:                  getFieldNames(),
1:                  getAnalyzer()
1:                  );
1:         }
1:     }
1: 
commit:4f7c143
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      ILLEGAL_NULL_ARG = "42XBM";
1:     private static  final   String      NULL_PRIMITIVE_ARG = "39004";
/////////////////////////////////////////////////////////////////////////
1:    /**
1:      * <p>
1:      * Test that nulls are not allowed as the values of certain arguments. See DERBY-6596.
1:      * </p>
1:      */
1:     public  void    test_6596_null_args()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         goodStatement( dboConnection, "create table t_6596( x int primary key, c clob )" );
1:         goodStatement( dboConnection, "insert into t_6596 values ( 1, 'abc' ), ( 2, 'def' )" );
1: 
1:         // create index errors
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "call lucenesupport.createindex( null, 't_6596', 'c', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "call lucenesupport.createindex( 'TEST_DBO', null, 'c', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', null, 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer', null )" );
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer', 'x', null )" );
1: 
0:         goodStatement( dboConnection, "call lucenesupport.createindex( 'TEST_DBO', 't_6596', 'c', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
1:         assertResults
1:             (
1:              dboConnection,
0:              "select * from table( t_6596__c( 'abc or def', null, 3, null ) ) tc order by documentid",
1:              new String[][]
1:              {
1:                  { "1", "0", "0.35355338" },
1:                  { "2", "1", "0.35355338" },
1:              },
1:              false
1:              );
0:         goodStatement( dboConnection, "call lucenesupport.updateindex( 'TEST_DBO', 't_6596', 'c', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
1:         
1:         // update index errors
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "call lucenesupport.updateindex( null, 't_6596', 'c', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "call lucenesupport.updateindex( 'TEST_DBO', null, 'c', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "call lucenesupport.updateindex( 'TEST_DBO', 't_6596', null, 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
1: 
1:         // query errors
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
0:               "select * from table( t_6596__c( null, null, 3, null ) ) tc order by documentid" );
1:         expectExecutionError
1:             ( dboConnection, NULL_PRIMITIVE_ARG,
0:               "select * from table( t_6596__c( 'abc or def', null, null, null ) ) tc order by documentid" );
1: 
1:         // drop index errors
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
1:               "call lucenesupport.dropindex( null, 't_6596', 'c' )" );
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
1:               "call lucenesupport.dropindex( 'TEST_DBO', null, 'c' )" );
1:         expectExecutionError
1:             ( dboConnection, ILLEGAL_NULL_ARG,
1:               "call lucenesupport.dropindex( 'TEST_DBO', 't_6596', null )" );
1: 
1:         goodStatement( dboConnection, "call lucenesupport.dropindex( 'TEST_DBO', 't_6596', 'c' )" );
1:         goodStatement( dboConnection, "drop table t_6596" );
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:     }
1:     
commit:abb2084
/////////////////////////////////////////////////////////////////////////
1:    /**
1:      * <p>
1:      * Test that nulls are allowed in keys. See DERBY-6602.
1:      * </p>
1:      */
1:     public  void    test_6602()
1:         throws Exception
1:     {
1:         CD[]    columnDescriptors = new CD[]
1:         {
1:             new CD( "bigintCol", "bigint" ),
1:             new CD( "blobCol", "blob" ),
1:             new CD( "booleanCol", "boolean" ),
1:             new CD( "charCol", "char( 10 )" ),
1:             new CD( "clobCol", "clob" ),
1:             new CD( "dataCol", "date" ),
1:             new CD( "decimalCol", "decimal" ),
1:             new CD( "doubleCol", "double" ),
1:             new CD( "floatCol", "float" ),
1:             new CD( "intCol", "int" ),
1:             new CD( "longvarcharCol", "long varchar" ),
1:             new CD( "longvarcharforbitdataCol", "long varchar for bit data" ),
1:             new CD( "numericCol", "numeric" ),
1:             new CD( "realCol", "real" ),
1:             new CD( "smallintCol", "smallint" ),
1:             new CD( "timeCol", "time" ),
1:             new CD( "varcharCol", "varchar( 10 )" ),
1:             new CD( "varcharforbitdataCol", "varchar( 10 ) for bit data" ),
1:         };
1: 
1:         StringBuilder   buffer = new StringBuilder();
1:         buffer.append( "create table t_6602\n(\ttextcol clob" );
1:         for ( CD cd : columnDescriptors )
1:         {
1:             buffer.append( ",\n\t" + cd.name + " " + cd.type );
1:         }
1:         buffer.append( "\n)" );
1:         
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         goodStatement( dboConnection, buffer.toString() );
1:         goodStatement( dboConnection, "insert into t_6602( textcol ) values ( 'abc'), ( 'def')" );
1: 
1:         for ( CD cd : columnDescriptors )
1:         {
1:             vet6602( dboConnection, cd );
1:         }
1: 
1:         goodStatement( dboConnection, "drop table t_6602" );
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:     }
1:     private void    vet6602( Connection conn, CD cd )   throws Exception
1:     {
1:         PreparedStatement   ps = chattyPrepare
1:             (
1:              conn,
1:              "call lucenesupport.createindex\n" +
0:              "( 'TEST_DBO', 't_6602', 'textcol', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer', ? )\n"
1:              );
1:         ps.setString( 1, cd.name );
1:         ps.execute();
1: 
1:         assertResults
1:             (
1:              conn,
0:              "select * from table( t_6602__textcol( 'abc or def', null, 3, null ) ) tc order by documentid",
1:              new String[][]
1:              {
1:                  { null, "0", "0.35355338" },
1:                  { null, "1", "0.35355338" },
1:              },
1:              false
1:              );
1: 
1:         goodStatement( conn, "call lucenesupport.dropIndex( 'TEST_DBO', 't_6602', 'textcol' )" );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     public  static  class   CD
1:     {
1:         public  final   String  name;
1:         public  final   String  type;
1: 
1:         public  CD( String Name, String Type )
1:         {
1:             name = Name;
1:             type = Type;
1:         }
1: 
1:         public  String  toString() { return "[ " + name + ", " + type + " ]"; }
1:     }
1: 
commit:a409436
/////////////////////////////////////////////////////////////////////////
1:     static  void    loadTestTable( Connection conn ) throws Exception
1:         conn.prepareStatement
1:              ).execute();
1:         conn.prepareStatement
/////////////////////////////////////////////////////////////////////////
1:              ).execute();
1:     static  void    unloadTestTable( Connection conn ) throws Exception
1:         conn.prepareStatement
1:              ).execute();
commit:4cedf31
/////////////////////////////////////////////////////////////////////////
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', null, 1000, null ) ) luceneResults order by poemID";
/////////////////////////////////////////////////////////////////////////
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', null, 1000, null ) ) luceneResults order by poemid";
/////////////////////////////////////////////////////////////////////////
0:              "from ruth.poems p, table ( ruth.poems__poemText( 'star', null, 1000, null ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', null, 100, null ) ) t"
/////////////////////////////////////////////////////////////////////////
0:             "from ruth.poems p, table ( ruth.poems__poemText( 'star', null, 1000, null ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:             "from ruth.poems p, table ( ruth.poemView__poemText( 'star', null, 1000, null ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:              "from table ( ruth.poems__poemText( 'star', null, 1000, null ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', null, 100, null ) ) t",
/////////////////////////////////////////////////////////////////////////
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', null, 3, null ) ) t",
/////////////////////////////////////////////////////////////////////////
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.constantStringQueryParser', 100, null ) ) t",
commit:5658bae
/////////////////////////////////////////////////////////////////////////
1:     private static  String              LUCENE_VERSION = "LUCENE_47";
commit:502ed2e
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      INCOMPATIBLE_ENCRYPTION = "42XBL";
/////////////////////////////////////////////////////////////////////////
1:    /**
1:      * <p>
1:      * Test that encryption and the Lucene plugin are incompatible.
1:      * </p>
1:      */
1:     public  void    test_010_encryption()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         String      password = getTestConfiguration().getPassword( TEST_DBO );
1:         String      encryptDatabaseURL = "jdbc:derby:" + DB_NAME + ";user=" + TEST_DBO + ";password=" + password +
1:                 ";dataEncryption=true;bootPassword=tryToGuessThis";
1:         String      decryptDatabaseURL = "jdbc:derby:" + DB_NAME + ";user=" + TEST_DBO + ";password=" + password +
1:                 ";decryptDatabase=true;bootPassword=tryToGuessThis";
1: 
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         getTestConfiguration().shutdownDatabase();
1: 
1:         // verify that you can't encrypt the database now
1:         try {
1:             DriverManager.getConnection( encryptDatabaseURL );
1:             fail( "Should not have been able to get a connection!" );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( INCOMPATIBLE_ENCRYPTION, se );
1:         }
1: 
1:         // now unload the tool and encrypt the database
1:         dboConnection = openUserConnection( TEST_DBO );
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         getTestConfiguration().shutdownDatabase();
1:         dboConnection = DriverManager.getConnection( encryptDatabaseURL );
1: 
1:         // now you can't load the plugin
1:         expectExecutionError( dboConnection, INCOMPATIBLE_ENCRYPTION, LOAD_TOOL );
1: 
1:         // turn off encryption
1:         getTestConfiguration().shutdownDatabase();
1:         dboConnection = DriverManager.getConnection( decryptDatabaseURL );
1:     }
1:     
commit:5cf7a46
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      NONEXISTENT_TABLE_FUNCTION  ="42ZB4";
/////////////////////////////////////////////////////////////////////////
1:         // but that doesn't stop you from deleting the index
1:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:         expectCompilationError
1:             (
1:              ruthConnection, NONEXISTENT_TABLE_FUNCTION,
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', null, 100, 0 ) ) t"
1:              );
commit:435459e
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      DB_NAME = "lucenesupportpermsdb";
1: 
/////////////////////////////////////////////////////////////////////////
0:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecoratorSingleUse( authenticatedTest, DB_NAME, false );
0:     protected void tearDown()
1:         throws Exception
1:     {
0:         TestConfiguration.getCurrent().shutdownEngine();
0:         super.tearDown();
1:     }
1: 
commit:561e69f
/////////////////////////////////////////////////////////////////////////
1:         Test        secureTest = new SecurityManagerSetup( suite, POLICY_FILE );
1:         Test        localizedTest = new LocaleTestSetup( authorizedTest, new Locale( LANGUAGE, COUNTRY ) );
1:         return localizedTest;
commit:7d889ca
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      LUCENE_VERSION_PROPERTY = "derby.tests.lucene.version";
0:     private static  String              LUCENE_VERSION = "LUCENE_45";
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         String      luceneVersion = getSystemProperty( LUCENE_VERSION_PROPERTY );
1:         if ( luceneVersion != null ) { LUCENE_VERSION = luceneVersion; }
1:         
commit:0b71ff5
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.lucene.analysis.Analyzer;
1: import org.apache.lucene.queryparser.classic.ParseException;
1: import org.apache.lucene.queryparser.classic.QueryParser;
1: import org.apache.lucene.search.Query;
1: import org.apache.lucene.util.Version;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', null, 1000, 0 ) ) luceneResults order by poemID";
/////////////////////////////////////////////////////////////////////////
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', null, 1000, 0 ) ) luceneResults order by poemid";
/////////////////////////////////////////////////////////////////////////
0:              "from ruth.poems p, table ( ruth.poems__poemText( 'star', null, 1000, 0 ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:             "from ruth.poems p, table ( ruth.poems__poemText( 'star', null, 1000, 0 ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:             "from ruth.poems p, table ( ruth.poemView__poemText( 'star', null, 1000, 0 ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:              "from table ( ruth.poems__poemText( 'star', null, 1000, 0 ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
1:    /**
1:      * <p>
1:      * Test changes to the arguments to the searching table function.
1:      * </p>
1:      */
1:     public  void    test_009_searchArgs()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         loadTestTable( ruthConnection );
1:         
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         goodStatement( ruthConnection, "call LuceneSupport.createIndex( 'ruth', 'textTable', 'textCol', null )" );
1: 
1:         // get all the matches
1:         assertResults
1:             (
1:              ruthConnection,
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', null, 100, 0 ) ) t",
1:              new String[][]
1:              {
1:                  { "10", "9", "2.2791052" },
1:                  { "9", "8", "1.6305782" },
1:                  { "8", "7", "1.1616905" },
1:                  { "7", "6", "0.97469425" },
1:                  { "6", "5", "0.6597747" },
1:                  { "5", "4", "0.49575216" },
1:                  { "4", "3", "0.33803377" },
1:                  { "3", "2", "0.17799875" },
1:                  { "2", "1", "0.09289266" },
1:                  { "1", "0", "0.035006654" },
1:              },
1:              false
1:              );
1:         
1:         // get an initial 3-row window of the top results
1:         assertResults
1:             (
1:              ruthConnection,
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', null, 3, 0 ) ) t",
1:              new String[][]
1:              {
1:                  { "10", "9", "2.2791052" },
1:                  { "9", "8", "1.6305782" },
1:                  { "8", "7", "1.1616905" },
1:              },
1:              false
1:              );
1:         
1:         // get the next 4-row window of results
1:         assertResults
1:             (
1:              ruthConnection,
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', null, 4, 1.0 ) ) t",
1:              new String[][]
1:              {
1:                  { "7", "6", "0.97469425" },
1:                  { "6", "5", "0.6597747" },
1:                  { "5", "4", "0.49575216" },
1:                  { "4", "3", "0.33803377" },
1:              },
1:              false
1:              );
1: 
1:         // get the final window of results
1:         assertResults
1:             (
1:              ruthConnection,
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', null, 100, 0.2 ) ) t",
1:              new String[][]
1:              {
1:                  { "3", "2", "0.17799875" },
1:                  { "2", "1", "0.09289266" },
1:                  { "1", "0", "0.035006654" },
1:              },
1:              false
1:              );
1:         
1:         // try a different query parser
1:         assertResults
1:             (
1:              ruthConnection,
0:              "select * from table( ruth.textTable__textCol( 'one two three four five six seven eight nine ten', 'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.constantStringQueryParser', 100, 0 ) ) t",
1:              new String[][]
1:              {
1:                  { "1", "0", "1.597837" },
1:                  { "2", "1", "0.9986481" },
1:                  { "3", "2", "0.7989185" },
1:                  { "4", "3", "0.7989185" },
1:                  { "5", "4", "0.69905365" },
1:                  { "6", "5", "0.59918886" },
1:                  { "7", "6", "0.59918886" },
1:                  { "8", "7", "0.49932405" },
1:                  { "9", "8", "0.49932405" },
1:                  { "10", "9", "0.49932405" },
1:              },
1:              false
1:              );
1:         
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         unloadTestTable( ruthConnection );
1:     }
0:     private void    loadTestTable( Connection conn ) throws Exception
1:     {
1:         goodStatement
1:             (
1:              conn,
1:              "create table textTable( keyCol int primary key, textCol clob )"
1:              );
1:         goodStatement
1:             (
1:              conn,
1:              "insert into textTable values\n" +
1:              "( 1, 'one' ),\n" +
1:              "( 2, 'one two' ),\n" +
1:              "( 3, 'one two three' ),\n" +
1:              "( 4, 'one two three four' ),\n" +
1:              "( 5, 'one two three four five' ),\n" +
1:              "( 6, 'one two three four five six' ),\n" +
1:              "( 7, 'one two three four five six seven' ),\n" +
1:              "( 8, 'one two three four five six seven eight' ),\n" +
1:              "( 9, 'one two three four five six seven eight nine' ),\n" +
1:              "( 10, 'one two three four five six seven eight nine ten' ),\n" +
1:              "( 101, 'bricks' ),\n" +
1:              "( 102, 'bricks and mortar' ),\n" +
1:              "( 103, 'bricks and mortar, tea' ),\n" +
1:              "( 104, 'bricks and mortar, tea, tears' ),\n" +
1:              "( 105, 'bricks and mortar, tea, tears, turtle' ),\n" +
1:              "( 106, 'bricks and mortar, tea, tears, turtle, soup' ),\n" +
1:              "( 107, 'bricks and mortar, tea, tears, turtle, soup, when in the course' ),\n" +
1:              "( 108, 'bricks and mortar, tea, tears, turtle, soup, when in the course of human events' ),\n" +
1:              "( 109, 'bricks and mortar, tea, tears, turtle, soup, when in the course of human events you want' ),\n" +
1:              "( 110, 'bricks and mortar, tea, tears, turtle, soup, when in the course of human events you want better cell coverage' )\n"
1:              );
1:     }
0:     private void    unloadTestTable( Connection conn ) throws Exception
1:     {
1:         goodStatement
1:             (
1:              conn,
1:              "drop table textTable"
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Alternative QueryParser maker, which forces the text to be a constant string */
0:     public  static  QueryParser constantStringQueryParser
1:         (
1:          Version version,
0:          String fieldName,
1:          Analyzer analyzer
1:          )
1:     {
0:         return new ConstantQueryParser( version, fieldName, analyzer );
1:     }
/////////////////////////////////////////////////////////////////////////
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // NESTED CLASSES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
0:     public  static  class   ConstantQueryParser extends QueryParser
1:     {
1:         public  ConstantQueryParser
1:             (
0:              Version version,
0:              String fieldName,
0:              Analyzer analyzer
1:              )
1:         {
0:             super( version, fieldName, analyzer );
1:         }
1: 
1:         public Query parse( String query )  throws ParseException
1:         {
1:             return super.parse( "one" );
1:         }
1:     }
1: 
commit:9cc25e2
/////////////////////////////////////////////////////////////////////////
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 1000, 0 ) ) luceneResults order by poemID";
/////////////////////////////////////////////////////////////////////////
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 1000, 0 ) ) luceneResults order by poemid";
/////////////////////////////////////////////////////////////////////////
0:              "from ruth.poems p, table ( ruth.poems__poemText( 'star', 1000, 0 ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:             "from ruth.poems p, table ( ruth.poems__poemText( 'star', 1000, 0 ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:             "from ruth.poems p, table ( ruth.poemView__poemText( 'star', 1000, 0 ) ) i\n" +
/////////////////////////////////////////////////////////////////////////
0:              "from table ( ruth.poems__poemText( 'star', 1000, 0 ) ) i\n" +
commit:cbdf827
/////////////////////////////////////////////////////////////////////////
1: 	private static  final   String      BAD_COLUMN_NAME                 = "42XBJ";
/////////////////////////////////////////////////////////////////////////
1:              "select p.originalAuthor, i.score\n" +
1:              "order by i.score desc\n",
/////////////////////////////////////////////////////////////////////////
1:             "select p.originalAuthor, i.score\n" +
1:             "order by i.score desc\n";
/////////////////////////////////////////////////////////////////////////
1:             "select p.originalAuthor, i.score\n" +
1:             "order by i.score desc\n";
/////////////////////////////////////////////////////////////////////////
1:              "order by i.score desc\n",
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test that you can't create an index involving a column with the same name
1:      * as one of the system-supplied column names (documentID and score).
1:      * </p>
1:      */
1:     public  void    test_008_columnNames()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1:         goodStatement( dboConnection, LOAD_TOOL );
1: 
1:         goodStatement( ruthConnection, "create table badTable1( keyCol int primary key, score clob )" );
1:         goodStatement( ruthConnection, "create table badTable2( keyCol int primary key, documentID clob )" );
1:         goodStatement( ruthConnection, "create table badTable3( score int primary key, textCol clob )" );
1:         goodStatement( ruthConnection, "create table badTable4( documentID int primary key, textCol clob )" );
1: 
1:         expectExecutionError
1:             (
1:              ruthConnection, BAD_COLUMN_NAME,
1:              "call LuceneSupport.createIndex( 'ruth', 'badTable1', 'score', null )"
1:              );
1:         expectExecutionError
1:             (
1:              ruthConnection, BAD_COLUMN_NAME,
1:              "call LuceneSupport.createIndex( 'ruth', 'badTable2', 'documentID', null )"
1:              );
1:         expectExecutionError
1:             (
1:              ruthConnection, BAD_COLUMN_NAME,
1:              "call LuceneSupport.createIndex( 'ruth', 'badTable3', 'textCol', null )"
1:              );
1:         expectExecutionError
1:             (
1:              ruthConnection, BAD_COLUMN_NAME,
1:              "call LuceneSupport.createIndex( 'ruth', 'badTable4', 'textCol', null )"
1:              );
1: 
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         goodStatement( ruthConnection, "drop table badTable1" );
1:         goodStatement( ruthConnection, "drop table badTable2" );
1:         goodStatement( ruthConnection, "drop table badTable3" );
1:         goodStatement( ruthConnection, "drop table badTable4" );
1:     }
1:     
commit:fcf3e6d
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      DROP_PRIMARY_KEY = "alter table poems drop constraint poemsKey";
/////////////////////////////////////////////////////////////////////////
1:         // dropping the key does NOT prevent you from re-indexing
1:         goodStatement( ruthConnection, DROP_PRIMARY_KEY );
1:         goodStatement( ruthConnection, UPDATE_POEMS_INDEX );
1: 
1:         // but dropping a key column DOES prevent you from re-indexing and from selecting
1:         goodStatement( ruthConnection, "alter table poems drop column versionStamp" );
1:         expectExecutionError( ruthConnection, COLUMN_OUT_OF_SCOPE, UPDATE_POEMS_INDEX );
1:         expectExecutionError( ruthConnection, COLUMN_OUT_OF_SCOPE, viewPoemsIndex );
/////////////////////////////////////////////////////////////////////////
1:         // verify that a primary key is necessary in order to index a table
1:         dropSchema( ruthConnection );
1:         createSchema( ruthConnection, Types.INTEGER );
1:         goodStatement( ruthConnection, DROP_PRIMARY_KEY );
1:         expectExecutionError( ruthConnection, NO_PRIMARY_KEY, INDEX_POEMS );
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test that you can index views and index tables with alternative column lists.
1:      * </p>
1:      */
1:     public  void    test_007_indexViews()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         createSchema( ruthConnection, Types.INTEGER );
1:         createPoemView( ruthConnection );
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         goodStatement( ruthConnection, INDEX_POEMS );
1: 
1:         // must supply some key columns if you're going to index a view
1:         expectExecutionError
1:             (
1:              ruthConnection,
1:              NO_PRIMARY_KEY,
1:              "call LuceneSupport.createIndex( 'ruth', 'poemView', 'poemText', null )"
1:              );
1: 
1:         // now index the view
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call LuceneSupport.createIndex( 'ruth', 'poemView', 'poemText', null, 'poemID', 'versionStamp' )"
1:              );
1: 
1:         // can't create a second index by the same name
1:         expectExecutionError
1:             (
1:              ruthConnection,
1:              FUNCTION_EXISTS,
1:              "call LuceneSupport.createIndex( 'ruth', 'poemView', 'poemText', null, 'poemID' )"
1:              );
1: 
1:         // vet index contents
1:         String  selectFromViewIndex =
0:             "select p.originalAuthor, i.rank\n" +
0:             "from ruth.poems p, table ( ruth.poemView__poemText( 'star', 0 ) ) i\n" +
1:             "where p.poemID = i.poemID and p.versionStamp = i.versionStamp\n" +
0:             "order by i.rank desc\n";
1:         assertResults
1:             (
1:              ruthConnection,
1:              selectFromViewIndex,
1:              new String[][]
1:              {
1:                  { "Walt Whitman", "0.26756266" },
1:                  { "Lord Byron", "0.22933942" },
1:                  { "John Milton", "0.22933942" },
1:              },
1:              false
1:              );
1: 
1:         // vet index list
1:         String  selectIndexes =
0:             "select schemaName, tableName, columnName, analyzerMaker\n" +
1:             "from table( LuceneSupport.listIndexes() ) l\n" +
1:             "order by schemaName, tableName, columnName\n";
1:         assertResults
1:             (
1:              ruthConnection,
1:              selectIndexes,
1:              new String[][]
1:              {
1:                  {
1:                      "RUTH", "POEMS", "POEMTEXT",
0:                      "org.apache.derby.optional.api.LuceneUtils.defaultAnalyzer",
1:                  },
1:                  {
1:                      "RUTH", "POEMVIEW", "POEMTEXT",
0:                      "org.apache.derby.optional.api.LuceneUtils.defaultAnalyzer",
1:                  },
1:              },
1:              false
1:              );
1: 
1:         // update the view index, changing its analyzer
1:         goodStatement
1:             (
1:              ruthConnection,
0:              "call LuceneSupport.updateIndex( 'ruth', 'poemView', 'poemText', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )"
1:              );
1:         assertResults
1:             (
1:              ruthConnection,
1:              selectFromViewIndex,
1:              new String[][]
1:              {
1:                  { "Walt Whitman", "0.3304931" },
1:                  { "John Milton", "0.2832798" },
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              ruthConnection,
1:              selectIndexes,
1:              new String[][]
1:              {
1:                  {
1:                      "RUTH", "POEMS", "POEMTEXT",
0:                      "org.apache.derby.optional.api.LuceneUtils.defaultAnalyzer",
1:                  },
1:                  {
1:                      "RUTH", "POEMVIEW", "POEMTEXT",
0:                      "org.apache.derby.optional.api.LuceneUtils.standardAnalyzer",
1:                  },
1:              },
1:              false
1:              );
1: 
1:         // drop the index on the view
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call LuceneSupport.dropIndex( 'ruth', 'poemView', 'poemText' )"
1:              );
1:         assertResults
1:             (
1:              ruthConnection,
1:              selectIndexes,
1:              new String[][]
1:              {
1:                  {
1:                      "RUTH", "POEMS", "POEMTEXT",
0:                      "org.apache.derby.optional.api.LuceneUtils.defaultAnalyzer",
1:                  },
1:              },
1:              false
1:              );
1: 
1:         // now drop the index on the table and create one with just one key column
1:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "call LuceneSupport.createIndex( 'ruth', 'poems', 'poemText', null, 'poemID' )"
1:              );
1:         assertResults
1:             (
1:              ruthConnection,
1:              "select *\n" +
0:              "from table ( ruth.poems__poemText( 'star', 0 ) ) i\n" +
0:              "order by i.rank desc\n",
1:              new String[][]
1:              {
1:                  { "5", "4", "0.26756266" },
1:                  { "4", "3", "0.22933942" },
1:                  { "3", "2", "0.22933942" },
1:              },
1:              false
1:              );
1:         
1:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         goodStatement( ruthConnection, "drop view poemView" );
1:         dropSchema( ruthConnection );
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void    createPoemView( Connection conn )
1:         throws Exception
1:     {
1:         goodStatement
1:             (
0:              conn,
1:              "create view poemView as select poemID, versionStamp, poemText from poems"
1:              );
1:     }
1:     
commit:fbf176c
/////////////////////////////////////////////////////////////////////////
0:               "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText', 'org.apache.derby.optional.api.LuceneUtils.standardAnalyzer' )" );
/////////////////////////////////////////////////////////////////////////
0:                      "org.apache.derby.optional.api.LuceneUtils.defaultAnalyzer",
0:                      "org.apache.derby.optional.api.LuceneUtils.standardAnalyzer",
commit:1a8d034
/////////////////////////////////////////////////////////////////////////
1:              "values ( substr( getDatabaseLocale(), 1, 2 ) )",
1:                  { LANGUAGE },
commit:2277df2
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
1: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1: import org.apache.derbyTesting.junit.LocaleTestSetup;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      INDEX_POEMS = "call LuceneSupport.createIndex( 'ruth', 'poems', 'poemText', null )";
1:     private static  final   String      UPDATE_POEMS_INDEX = "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText', null )";
0:     private static  final   String      LUCENE_VERSION = "LUCENE_45";
1:     private static  final   String      LANGUAGE = "en";
1:     private static  final   String      COUNTRY = "US";
1: 
/////////////////////////////////////////////////////////////////////////
0:         Test        localizedTest = new LocaleTestSetup( suite, new Locale( LANGUAGE, COUNTRY ) );
0:         Test        secureTest = new SecurityManagerSetup( localizedTest, POLICY_FILE );
/////////////////////////////////////////////////////////////////////////
1:         expectExecutionError
1:             ( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText', null )" );
/////////////////////////////////////////////////////////////////////////
1:         expectExecutionError( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'foo', null )" );
1:         expectExecutionError
1:             ( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'originalAuthor', null )" );
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 0 ) ) luceneResults order by poemID";
/////////////////////////////////////////////////////////////////////////
1:                  { "3", "3", "2", "0.22933942" },
1:                  { "4", "4", "3", "0.22933942" },
1:                  { "5", "5", "4", "0.26756266" },
/////////////////////////////////////////////////////////////////////////
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 0 ) ) luceneResults order by poemid";
1:                 { "3", "3", "2", "0.22933942" },
1:                 { "4", "4", "3", "0.22933942" },
1:                 { "5", "5", "4", "0.26756266" },
/////////////////////////////////////////////////////////////////////////
1:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'foo', 'poemText', null )" );
1:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'poems', 'fooText', null )" );
1:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'poems', 'versionStamp', null )" );
/////////////////////////////////////////////////////////////////////////
1:                  { "Walt Whitman", "0.26756266" },
1:                  { "Lord Byron", "0.22933942" },
1:                  { "John Milton", "0.22933942" },
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test that you can change the Analyzer.
1:      * </p>
1:      */
1:     public  void    test_006_changeAnalyzer()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         createSchema( ruthConnection, Types.INTEGER );
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         goodStatement( ruthConnection, INDEX_POEMS );
1: 
1:         // verify that we are the correct locale
1:         assertResults
1:             (
1:              ruthConnection,
0:              "values ( getDatabaseLocale() )",
1:              new String[][]
1:              {
0:                  { LANGUAGE + "_" + COUNTRY },
1:              },
1:              false
1:              );
1:         
1: 
1:         String  query =
0:             "select p.originalAuthor, i.rank\n" +
0:             "from ruth.poems p, table ( ruth.poems__poemText( 'star', 0 ) ) i\n" +
1:             "where p.poemID = i.poemID and p.versionStamp = i.versionStamp\n" +
0:             "order by i.rank desc\n";
1: 
1:         assertResults
1:             (
1:              ruthConnection,
1:              query,
1:              new String[][]
1:              {
1:                  { "Walt Whitman", "0.26756266" },
1:                  { "Lord Byron", "0.22933942" },
1:                  { "John Milton", "0.22933942" },
1:              },
1:              false
1:              );
1: 
1:         // now switch the Analyzer and re-run the query
0:         goodStatement
1:             ( ruthConnection,
0:               "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText', 'org.apache.derby.optional.LuceneUtils.standardAnalyzer' )" );
1: 
1:         assertResults
1:             (
1:              ruthConnection,
1:              query,
1:              new String[][]
1:              {
1:                  { "Walt Whitman", "0.3304931" },
1:                  { "John Milton", "0.2832798" },
1:              },
1:              false
1:              );
1: 
1:         //
1:         // Add another index and inspect the values of listIndexes()
1:         //
1:         goodStatement( ruthConnection, "call LuceneSupport.createIndex( 'ruth', 'poems', 'originalAuthor', null )" );
1:         assertResults
1:             (
1:              ruthConnection,
0:              "select schemaName, tableName, columnName, luceneVersion, analyzer, analyzerMaker\n" +
1:              "from table( LuceneSupport.listIndexes() ) l\n" +
1:              "order by schemaName, tableName, columnName\n",
1:              new String[][]
1:              {
1:                  {
1:                      "RUTH", "POEMS", "ORIGINALAUTHOR", LUCENE_VERSION,
1:                      "org.apache.lucene.analysis.en.EnglishAnalyzer",
0:                      "org.apache.derby.optional.LuceneUtils.defaultAnalyzer",
1:                  },
1:                  {
1:                      "RUTH", "POEMS", "POEMTEXT", LUCENE_VERSION,
1:                      "org.apache.lucene.analysis.standard.StandardAnalyzer",
0:                      "org.apache.derby.optional.LuceneUtils.standardAnalyzer",
1:                  },
1:              },
1:              false
1:              );
1: 
1:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:         goodStatement( ruthConnection, "call LuceneSupport.dropIndex( 'ruth', 'poems', 'originalAuthor' )" );
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         dropSchema( ruthConnection );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         createLocaleFunction( ruthConnection );
/////////////////////////////////////////////////////////////////////////
1:     private void    createLocaleFunction( Connection conn )
1:         throws Exception
1:     {
0:         goodStatement
1:             (
0:              conn,
1:              "create function getDatabaseLocale() returns varchar( 20 )\n" +
1:              "language java parameter style java reads sql data\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.getDatabaseLocale()'\n"
1:              );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         goodStatement( ruthConnection, "drop function getDatabaseLocale" );
/////////////////////////////////////////////////////////////////////////
1:     /** Get the database locale */
1:     public  static  String  getDatabaseLocale()
1:         throws SQLException
1:     {
1:         return ConnectionUtil.getCurrentLCC().getDatabase().getLocale().toString();
1:     }
1:     
commit:6aeea9c
/////////////////////////////////////////////////////////////////////////
1:         createSchema( ruthConnection, Types.INTEGER );
1: 
/////////////////////////////////////////////////////////////////////////
1:         dropSchema( ruthConnection );
commit:cb62199
/////////////////////////////////////////////////////////////////////////
1:         String  listIndexes = "select schemaName, tableName, columnName from table ( LuceneSupport.listIndexes() ) listindexes";
1:                  { "RUTH", "POEMS", "POEMTEXT" },
commit:d847ced
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.math.BigDecimal;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import java.sql.SQLException;
0: import java.sql.SQLWarning;
1: import java.sql.Connection;
1: import java.sql.Date;
0: import java.sql.Statement;
1: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.Types;
0: import java.util.ArrayList;
1: import java.util.Arrays;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: 
1: /**
1:  * <p>
1:  * Test permissions on objects created by the optional Lucene support tool.
1:  * </p>
1:  */
1: public class LuceneSupportPermsTest extends GeneratedColumnsHelper
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String      TEST_DBO = "TEST_DBO";
1:     private static  final   String      RUTH = "RUTH";
1:     private static  final   String      ALICE = "ALICE";
1:     private static  final   String      FRANK = "FRANK";
1:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, ALICE, RUTH, FRANK  };
1: 
1: 	private static  final   String      AUTH_NO_ACCESS_NOT_OWNER    = "42507";
1: 	private static  final   String      DBO_ONLY                                = "4251D";
1:     private static  final   String      FUNCTION_EXISTS                 = "X0Y68";
1: 
1:     private static  final   String      NOT_INDEXABLE                   = "42XBA";
1:     private static  final   String      NO_PRIMARY_KEY              = "42XBB";
1:     // LUCENE_UNSUPPORTED_TYPE = "42XBC": only raised if key type is unsupported. but all indexable types are supported.
1:     // LUCENE_INVALID_CHARACTER = "42XBD" is tested by LuceneSupportTest.
1:     private static  final   String      NONEXISTENT_INDEX           = "42XBE";
1: 	private static  final   String      NO_DDL_PRIV                    = "42XBF";
1: 	private static  final   String      DOUBLE_LOAD_ILLEGAL         = "42XBG";
1: 	private static  final   String      DOUBLE_UNLOAD_ILLEGAL       = "42XBH";
1: 	private static  final   String      BAD_DIRECTORY                      = "42XBI";
1: 
1:     private static  final   String      POLICY_FILE = "org/apache/derbyTesting/functionTests/tests/lang/luceneSupport.policy";
1: 
1:     private static  final   String      LOAD_TOOL = "call syscs_util.syscs_register_tool( 'luceneSupport', true )";
1:     private static  final   String      UNLOAD_TOOL = "call syscs_util.syscs_register_tool( 'luceneSupport', false )";
0:     private static  final   String      INDEX_POEMS = "call LuceneSupport.createIndex( 'ruth', 'poems', 'poemText' )";
0:     private static  final   String      UPDATE_POEMS_INDEX = "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText' )";
1:     private static  final   String      DROP_POEMS_INDEX = "call LuceneSupport.dropIndex( 'ruth', 'poems', 'poemText' )";
1: 
1:     private static  final   long        MILLIS_IN_HOUR = 1000L * 60L * 60L;
1:     private static  final   long        MILLIS_IN_DAY = MILLIS_IN_HOUR * 24L;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create a new instance.
1:      */
1: 
1:     public LuceneSupportPermsTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = (TestSuite) TestConfiguration.embeddedSuite(LuceneSupportPermsTest.class);
1: 
0:         Test        secureTest = new SecurityManagerSetup( suite, POLICY_FILE );
1:         Test        authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:             ( secureTest, LEGAL_USERS, "LuceneSupportPermissions" );
0:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecorator( authenticatedTest );
1: 
0:         return authorizedTest;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Test baseline permissions where no grants are made.
1:      * </p>
1:      */
1:     public  void    test_001_basicNoGrant()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1:         Connection  aliceConnection = openUserConnection( ALICE );
1: 
1:         createSchema( ruthConnection, Types.INTEGER );
1: 
1:         // ruth does not have permission to load the tool
1:         expectExecutionError( ruthConnection, LACK_EXECUTE_PRIV, LOAD_TOOL );
1: 
1:         // but the dbo has permission
1:         goodStatement( dboConnection, LOAD_TOOL );
1: 
1:         // can't update a non-existent index
0:         expectExecutionError( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'poemText' )" );
1: 
1:         // alice does not have permission to index a table owned by ruth
1:         expectExecutionError( aliceConnection, LACK_COLUMN_PRIV, INDEX_POEMS );
1: 
1:         // but ruth can
1:         goodStatement( ruthConnection, INDEX_POEMS );
1: 
1:         // redundant index creation fails
1:         expectExecutionError( ruthConnection, FUNCTION_EXISTS, INDEX_POEMS );
1: 
1:         // can't update a non-existent index
0:         expectExecutionError( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'foo' )" );
0:         expectExecutionError( ruthConnection, NONEXISTENT_INDEX, "call LuceneSupport.updateIndex( 'ruth', 'poems', 'originalAuthor' )" );
1: 
1:         // alice can't view an index created by ruth
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 0 ) ) luceneResults";
1:         expectExecutionError( aliceConnection, LACK_EXECUTE_PRIV, viewPoemsIndex );
1: 
1:         // but ruth can
1:         assertResults
1:             (
1:              ruthConnection,
1:              viewPoemsIndex,
1:              new String[][]
1:              {
0:                  { "5", "5", "4", "0.3304931" },
0:                  { "3", "3", "2", "0.2832798" },
1:              },
1:              false
1:              );
1: 
1:         // alice can list indexes even on tables owned by ruth
0:         String  listIndexes = "select id, schemaName, tableName, columnName from table ( LuceneSupport.listIndexes() ) listindexes";
1:         assertResults
1:             (
1:              aliceConnection,
1:              listIndexes,
1:              new String[][]
1:              {
0:                  { "1", "RUTH", "POEMS", "POEMTEXT" },
1:              },
1:              false
1:              );
1: 
1:         // alice cannot update an index owned by ruth
1:         expectExecutionError( aliceConnection, NO_DDL_PRIV, UPDATE_POEMS_INDEX );
1:         
1:         // alice cannot drop an index owned by ruth
1:         expectExecutionError( aliceConnection, AUTH_NO_ACCESS_NOT_OWNER, DROP_POEMS_INDEX );
1: 
1:         // ruth can update the index
1:         goodStatement( ruthConnection, UPDATE_POEMS_INDEX );
1: 
0:         // dropping the key prevents you from re-indexing
0:         goodStatement( ruthConnection, "alter table poems drop constraint poemsKey" );
0:         expectExecutionError( ruthConnection, NO_PRIMARY_KEY, UPDATE_POEMS_INDEX );
1:         
1:         // ruth can drop the index
1:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:         assertResults
1:             (
1:              ruthConnection,
1:              listIndexes,
1:              new String[][] {},
1:              false
1:              );
1: 
1:         // redundant drop fails, however
1:         expectExecutionError( ruthConnection, NONEXISTENT_OBJECT, DROP_POEMS_INDEX );
1: 
1:         // ruth cannot unload the tool
1:         expectExecutionError( ruthConnection, LACK_EXECUTE_PRIV, UNLOAD_TOOL );
1: 
1:         // but the dbo can
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1: 
1:         dropSchema( ruthConnection );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Test that a user can grant access to her indexes.
1:      * </p>
1:      */
1:     public  void    test_002_userGrant()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1:         Connection  aliceConnection = openUserConnection( ALICE );
1: 
1:         createSchema( ruthConnection, Types.INTEGER );
1: 
1:         // load the Lucene plugin
1:         goodStatement( dboConnection, LOAD_TOOL );
1: 
1:         // ruth indexes her table and grants alice privilege to run the index reading function
1:         goodStatement( ruthConnection, INDEX_POEMS );
1: 
1:         Permission[]    permissions = new Permission[]
1:         {
1:             new Permission( "execute on function poems__poemText", NO_GENERIC_PERMISSION ),
1:             new Permission( "select ( poemID ) on poems", NO_SELECT_OR_UPDATE_PERMISSION ),
1:             new Permission( "select ( versionStamp ) on poems", NO_SELECT_OR_UPDATE_PERMISSION ),
1:             new Permission( "select ( poemText ) on poems", NO_SELECT_OR_UPDATE_PERMISSION ),
1:         };
1:         for ( Permission permission : permissions )
1:         {
1:             grantPermission( ruthConnection, permission.text, ALICE );
1:         }
1: 
1:         // but alice still needs select privilege on the base table columns
0:         String  viewPoemsIndex = "select * from table ( ruth.poems__poemText( 'star', 0 ) ) luceneResults";
1:         String[][]  viewPoemsIndexResults = new String[][]
1:             {
0:                 { "5", "5", "4", "0.3304931" },
0:                 { "3", "3", "2", "0.2832798" },
1:             };
1: 
1:         // now alice can view the index
1:         assertResults( aliceConnection, viewPoemsIndex, viewPoemsIndexResults, false );
1: 
1:         // now revoke each permission and verify that it is needed
1:         for ( Permission permission : permissions )
1:         {
1:             vetPermission_002( permission, ruthConnection, aliceConnection, viewPoemsIndex, viewPoemsIndexResults );
1:         }
1: 
1:         // but alice still can't drop an index owned by ruth
1:         expectExecutionError( aliceConnection, AUTH_NO_ACCESS_NOT_OWNER, DROP_POEMS_INDEX );
1: 
1:         // unload the plugin
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1: 
1:         dropSchema( ruthConnection );
1:     }
1:     private void    vetPermission_002
1:         (
1:          Permission permission,
1:          Connection ruthConnection,
1:          Connection aliceConnection,
1:          String statement,
1:          String[][] expectedResults
0:          )
1:         throws Exception
1:     {
1:         revokePermission( ruthConnection, permission.text, ALICE );
1:         expectExecutionError( aliceConnection, permission.sqlStateWhenMissing, statement );
1:         grantPermission( ruthConnection, permission.text, ALICE );
1:         assertResults( aliceConnection, statement, expectedResults, false );
1:     }
1:     private void    grantPermission( Connection conn, String permission, String grantee )
1:         throws Exception
1:     {
1:         String  command = "grant " + permission + " to " + grantee;
1: 
1:         goodStatement( conn, command );
1:     }
1:     private void    revokePermission( Connection conn, String permission, String grantee )
1:         throws Exception
1:     {
1:         String  command = "revoke " + permission + " from " + grantee;
1:         if ( permission.startsWith( "execute" ) || permission.startsWith( "usage" ) )   { command += " restrict"; }
1: 
1:         goodStatement( conn, command );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Test that only the DBO can (un)load the tool and the tool
1:      * can't be (un)loaded twice.
1:      * </p>
1:      */
1:     public  void    test_003_loading()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         goodStatement( dboConnection, "grant execute on procedure syscs_util.syscs_register_tool to public" );
1: 
1:         // only the DBO can load the tool
1:         expectExecutionError( ruthConnection, DBO_ONLY, LOAD_TOOL );
1: 
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         expectExecutionError( dboConnection, DOUBLE_LOAD_ILLEGAL, LOAD_TOOL );
1: 
1:         // cannot index non-existent table or column
0:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'foo', 'poemText' )" );
0:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'poems', 'fooText' )" );
0:         expectExecutionError( ruthConnection, NOT_INDEXABLE, "call LuceneSupport.createIndex( 'ruth', 'poems', 'versionStamp' )" );
1: 
1:         // cannot drop non-existent index
1:         expectExecutionError( ruthConnection, NONEXISTENT_OBJECT, "call LuceneSupport.dropIndex( 'ruth', 'foo', 'poemText' )" );
1:         expectExecutionError( ruthConnection, NONEXISTENT_OBJECT, "call LuceneSupport.dropIndex( 'ruth', 'poems', 'versionStamp' )" );
1:         
1:         // only the DBO can unload the tool
1:         expectExecutionError( ruthConnection, DBO_ONLY, UNLOAD_TOOL );
1: 
1:         goodStatement( dboConnection, "revoke execute on procedure syscs_util.syscs_register_tool from public restrict" );
1: 
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         expectExecutionError( dboConnection, DOUBLE_UNLOAD_ILLEGAL, UNLOAD_TOOL );
1: 
1:         // try loading and unloading again for good measure
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Test all datatypes as key types.
1:      * </p>
1:      */
1:     public  void    test_004_datatypes()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         goodStatement( dboConnection, LOAD_TOOL );
1: 
1:         vet_004( ruthConnection, Types.BIGINT );
1:         vet_004( ruthConnection, Types.BOOLEAN );
1:         vet_004( ruthConnection, Types.CHAR );
1:         vet_004( ruthConnection, Types.BINARY );
1:         vet_004( ruthConnection, Types.DATE );
1:         vet_004( ruthConnection, Types.DECIMAL );
1:         vet_004( ruthConnection, Types.DOUBLE );
1:         vet_004( ruthConnection, Types.FLOAT );
1:         vet_004( ruthConnection, Types.INTEGER );
1:         vet_004( ruthConnection, Types.NUMERIC );
1:         vet_004( ruthConnection, Types.REAL );
1:         vet_004( ruthConnection, Types.SMALLINT );
1:         vet_004( ruthConnection, Types.TIME );
1:         vet_004( ruthConnection, Types.TIMESTAMP );
1:         vet_004( ruthConnection, Types.VARCHAR );
1:         vet_004( ruthConnection, Types.VARBINARY );
1: 
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:     }
1:     private void    vet_004( Connection ruthConnection, int jdbcType )
1:         throws Exception
1:     {
1:         createSchema( ruthConnection, jdbcType );
1:         goodStatement( ruthConnection, INDEX_POEMS );
1: 
1:         // make sure that we can de-serialize the key
1:         assertResults
1:             (
1:              ruthConnection,
0:              "select p.originalAuthor, i.rank\n" +
0:              "from ruth.poems p, table ( ruth.poems__poemText( 'star', 0 ) ) i\n" +
1:              "where p.poemID = i.poemID and p.versionStamp = i.versionStamp\n" +
0:              "order by i.rank desc\n",
1:              new String[][]
1:              {
0:                  { "Walt Whitman", "0.3304931" },
0:                  { "John Milton", "0.2832798" },
1:              },
1:              false
1:              );
1: 
1:         goodStatement( ruthConnection, DROP_POEMS_INDEX );
1:         dropSchema( ruthConnection );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Test error messages when a lucene directory has been deleted.
1:      * </p>
1:      */
1:     public  void    test_005_deleteDirectory()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         createSchema( ruthConnection, Types.INTEGER );
1:         goodStatement( dboConnection, LOAD_TOOL );
1:         goodStatement( ruthConnection, INDEX_POEMS );
1: 
1:         TestConfiguration   config = getTestConfiguration();
1: 
1:         String  dbName = config.getDefaultDatabaseName();
1:         String  physicalDBName = config.getPhysicalDatabaseName( dbName );
1:         String  dbPath = config.getDatabasePath( physicalDBName );
1:         File    dbDirectory = new File( dbPath );
0:         File    luceneDirectory = new File( dbDirectory, "lucene" );
1:         File    ruthDirectory = new File( luceneDirectory, "RUTH" );
1:         File    poemsDirectory = new File( ruthDirectory, "POEMS" );
1:         File    poemTextIndexDirectory = new File( poemsDirectory, "POEMTEXT" );
1: 
1:         assertTrue( deleteFile( poemTextIndexDirectory ) );
1: 
0:         // can't update the index if the directory has disappeared
0:         expectExecutionError( ruthConnection, BAD_DIRECTORY, UPDATE_POEMS_INDEX );
0:         expectExecutionError( ruthConnection, BAD_DIRECTORY, DROP_POEMS_INDEX );
1: 
1:         goodStatement( dboConnection, UNLOAD_TOOL );
1:         dropSchema( ruthConnection );
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private void    createSchema( Connection ruthConnection, int jdbcType )  throws Exception
1:     {
1:         createPoemsTable( ruthConnection, jdbcType );
1:     }
1:     private void    createPoemsTable( Connection conn, int jdbcType )
1:         throws Exception
1:     {
0:         goodStatement
1:             (
0:              conn,
1:              "create table poems\n" +
1:              "(\n" +
1:              "    poemID " + getType( jdbcType ) + ",\n" +
1:              "    versionStamp int not null,\n" +
1:              "    originalAuthor       varchar( 50 ),\n" +
1:              "    lastEditor           varchar( 50 ),\n" +
1:              "    poemText            clob,\n" +
1:              "    constraint poemsKey primary key( poemID, versionStamp )\n" +
1:              ")\n"
1:              );
1: 
1:         PreparedStatement   ps = conn.prepareStatement( "insert into poems values ( ?, ?, ?, ?, ? )" );
1: 
1:         int     poemID = 1;
1:         int     versionStamp = 1;
1: 
1:         setNextPoemID( ps, jdbcType, poemID++ );
1:         ps.setInt( 2, versionStamp++ );
1:         ps.setString( 3, "Geoffrey Chaucer" );
1:         ps.setString( 4, "Geoffrey Chaucer" );
1:         ps.setString( 5, "Whan that Aprill, with his shoures soote The droghte of March hath perced to the roote And bathed every veyne in swich licour, Of which vertu engendred is the flour;" );
1:         ps.executeUpdate();
1: 
1:         setNextPoemID( ps, jdbcType, poemID++ );
1:         ps.setInt( 2, versionStamp++ );
1:         ps.setString( 3, "Andrew Marvell" );
1:         ps.setString( 4, "Andrew Marvell" );
1:         ps.setString( 5, "Had we but world enough, and time, This coyness, lady, were no crime." );
1:         ps.executeUpdate();
1: 
1:         setNextPoemID( ps, jdbcType, poemID++ );
1:         ps.setInt( 2, versionStamp++ );
1:         ps.setString( 3, "John Milton" );
1:         ps.setString( 4, "John Milton" );
1:         ps.setString( 5, "From morn to noon he fell, from noon to dewy eve, a summers day, and with the setting sun dropped from the ze4ith like a falling star on Lemnos, the Aegean isle" );
1:         ps.executeUpdate();
1: 
1:         setNextPoemID( ps, jdbcType, poemID++ );
1:         ps.setInt( 2, versionStamp++ );
1:         ps.setString( 3, "Lord Byron" );
1:         ps.setString( 4, "Lord Byron" );
1:         ps.setString( 5, "The Assyrian came down like the wolf on the fold, And his cohorts were gleaming in purple and gold; And the sheen of their spears was like stars on the sea, When the blue wave rolls nightly on deep Galilee." );
1:         ps.executeUpdate();
1: 
1:         setNextPoemID( ps, jdbcType, poemID++ );
1:         ps.setInt( 2, versionStamp++ );
1:         ps.setString( 3, "Walt Whitman" );
1:         ps.setString( 4, "Walt Whitman" );
1:         ps.setString( 5, "When lilacs last in the dooryard bloomd, And the great star early droopd in the western sky in the night, I mournd, and yet shall mourn with ever-returning spring." );
1:         ps.executeUpdate();
1: 
1:         ps.close();
1:     }
1: 
1:     private String  getType( int jdbcType ) throws Exception
1:     {
1:         switch( jdbcType )
1:         {
1:         case Types.BINARY: return "char( 100 ) for bit data";
1:         case Types.BOOLEAN: return "boolean";
1:         case Types.DECIMAL: return "decimal";
1:         case Types.INTEGER: return "int";
1:         case Types.BIGINT: return "bigint";
1:         case Types.SMALLINT: return "smallint";
1:         case Types.DOUBLE: return "double";
1:         case Types.FLOAT: return "real";
1:         case Types.NUMERIC: return "numeric";
1:         case Types.CHAR: return "char( 5 )";
1:         case Types.REAL: return "real";
1:         case Types.VARCHAR: return "varchar( 5 )";
1:         case Types.VARBINARY: return "varchar( 256 ) for bit data";
1:         case Types.DATE: return "date";
1:         case Types.TIME: return "time";
1:         case Types.TIMESTAMP: return "timestamp";
1: 
1:         default:    throw new Exception( "Unsupported datatype: " + jdbcType );
1:         }
1:     }
1: 
1:     private void    setNextPoemID( PreparedStatement ps, int jdbcType, int intPoemID )
1:         throws Exception
1:     {
1:         switch( jdbcType )
1:         {
1:         case Types.BINARY:
1:             ps.setBytes( 1, makeBytes( intPoemID ) );
1:             break;
1: 
1:         case Types.BOOLEAN:
1:             ps.setBoolean( 1, (intPoemID % 2 == 0) ? true : false );
1:             break;
1: 
1:         case Types.DECIMAL:
1:         case Types.NUMERIC:
1:             ps.setBigDecimal( 1, new BigDecimal( intPoemID ) );
1:             break;
1: 
1:         case Types.INTEGER:
1:             ps.setInt( 1, intPoemID );
1:             break;
1: 
1:         case Types.BIGINT:
1:             ps.setLong( 1, (long) intPoemID + (long) Integer.MAX_VALUE );
1:             break;
1: 
1:         case Types.SMALLINT:
1:             ps.setShort( 1, (short) intPoemID );
1:             break;
1: 
1:         case Types.DOUBLE:
1:             ps.setDouble( 1, (double) intPoemID );
1:             break;
1: 
1:         case Types.FLOAT:
1:         case Types.REAL:
1:             ps.setFloat( 1, (float) intPoemID );
1:             break;
1: 
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:             ps.setString( 1, makeStringKey( intPoemID ) );
1:             break;
1: 
1:         case Types.VARBINARY:
1:             ps.setBytes( 1, makeAllBytes( intPoemID ) );
1:             break;
1: 
1:         case Types.DATE:
1:             ps.setDate( 1, new Date( MILLIS_IN_DAY * (long)(500 + intPoemID) ) );
1:             break;
1: 
1:         case Types.TIME:
1:             ps.setTime( 1, new Time( MILLIS_IN_HOUR * (long)(intPoemID) ) );
1:             break;
1: 
1:         case Types.TIMESTAMP:
1:             ps.setTimestamp( 1, new Timestamp( MILLIS_IN_DAY * (long)(500 + intPoemID) ) );
1:             break;
1: 
1:         default:    throw new Exception( "Unsupported datatype: " + jdbcType );
1:         }
1:     }
1:     private String  makeStringKey( int key )
1:     {
1:         String  digit = Integer.toString( key );
1:         return digit + digit + digit + digit + digit;
1:     }
1: 
1:     private void    dropSchema( Connection ruthConnection )    throws Exception
1:     {
1:         goodStatement( ruthConnection, "drop table poems" );
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // PROCEDURES AND FUNCTIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  String  toString( byte[] value )
1:     {
1:         if ( value == null ) { return null; }
1: 
1:         return Arrays.toString( value );
1:     }
1: 
1:     /** Make a byte array with all possible byte values in it */
1:     public  static  byte[]  makeAllBytes( int initialValue )
1:     {
1:         int     size = 2 * ( -Byte.MIN_VALUE );
1:         byte[]  result = new byte[ size ];
1:         int     value = initialValue;
1: 
1:         if ( value < Byte.MIN_VALUE ) { value = Byte.MIN_VALUE; }
1:         if ( value > Byte.MAX_VALUE ) { value = Byte.MAX_VALUE; }
1: 
1:         for ( int idx = 0; idx < size; idx++ )
1:         {
1:             result[ idx ] = (byte) (value++);
1: 
1:             if ( value > Byte.MAX_VALUE ) { value = Byte.MIN_VALUE; }
1:         }
1: 
1:         return result;
1:     }
1:     
1:     /** Make a byte array starting with the given byte */
1:     public  static  byte[]  makeBytes( int initialValue )
1:     {
1:         byte[]  result = new byte[ initialValue ];
1: 
1:         for ( int idx = 0; idx < initialValue; idx++ )
1:         {
1:             result[ idx ] = (byte) initialValue;
1:         }
1: 
1:         return result;
1:     }
1:     
1:     /**
1:      * Delete a file. If it's a directory, recursively delete all directories
1:      * and files underneath it first.
1:      */
1:     private boolean deleteFile( File file )
1:         throws IOException, PrivilegedActionException
1:     {
1:         boolean retval = true;
1:         
1:         if ( isDirectory( file ) )
1:         {
1:             for ( File child : listFiles( file ) ) { retval = retval && deleteFile( child ); }
1:         }
1: 
1:         return retval && clobberFile( file );
1:     }
1: 
1:     /** Return true if the file is a directory */
1:     private boolean isDirectory( final File file )
1:         throws IOException, PrivilegedActionException
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedExceptionAction<Boolean>()
1:              {
1:                 public Boolean run() throws IOException
1:                 {
1:                     if ( file == null ) { return false; }
1:                     else { return file.isDirectory(); }
1:                 }
1:              }
1:              ).booleanValue();
1:     }
1: 
1:     /** Really delete a file */
1:     private boolean clobberFile( final File file )
1:         throws IOException, PrivilegedActionException
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedExceptionAction<Boolean>()
1:              {
1:                 public Boolean run() throws IOException
1:                 {
1:                     return file.delete();
1:                 }
1:              }
1:              ).booleanValue();
1:     }
1: 
1:     /** List files */
1:     private File[]  listFiles( final File file )
1:         throws IOException, PrivilegedActionException
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedExceptionAction<File[]>()
1:              {
1:                 public File[] run() throws IOException
1:                 {
1:                     return file.listFiles();
1:                 }
1:              }
1:              );
1:     }
1: 
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
0: import java.sql.SQLException;
0: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
0: import org.apache.lucene.analysis.Analyzer;
0: import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;
0: import org.apache.lucene.queryparser.classic.ParseException;
0: import org.apache.lucene.queryparser.classic.QueryParser;
0: import org.apache.lucene.search.Query;
0: import org.apache.lucene.util.Version;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = (BaseTestSuite)TestConfiguration.embeddedSuite(
1:             LuceneSupportPermsTest.class);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:faa9027
/////////////////////////////////////////////////////////////////////////
1:         File    luceneDirectory = new File( dbDirectory, "LUCENE" );
commit:689206c
/////////////////////////////////////////////////////////////////////////
1:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecoratorSingleUse( authenticatedTest, DB_NAME, true );
============================================================================