1:125c328: /*
1:da0b88f: 
1:69e3d06:    Derby - Class org.apache.derby.client.am.ClientClob
1:8055511: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:8055511: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:8055511: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:da0b88f: 
1:f433a64: */
1:da0b88f: 
1:33776ff: package org.apache.derby.client.am;
1:1e5b2aa: 
1:da0b88f: 
1:125c328: import java.io.IOException;
1:69e3d06: import java.io.InputStream;
1:69e3d06: import java.io.InputStreamReader;
1:69e3d06: import java.io.OutputStream;
1:a4846de: import java.io.Reader;
1:69e3d06: import java.io.StringReader;
1:69e3d06: import java.io.Writer;
1:a0b8943: import java.nio.charset.Charset;
1:69e3d06: import java.sql.Clob;
1:d506170: import java.sql.SQLException;
1:1e5b2aa: 
1:956354d: import org.apache.derby.client.net.EncodedInputStream;
1:1e5b2aa: import org.apache.derby.shared.common.reference.SQLState;
1:61aec23: 
1:69e3d06: /**
1:69e3d06:  * This class implements the JDBC {@code java.sql.Clob} interface.
1:69e3d06:  */
1:69e3d06: public class ClientClob extends Lob implements Clob {
1:70f7692:     //---------------------navigational members-----------------------------------
1:125c328: 
1:70f7692:     //-----------------------------state------------------------------------------
1:70f7692:     protected String string_ = null;
1:a4846de: 
1:70f7692:     // Only used for input purposes.  For output, each getXXXStream call
1:70f7692:     // must generate an independent stream.
1:0326967:     private InputStream asciiStream_ = null;
1:0326967:     private InputStream unicodeStream_ = null;
1:0326967:     private Reader characterStream_ = null;
1:fefd864: 
1:70f7692:     // used for input
1:70f7692:     // Therefore, we always convert a String to UTF-8 before we flow it for input
1:0326967:     private byte[] utf8String_;
1:fefd864: 
1:70f7692:     //---------------------constructors/finalizer---------------------------------
1:69e3d06:     public ClientClob(Agent agent, String string) {
1:da0b88f: 
1:fefd864:         this(agent,
1:fefd864:              false);
1:8055511: 
1:70f7692:         string_ = string;
1:2ef245a:         setSqlLength(string_.length());
2:70f7692:         dataType_ |= STRING;
1:d506170:     }
1:8055511: 
1:70f7692:     // CTOR for output, when a btc isn't available; the encoding is
1:69e3d06:     public ClientClob(Agent agent,
1:70f7692:                 byte[] unconvertedBytes,
1:a0b8943:                 Charset charset,
1:70f7692:                 int dataOffset) throws SqlException {
1:8055511: 
1:fefd864:         this(agent,
1:fefd864:              false);
1:da0b88f: 
1:a0b8943:         // check for null encoding is needed because the net layer
1:a0b8943:         // will no longer throw an exception if the server didn't specify
1:a0b8943:         // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
1:a0b8943:         // cursor is only required for types which can have mixed or double
1:a0b8943:         // byte ccsids.
1:a0b8943:         if (charset == null) {
1:a0b8943:             throw new SqlException(agent.logWriter_,
1:a0b8943:                 new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
1:a4846de:         }
1:a0b8943: 
1:a0b8943:         string_ = new String(unconvertedBytes,
1:a0b8943:                 dataOffset,
1:a0b8943:                 unconvertedBytes.length - dataOffset,
1:a0b8943:                 charset);
1:a0b8943:         setSqlLength(string_.length());
1:a0b8943:         dataType_ |= STRING;
1:70f7692:     }
1:da0b88f: 
1:70f7692:     // CTOR for ascii/unicode stream input
1:faf6742:     //"ISO-8859-1", "UTF-8", or "UnicodeBigUnmarked"
1:69e3d06:     public ClientClob(Agent agent,
1:69e3d06:                 InputStream inputStream,
1:a0b8943:                 Charset encoding,
1:a0b8943:                 int length) {
1:da0b88f: 
1:fefd864:         this(agent,
1:fefd864:              false);
1:da0b88f: 
1:2ef245a:         setSqlLength(length);
1:da0b88f: 
1:a0b8943:         if (encoding.equals(Cursor.ISO_8859_1)) {
1:70f7692:             asciiStream_ = inputStream;
1:70f7692:             dataType_ |= ASCII_STREAM;
1:a0b8943:         } else if (encoding.equals(Cursor.UTF_8)) {
1:70f7692:             unicodeStream_ = inputStream;
1:70f7692:             dataType_ |= UNICODE_STREAM;
1:a0b8943:         } else if (encoding.equals(Cursor.UTF_16BE)) {
1:a0b8943:             characterStream_ =
1:a0b8943:                     new InputStreamReader(inputStream, Cursor.UTF_16BE);
1:70f7692:             dataType_ |= CHARACTER_STREAM;
1:2ef245a:             setSqlLength(length / 2);
1:70f7692:         }
1:70f7692:     }
1:da0b88f: 
1:c784df5:     /**
1:69e3d06:      * Create a <code>ClientClob</code> of unknown length with the specified
1:956354d:      * encoding.
1:956354d:      *
1:956354d:      * This constructor was added to support the JDBC 4 length less overloads.
1:69e3d06:      * Note that a <code>ClientClob</code> created with this constructor is
1:69e3d06:      * made for input to the database only. Do not pass it out to the user!
1:c9382f0:      *
1:956354d:      * @param agent
1:956354d:      * @param inputStream the data to insert
1:faf6742:      * @param encoding encoding to use for characters. Only "ISO-8859-1" is
1:956354d:      *      allowed.
1:956354d:      */
1:a0b8943:     ClientClob(Agent agent, InputStream inputStream, Charset encoding)
1:956354d:             throws SqlException {
1:da0b88f: 
1:fefd864:         this(agent,
1:fefd864:              isLayerBStreamingPossible( agent ));
1:da0b88f: 
1:a0b8943:         if (encoding.equals(Cursor.ISO_8859_1)) {
1:956354d:             asciiStream_ = inputStream;
1:956354d:             dataType_ |= ASCII_STREAM;
1:956354d:         } else {
1:da0b88f:             throw new SqlException(agent_.logWriter_,
1:da0b88f:                 new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
1:956354d:                 encoding + " InputStream", "String/Clob");
1:956354d:         }
1:956354d:     }
1:da0b88f: 
1:70f7692:     // CTOR for character stream input
1:70f7692:     // THE ENCODING IS ASSUMED TO BE "UTF-16BE"
1:0326967:     ClientClob(Agent agent, Reader reader, int length) {
1:da0b88f: 
1:fefd864:         this(agent,
1:fefd864:              false);
1:da0b88f: 
1:2ef245a:         setSqlLength(length);
1:70f7692:         characterStream_ = reader;
1:70f7692:         dataType_ |= CHARACTER_STREAM;
1:956354d:     }
1:da0b88f: 
1:c9382f0:     /**
1:69e3d06:      * Create a <code>ClientClob</code> object for a Clob value stored
1:61aec23:      * on the server and indentified by <code>locator</code>.
1:da0b88f:      * @param agent context for this <code>Clob</code>
1:61aec23:      *              object (incl. connection).
1:61aec23:      * @param locator reference id to <code>Clob</code> value on server.
1:61aec23:      */
1:69e3d06:     public ClientClob(Agent agent, int locator)
1:61aec23:     {
1:61aec23:         super(agent, false);
1:61aec23:         locator_ = locator;
1:61aec23:         dataType_ |= LOCATOR;
1:61aec23:     }
1:da0b88f: 
1:61aec23:     /**
1:69e3d06:      * Create a <code>ClientClob</code> of unknown length.
1:956354d:      *
1:956354d:      * This constructor was added to support the JDBC 4 length less overloads.
1:69e3d06:      * Note that a <code>ClientClob</code> created with this constructor is
1:69e3d06:      * made for input to the database only. Do not pass it out to the user!
1:956354d:      *
1:956354d:      * @param agent
1:956354d:      * @param reader the data to insert
1:956354d:      */
1:0326967:     ClientClob(Agent agent, Reader reader) {
1:da0b88f: 
1:fefd864:         this(agent,
1:fefd864:              isLayerBStreamingPossible( agent ) );
1:da0b88f: 
1:956354d:         // Wrap reader in stream to share code.
1:956354d:         unicodeStream_ = EncodedInputStream.createUTF8Stream(reader);
1:956354d:         // Override type to share logic with the other stream types.
1:956354d:         dataType_ |= UNICODE_STREAM;
1:956354d:     }
1:da0b88f: 
1:69e3d06:     private ClientClob(Agent agent,
1:fefd864:                  boolean willBeLayerBStreamed) {
1:fefd864:         super(agent,
1:fefd864:               willBeLayerBStreamed);
1:125c328:     }
1:61aec23: 
1:70f7692:     // ---------------------------jdbc 2------------------------------------------
1:70f7692:     // Create another method lengthX for internal calls
1:d506170:     public long length() throws SQLException {
1:da0b88f: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:da0b88f: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "length");
1:d506170:                 }
1:da0b88f: 
1:2ef245a:                 long length = super.sqlLength();
1:da0b88f: 
1:d506170:                 if (agent_.loggingEnabled()) {
1:2ef245a:                     agent_.logWriter_.traceExit(this, "length", length);
1:d506170:                 }
1:2ef245a:                 return length;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:da0b88f: 
1:956354d:   /**
1:f433a64:    * Returns a copy of the specified substring
1:f433a64:    * in the <code>CLOB</code> value
1:69e3d06:    * designated by this <code>ClientClob</code> object.
1:f433a64:    * The substring begins at position
1:f433a64:    * <code>pos</code> and has up to <code>length</code> consecutive
1:f433a64:    * characters. The starting position must be between 1 and the length
1:f433a64:    * of the CLOB plus 1. This allows for zero-length CLOB values, from
1:da0b88f:    * which only zero-length substrings can be returned.
1:f433a64:    * If a larger length is requested than there are characters available,
1:f433a64:    * characters to the end of the CLOB are returned.
1:f433a64:    * @param pos the first character of the substring to be extracted.
1:f433a64:    *            The first character is at position 1.
1:f433a64:    * @param length the number of consecutive characters to be copied
1:69e3d06:    * @return a <code>String</code> that is the specified substring in the
1:69e3d06:    *         <code>CLOB</code> value designated by this <code>ClientClob</code>
1:69e3d06:    *         object
1:f433a64:    * @exception SQLException if there is an error accessing the
1:f433a64:    * <code>CLOB</code>
1:da0b88f: 
1:f433a64:    * NOTE: If the starting position is the length of the CLOB plus 1,
1:f433a64:    * zero characters are returned regardless of the length requested.
1:125c328:    */
1:d506170:     public String getSubString(long pos, int length) throws SQLException {
1:da0b88f: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:da0b88f: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 String retVal = null;
1:da0b88f: 
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getSubString", (int) pos, length);
1:d506170:                 }
1:61aec23: 
1:e6936ea:                 if ( pos <= 0 ) {
1:da0b88f:                     throw new SqlException(agent_.logWriter_,
1:66527ec:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), pos);
1:e6936ea:                 }
1:61aec23: 
1:e6936ea:                 if ( length < 0 ) {
1:da0b88f:                     throw new SqlException(agent_.logWriter_,
1:e65b4db:                         new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
1:66527ec:                         length);
1:d506170:                 }
1:1e5b2aa: 
1:2ef245a:                 if (pos > sqlLength() + 1) {
1:da0b88f:                     throw new SqlException(agent_.logWriter_,
1:da0b88f:                         new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE),
1:66527ec:                         pos);
1:f433a64:                 }
1:d506170:                 retVal = getSubStringX(pos, length);
1:1e5b2aa: 
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getSubString", retVal);
1:d506170:                 }
1:d506170:                 return retVal;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:da0b88f: 
1:2ef245a:     private String getSubStringX(long pos, int length) throws SqlException
1:2ef245a:     {
1:2ef245a:         checkForClosedConnection();
1:2ef245a:         // actual length is the lesser of the length requested
1:2ef245a:         // and the number of characters available from pos to the end
1:2ef245a:         long actualLength = Math.min(this.sqlLength() - pos + 1, (long) length);
1:61aec23:         //Check to see if the Clob object is locator enabled.
1:61aec23:         if (isLocator()) {
1:61aec23:             //The Clob object is locator enabled. Hence call the stored
1:61aec23:             //procedure CLOBGETLENGTH to determine the length of the Clob.
1:61aec23:             return agent_.connection_.locatorProcedureCall()
1:61aec23:                 .clobGetSubString(locator_, pos, (int)actualLength);
1:61aec23:         }
1:61aec23:         else {
1:61aec23:             //The Clob object is not locator enabled.
1:61aec23:             return string_.substring
1:61aec23:                     ((int) pos - 1, (int) (pos - 1 + actualLength));
1:61aec23:         }
1:d506170:     }
1:da0b88f: 
1:69e3d06:     public Reader getCharacterStream() throws SQLException {
1:da0b88f: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:956354d: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getCharacterStream");
1:d506170:                 }
1:956354d: 
1:69e3d06:                 Reader retVal = getCharacterStreamX();
1:d506170:                 if (agent_.loggingEnabled()) {
1:61aec23:                     agent_.logWriter_.traceExit(this, "getCharacterStream", retVal);
1:d506170:                 }
1:d506170:                 return retVal;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:956354d: 
1:69e3d06:     Reader getCharacterStreamX() throws SqlException {
1:d506170:         checkForClosedConnection();
1:956354d: 
1:61aec23:         //check is this Lob is locator enabled
1:61aec23:         if (isLocator()) {
1:a8908bd:             //The Lob is locator enabled. Return an instance of the
1:a8908bd:             //update sensitive Reader that wraps inside it a
1:a8908bd:             //Buffered Locator Reader. The wrapper class
1:a8908bd:             //watches out for updates.
1:a8908bd:             return new UpdateSensitiveClobLocatorReader
1:a8908bd:                     (agent_.connection_, this);
1:61aec23:         }
1:61aec23:         else if (isCharacterStream())  // this Lob is used for input
1:d506170:         {
1:70f7692:             return characterStream_;
1:70f7692:         }
1:956354d: 
1:69e3d06:         return new StringReader(string_);
1:70f7692:     }
1:125c328: 
1:69e3d06:     public InputStream getAsciiStream() throws SQLException {
1:125c328: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:125c328: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getAsciiStream");
1:d506170:                 }
1:125c328: 
1:69e3d06:                 InputStream retVal = getAsciiStreamX();
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getAsciiStream", retVal);
1:d506170:                 }
1:d506170:                 return retVal;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:125c328: 
1:69e3d06:     InputStream getAsciiStreamX() throws SqlException {
3:70f7692:         checkForClosedConnection();
1:125c328: 
1:70f7692:         if (isAsciiStream())  // this Lob is used for input
1:d506170:         {
1:70f7692:             return asciiStream_;
1:70f7692:         }
1:61aec23:         else if(isLocator()) { // Check to see if this Lob is locator enabled
1:61aec23:             //The Lob is locator enabled. Return an instance
1:a8908bd:             //of the update sensitive wrappers that wrap inside
1:a8908bd:             //it a Buffered Locator enabled InputStream. The
1:a8908bd:             //wrapper watches out for updates to the underlying
1:a8908bd:             //Clob.
1:a8908bd:             return new UpdateSensitiveClobLocatorInputStream
1:a8908bd:                     (agent_.connection_,this);
1:61aec23:         }
1:61aec23:         else {
1:69e3d06:             return new AsciiStream(string_, new StringReader(string_));
1:61aec23:         }
1:70f7692:     }
1:125c328: 
1:d506170:     public long position(String searchstr, long start) throws SQLException {
1:da0b88f: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:da0b88f: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this,
1:d506170:                             "position(String, long)",
1:d506170:                             searchstr,
1:d506170:                             start);
1:d506170:                 }
1:d506170:                 if (searchstr == null) {
1:da0b88f:                     throw new SqlException(agent_.logWriter_,
1:e65b4db:                         new ClientMessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
1:d506170:                 }
1:f433a64:                 if (start < 1) {
1:da0b88f:                     throw new SqlException(agent_.logWriter_,
1:da0b88f:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION),
1:66527ec:                             start);
1:f433a64:                 }
1:125c328: 
1:d506170:                 long pos = positionX(searchstr, start);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "position(String, long)", pos);
1:f433a64:                 }
1:d506170:                 return pos;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:125c328: 
1:70f7692:     private long positionX(String searchstr, long start) throws SqlException {
1:70f7692:         checkForClosedConnection();
1:61aec23: 
1:61aec23:         long index = -1;
1:70f7692:         if (start <= 0) {
1:da0b88f:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.INVALID_API_PARAMETER),
1:66527ec:                 start, "start", "Clob.position()");
1:70f7692:         }
1:da0b88f: 
1:61aec23:         //Check is locator support is available for this LOB.
1:61aec23:         if (isLocator()) {
1:da0b88f:             //Locator support is available. Hence call
1:da0b88f:             //CLOBGETPOSITIONFROMSTRING to determine the position
1:61aec23:             //of the given substring inside the LOB.
1:61aec23:             index = agent_.connection_.locatorProcedureCall()
1:61aec23:                 .clobGetPositionFromString(locator_, searchstr, start);
1:61aec23:         } else {
1:61aec23:             //Locator support is not available.
1:61aec23:             index = string_.indexOf(searchstr, (int) start - 1);
1:61aec23:             if (index != -1) {
1:61aec23:                 index++; // api index starts at 1
1:61aec23:             }
1:70f7692:         }
1:61aec23:         return index;
1:70f7692:     }
1:125c328: 
1:69e3d06:     public long position(Clob searchstr, long start) throws SQLException {
1:125c328: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:125c328: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this,
1:d506170:                             "position(Clob, long)",
1:d506170:                             searchstr,
1:d506170:                             start);
1:d506170:                 }
1:f433a64:                 if (start < 1) {
1:da0b88f:                     throw new SqlException(agent_.logWriter_,
1:66527ec:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), start);
1:d506170:                 }
1:125c328: 
1:d506170:                 if (searchstr == null) {
1:da0b88f:                     throw new SqlException(agent_.logWriter_,
1:e65b4db:                         new ClientMessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
1:d506170:                 }
1:d506170:                 long pos = positionX(searchstr, start);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "position(Clob, long)", pos);
1:d506170:                 }
1:d506170:                 return pos;
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:125c328: 
1:69e3d06:     private long positionX(Clob searchstr, long start) throws SqlException {
1:70f7692:         checkForClosedConnection();
1:125c328: 
1:70f7692:         if (start <= 0) {
1:da0b88f:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.INVALID_API_PARAMETER),
1:66527ec:                 start, "start", "Clob.position()");
1:70f7692:         }
1:125c328: 
1:70f7692:         // if the searchstr is longer than the source, no match
1:d6844ab:         long index;
2:125c328:         try {
1:2ef245a:             if (searchstr.length() > sqlLength()) {
1:70f7692:                 return -1;
1:70f7692:             }
1:125c328: 
1:a6f48dd:             //Check if locator support is available for this LOB.
1:a6f48dd:             if (isLocator()) {
1:a6f48dd:                 //Locator support is available. Hence call
1:a6f48dd:                 //CLOBGETPOSITIONFROMLOCATOR to determine the position
1:a6f48dd:                 //of the given Clob inside the LOB.
1:d6844ab:                 index = agent_.connection_.locatorProcedureCall()
1:a6f48dd:                     .clobGetPositionFromLocator(locator_,
1:69e3d06:                         ((ClientClob)searchstr).getLocator(),
1:a6f48dd:                         start);
1:a6f48dd:             } else {
1:a6f48dd:                 //Locator support is not available.
1:a6f48dd:                 index = string_.indexOf(searchstr.getSubString(1L,
1:a6f48dd:                                                     (int) searchstr.length()),
1:a6f48dd:                                         (int) start - 1);
1:d6844ab:                 //increase the index by one since String positions are
1:d6844ab:                 //0-based and Clob positions are 1-based
1:d6844ab:                 if (index != -1) {
1:d6844ab:                     index++;
1:d6844ab:                 }
1:a6f48dd:             }
1:69e3d06:         } catch (SQLException e) {
1:e6936ea:             throw new SqlException(e);
1:70f7692:         }
1:d6844ab:         return index;
1:70f7692:     }
1:125c328: 
1:33776ff:     //---------------------------- jdbc 3.0 -----------------------------------
1:125c328: 
1:d506170:     public int setString(long pos, String str) throws SQLException {
1:da0b88f: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:da0b88f: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setString", (int) pos, str);
1:d506170:                 }
1:d506170:                 int length = setStringX(pos, str, 0, str.length());
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "setString", length);
1:d506170:                 }
1:d506170:                 return length;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:125c328: 
1:d506170:     public int setString(long pos, String str, int offset, int len) throws SQLException {
1:da0b88f: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:da0b88f: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setString", (int) pos, str, offset, len);
1:d506170:                 }
1:d506170:                 int length = setStringX(pos, str, offset, len);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "setString", length);
1:d506170:                 }
1:d506170:                 return length;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:125c328: 
1:0326967:     int setStringX(long pos, String str, int offset, int len)
1:0326967:             throws SqlException {
1:e6936ea:         if ((int) pos <= 0 ) {
1:da0b88f:             throw new SqlException(agent_.logWriter_,
1:66527ec:                 new ClientMessageId(SQLState.BLOB_BAD_POSITION), pos);
1:e6936ea:         }
1:2ef245a:         if ( pos - 1 > sqlLength()) {
1:da0b88f:             throw new SqlException(agent_.logWriter_,
1:66527ec:                 new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), pos);
1:70f7692:         }
1:125c328:         
1:1e5b2aa:         if (str == null) {
1:1e5b2aa:             throw new SqlException(agent_.logWriter_,
1:1e5b2aa:                     new ClientMessageId(
1:1e5b2aa:                             SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
1:1e5b2aa:         }
1:1e5b2aa:         
1:1e5b2aa:         if (str.length() == 0) {
1:1e5b2aa:             return 0;
1:1e5b2aa:         }
1:1e5b2aa:         
1:1e5b2aa:         if ((offset < 0) || offset >= str.length() ) {
1:da0b88f:             throw new SqlException(agent_.logWriter_,
1:66527ec:                 new ClientMessageId(SQLState.BLOB_INVALID_OFFSET), offset);
1:70f7692:         }
1:125c328: 
1:e6936ea:         if ( len < 0 ) {
1:da0b88f:             throw new SqlException(agent_.logWriter_,
1:66527ec:                 new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH), len);
1:e6936ea:         }
1:da0b88f:         
1:1e5b2aa:         if (offset + len > str.length()) {
1:1e5b2aa:             throw new SqlException(agent_.logWriter_,
1:1e5b2aa:                     new ClientMessageId(
1:1e5b2aa:                             SQLState.LANG_SUBSTR_START_ADDING_LEN_OUT_OF_RANGE),
1:66527ec:                     offset, len, str);
1:1e5b2aa:         }
1:125c328: 
1:70f7692:         if (len == 0) {
1:70f7692:             return 0;
1:70f7692:         }
1:125c328: 
1:70f7692:         int length = 0;
1:70f7692:         length = Math.min((str.length() - offset), len);
1:61aec23:         //check if the Clob object is locator enabled
1:61aec23:         if (isLocator()) {
1:61aec23:             //The Clob is locator enabled. Call the CLOBSETSTRING
1:61aec23:             //stored procedure to set the given string in the Clob.
1:61aec23:             agent_.connection_.locatorProcedureCall().clobSetString
1:61aec23:                 (locator_, pos, length, str.substring(offset, offset + length));
1:61aec23:             if (pos+length-1 > sqlLength()) { // Wrote beyond the old end
1:61aec23:                 // Update length
1:61aec23:                 setSqlLength(pos + length - 1);
1:61aec23:             }
1:a8908bd:             //The Clob value has been
1:a8908bd:             //updated. Increment the
1:a8908bd:             //update count.
1:a8908bd:             incrementUpdateCount();
1:61aec23:         }
1:61aec23:         else {
1:61aec23:             //The Clob is not locator enabled.
1:c784df5:             reInitForNonLocator(
1:c784df5:                 string_.substring(0, (int) pos - 1)
1:c784df5:                     .concat(str.substring(offset, offset + length)));
1:70f7692:         }
3:70f7692:         return length;
1:70f7692:     }
1:125c328: 
1:69e3d06:     public OutputStream setAsciiStream(long pos) throws SQLException {
1:a4846de: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:a4846de: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
2:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setAsciiStream", (int) pos);
1:d506170:                 }
1:69e3d06:                 OutputStream outStream = null;
1:da0b88f: 
1:61aec23:                 if(isLocator()) { // Check to see if the Lob is locator enabled
1:61aec23:                     //The Lob is locator enabled. Return an instance of the
1:61aec23:                     //Locator enabled Clob specific OutputStream implementation.
1:61aec23:                     outStream = new ClobLocatorOutputStream
1:0326967:                             (this, pos);
1:61aec23:                 }
1:61aec23:                 else {
1:61aec23:                     //The Lob is not locator enabled.
1:da0b88f:                     outStream = new
1:61aec23:                             ClobOutputStream(this, pos);
1:61aec23:                 }
1:61aec23:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "setAsciiStream", outStream);
1:d506170:                 }
1:d506170:                 return outStream;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:fefd864: 
1:69e3d06:     public Writer setCharacterStream(long pos) throws SQLException {
1:fefd864: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:fefd864: 
2:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setCharacterStream", (int) pos);
1:d506170:                 }
1:69e3d06:                 Writer writer = null;
1:61aec23:                 //Check to see if this Clob is locator enabled.
1:61aec23:                 if (isLocator()) {
1:61aec23:                     //return an instance of the locator enabled implementation
1:61aec23:                     //of the writer interface
1:61aec23:                     writer = new ClobLocatorWriter(agent_.connection_, this, pos);
1:61aec23:                 }
1:61aec23:                 else {//The Lob is not locator enabled.
1:61aec23:                     writer = new ClobWriter(this, pos);
1:61aec23:                 }
1:fefd864: 
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "setCharacterStream", writer);
1:d506170:                 }
1:d506170:                 return writer;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:fefd864: 
1:d506170:     public void truncate(long len) throws SQLException {
1:da0b88f: 
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:da0b88f: 
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, " truncate", (int) len);
1:d506170:                 }
1:e6936ea:                 if (len < 0 ) {
1:956354d:                     throw new SqlException(agent_.logWriter_,
1:e65b4db:                         new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
1:66527ec:                         len);
1:e6936ea:                 }
1:fefd864: 
1:2ef245a:                 if ( len > sqlLength()) {
1:da0b88f:                     throw new SqlException(agent_.logWriter_,
1:e65b4db:                         new ClientMessageId(SQLState.BLOB_LENGTH_TOO_LONG),
1:66527ec:                         len);
1:d506170:                 }
1:da0b88f: 
1:2ef245a:                 if (len == sqlLength()) {
1:d506170:                     return;
1:d506170:                 }
1:da0b88f: 
1:61aec23:                 //check whether the Lob is locator enabled.
1:61aec23:                 if (isLocator()) {
1:61aec23:                     //The Lob is locator enabled then call the stored
1:61aec23:                     //procedure CLOBTRUNCATE to truncate this Lob.
1:61aec23:                     agent_.connection_.locatorProcedureCall().
1:61aec23:                             clobTruncate(locator_, len);
1:a63282c:                     // The Clob value has been modified.
1:a63282c:                     // Increment the update count and update the length.
1:a8908bd:                     incrementUpdateCount();
1:a63282c:                     setSqlLength(len);
1:61aec23:                 }
1:61aec23:                 else {
1:61aec23:                     //The Lob is not locator enabled.
1:c784df5:                     reInitForNonLocator(string_.substring(0, (int) len));
1:d506170:                 }
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:fefd864: 
1:a4846de:     //---------------------------- jdbc 4.0 -------------------------------------
1:956354d:     /**
1:125c328:      * This method frees the <code>Clob</code> object and releases the resources the resources
1:125c328:      * that it holds.  The object is invalid once the <code>free</code> method
1:125c328:      * is called. If <code>free</code> is called multiple times, the
1:125c328:      * subsequent calls to <code>free</code> are treated as a no-op.
1:956354d:      *
1:125c328:      * @throws SQLException if an error occurs releasing
1:125c328:      * the Clob's resources
1:125c328:      */
1:a4846de:     public void free()
1:a4846de:         throws SQLException {
1:da0b88f: 
1:125c328:         //calling free() on a already freed object is treated as a no-op
1:8055511:         if (!isValid_) return;
1:da0b88f: 
1:125c328:         //now that free has been called the Blob object is no longer
1:125c328:         //valid
1:8055511:         isValid_ = false;
1:da0b88f: 
1:da0b88f:         try {
1:da0b88f:             synchronized (agent_.connection_) {
1:da0b88f:                 if (agent_.loggingEnabled()) {
1:da0b88f:                     agent_.logWriter_.traceEntry(this, "free");
1:da0b88f:                 }
1:da0b88f:                 if (isLocator()) {
1:da0b88f:                     agent_.connection_.locatorProcedureCall()
1:da0b88f:                         .clobReleaseLocator(locator_);
1:da0b88f:                 }
1:da0b88f:             }
1:da0b88f:         } catch (SqlException se) {
1:da0b88f:             throw se.getSQLException();
1:da0b88f:         }
1:da0b88f: 
1:125c328:         if(isString()) {
1:125c328:             string_ = null;
1:125c328:             utf8String_ = null;
1:125c328:         }
1:125c328:         if(isAsciiStream()) {
1:61aec23:             try {
1:125c328:                 asciiStream_.close();
1:125c328:             }
1:125c328:             catch(IOException ioe) {
1:125c328:                 throw new SqlException(null, new ClientMessageId(SQLState.IO_ERROR_UPON_LOB_FREE)).getSQLException();
1:125c328:             }
1:125c328:         }
1:125c328:         if(isUnicodeStream()) {
1:125c328:             try {
1:125c328:                 unicodeStream_.close();
1:125c328:             }
1:125c328:             catch(IOException ioe) {
1:125c328:                 throw new SqlException(null, new ClientMessageId(SQLState.IO_ERROR_UPON_LOB_FREE)).getSQLException();
1:125c328:             }
1:125c328:         }
1:125c328:         if(isCharacterStream()) {
1:125c328:             try {
1:125c328:                 characterStream_.close();
1:125c328:             }
1:125c328:             catch(IOException ioe) {
1:125c328:                 throw new SqlException(null, new ClientMessageId(SQLState.IO_ERROR_UPON_LOB_FREE)).getSQLException();
1:125c328:             }
1:125c328:         }
1:125c328:     }
1:125c328: 
1:956354d:     /**
1:c9382f0:      * Returns a <code>Reader</code> object that contains a partial
1:c9382f0:      * <code>Clob</code> value, starting with the character specified by pos,
1:c9382f0:      * which is length characters in length.
1:c9382f0:      *
1:c9382f0:      * @param pos the offset to the first character of the partial value to
1:c9382f0:      * be retrieved.  The first character in the Clob is at position 1.
1:c9382f0:      * @param length the length in characters of the partial value to be
1:c9382f0:      * retrieved.
1:c9382f0:      * @return <code>Reader</code> through which the partial <code>Clob</code>
1:c9382f0:      * value can be read.
1:c9382f0:      * @throws SQLException if pos is less than 1 or if pos is greater than the
1:c9382f0:      * number of
1:418a799:      * characters in the {@code Clob} or if {@code pos + length} is greater than
1:418a799:      * {@code Clob.length() +1}
1:c9382f0:      */
1:a4846de:     public Reader getCharacterStream(long pos, long length)
1:a4846de:         throws SQLException {
1:c9382f0:         //call checkValidity to exit by throwing a SQLException if
1:c9382f0:         //the Clob object has been freed by calling free() on it
1:c9382f0:         checkValidity();
1:c9382f0: 
1:c9382f0:         synchronized (agent_.connection_) {
1:c9382f0:             if (agent_.loggingEnabled()) {
1:c9382f0:                 agent_.logWriter_.traceEntry(this, "getCharacterStream",
1:c9382f0:                     (int) pos, length);
1:c9382f0:             }
1:c9382f0:             checkPosAndLength(pos, length);
1:61aec23:             Reader retVal = null;
1:61aec23:             //check if the Lob is locator enabled.
1:61aec23:             if(isLocator()) {
1:a8908bd:                 //1) The Lob is locator enabled. Return the update
1:a8908bd:                 //   sensitive wrapper that wraps inside it a
1:a8908bd:                 //   locator enabled Clob Reader. The wrapper
1:a8908bd:                 //   watches out for updates to the underlying
1:a8908bd:                 //   Clob.
1:a6f48dd:                 //2) len is the number of characters in the
1:a6f48dd:                 //   stream starting from pos.
1:a6f48dd:                 //3) checkPosAndLength will ensure that pos and
1:a6f48dd:                 //   length fall within the boundaries of the
1:a6f48dd:                 //   Clob object.
1:a6f48dd:                 try {
1:a8908bd:                     retVal = new UpdateSensitiveClobLocatorReader
1:a8908bd:                             (agent_.connection_, this,
1:a8908bd:                             pos, length);
1:a6f48dd:                 }
1:a6f48dd:                 catch(SqlException sqle) {
1:a6f48dd:                     throw sqle.getSQLException();
1:a6f48dd:                 }
1:c9382f0:             }
1:61aec23:             else {
1:61aec23:                 //The Lob is not locator enabled.
1:c9382f0:                 String retVal_str = null;
1:c9382f0:                 try {
1:c9382f0:                     retVal_str = getSubStringX(pos, (int)length);
1:c9382f0:                 }
1:c9382f0:                 catch(SqlException sqle) {
1:c9382f0:                     throw sqle.getSQLException();
1:c9382f0:                 }
1:69e3d06:                 retVal = new StringReader(retVal_str);
1:c9382f0:                 if (agent_.loggingEnabled()) {
1:c9382f0:                     agent_.logWriter_.traceExit(this, "getCharacterStream", retVal);
1:c9382f0:                 }
1:61aec23:             }
1:c9382f0:             return retVal;
1:61aec23:         }
1:61aec23:     }
1:125c328: 
1:70f7692:     //----------------------------helper methods----------------------------------
1:a4846de: 
1:70f7692:     public boolean isString() {
1:70f7692:         return ((dataType_ & STRING) == STRING);
1:125c328:     }
1:fefd864: 
1:70f7692:     public boolean isAsciiStream() {
1:70f7692:         return ((dataType_ & ASCII_STREAM) == ASCII_STREAM);
1:125c328:     }
1:fefd864: 
1:70f7692:     public boolean isCharacterStream() {
1:70f7692:         return ((dataType_ & CHARACTER_STREAM) == CHARACTER_STREAM);
1:a4846de:     }
1:fefd864: 
1:70f7692:     public boolean isUnicodeStream() {
1:70f7692:         return ((dataType_ & UNICODE_STREAM) == UNICODE_STREAM);
1:70f7692:     }
1:fefd864: 
1:69e3d06:     public InputStream getUnicodeStream() {
1:70f7692:         return unicodeStream_;
1:70f7692:     }
1:fefd864: 
1:70f7692:     public String getString() {
1:70f7692:         return string_;
1:70f7692:     }
1:fefd864: 
1:70f7692:     public byte[] getUtf8String() {
1:70f7692:         return utf8String_;
1:70f7692:     }
1:fefd864: 
1:70f7692:     // Return the length of the equivalent UTF-8 string
1:70f7692:     // precondition: string_ is not null and dataType_ includes STRING
1:a0b8943:     public int getUTF8Length() {
1:70f7692:         if (utf8String_ != null) {
2:70f7692:             return utf8String_.length;
1:70f7692:         }
1:f433a64: 
1:a0b8943:         utf8String_ = string_.getBytes(Cursor.UTF_8);
1:a0b8943:         return utf8String_.length;
1:70f7692:     }
1:f433a64: 
1:125c328:     /**
1:c784df5:      * Reinitialize the value of this CLOB.
1:c784df5:      *
1:c784df5:      * This is legacy code, only used when talking to servers that don't
1:c784df5:      * support locators.
1:c784df5:      *
1:c784df5:      * @param newString the new value
1:c784df5:      */
1:c784df5:     // The StringBufferInputStream class is deprecated, but we don't care too
1:c784df5:     // much since this code is only for talking to very old servers. Suppress
1:c784df5:     // the deprecation warnings for now.
1:c784df5:     @SuppressWarnings("deprecation")
1:c784df5:     void reInitForNonLocator(String newString) {
1:c784df5:         string_ = newString;
1:c784df5:         asciiStream_ = new java.io.StringBufferInputStream(string_);
1:c784df5:         unicodeStream_ = new java.io.StringBufferInputStream(string_);
1:69e3d06:         characterStream_ = new StringReader(string_);
1:c784df5:         setSqlLength(string_.length());
1:c784df5:     }
1:e6936ea: 
1:e6936ea: 
1:f433a64:     /**
1:956354d:      * Materialize the stream used for input to the database.
1:2ef245a:      *
1:2ef245a:      * @throws SqlException
1:956354d:      */
1:2ef245a:     protected void materializeStream()
1:956354d:         throws SqlException {
1:da0b88f:         unicodeStream_ = super.materializeStream(isAsciiStream() ?
1:da0b88f:                                                         asciiStream_ :
1:956354d:                                                         unicodeStream_,
1:956354d:                                                  "java.sql.Clob");
1:956354d:         dataType_ = UNICODE_STREAM;
1:61aec23:     }
1:da0b88f: 
1:61aec23:     /*---------------------------------------------------------------------
1:61aec23:       Methods used in the locator implementation.
1:61aec23:      ----------------------------------------------------------------------*/
1:da0b88f: 
1:61aec23:     /**
1:61aec23:      * Get the length in bytes of the <code>Clob</code> value represented by
1:61aec23:      * this locator based <code>Clob</code> object.
1:61aec23:      *
1:61aec23:      * A stored procedure call will be made to get it from the server.
1:69e3d06:      * @throws org.apache.derby.client.am.SqlException
1:61aec23:      * @return length of <code>Clob</code> in bytes
1:61aec23:      */
1:61aec23:     long getLocatorLength() throws SqlException
1:61aec23:     {
1:61aec23:         return agent_.connection_.locatorProcedureCall()
1:61aec23:             .clobGetLength(locator_);
1:61aec23:     }
1:61aec23: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
1:                 Charset charset,
1:         // check for null encoding is needed because the net layer
1:         // will no longer throw an exception if the server didn't specify
1:         // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
1:         // cursor is only required for types which can have mixed or double
1:         // byte ccsids.
1:         if (charset == null) {
1:             throw new SqlException(agent.logWriter_,
1:                 new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
1: 
1:         string_ = new String(unconvertedBytes,
1:                 dataOffset,
1:                 unconvertedBytes.length - dataOffset,
1:                 charset);
1:         setSqlLength(string_.length());
1:         dataType_ |= STRING;
1:                 Charset encoding,
1:                 int length) {
1:         if (encoding.equals(Cursor.ISO_8859_1)) {
1:         } else if (encoding.equals(Cursor.UTF_8)) {
1:         } else if (encoding.equals(Cursor.UTF_16BE)) {
1:             characterStream_ =
1:                     new InputStreamReader(inputStream, Cursor.UTF_16BE);
/////////////////////////////////////////////////////////////////////////
1:     ClientClob(Agent agent, InputStream inputStream, Charset encoding)
1:         if (encoding.equals(Cursor.ISO_8859_1)) {
/////////////////////////////////////////////////////////////////////////
1:     public int getUTF8Length() {
1:         utf8String_ = string_.getBytes(Cursor.UTF_8);
1:         return utf8String_.length;
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), pos);
1:                         length);
1:                         pos);
/////////////////////////////////////////////////////////////////////////
1:                             start);
/////////////////////////////////////////////////////////////////////////
1:                 start, "start", "Clob.position()");
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), start);
/////////////////////////////////////////////////////////////////////////
1:                 start, "start", "Clob.position()");
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.BLOB_BAD_POSITION), pos);
1:                 new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), pos);
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.BLOB_INVALID_OFFSET), offset);
1:                 new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH), len);
1:                     offset, len, str);
/////////////////////////////////////////////////////////////////////////
1:                         len);
1:                         len);
/////////////////////////////////////////////////////////////////////////
0:                 length, Integer.MAX_VALUE);
commit:c784df5
/////////////////////////////////////////////////////////////////////////
1:             reInitForNonLocator(
1:                 string_.substring(0, (int) pos - 1)
1:                     .concat(str.substring(offset, offset + length)));
/////////////////////////////////////////////////////////////////////////
1:                     reInitForNonLocator(string_.substring(0, (int) len));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Reinitialize the value of this CLOB.
1:      *
1:      * This is legacy code, only used when talking to servers that don't
1:      * support locators.
1:      *
1:      * @param newString the new value
1:      */
1:     // The StringBufferInputStream class is deprecated, but we don't care too
1:     // much since this code is only for talking to very old servers. Suppress
1:     // the deprecation warnings for now.
1:     @SuppressWarnings("deprecation")
1:     void reInitForNonLocator(String newString) {
1:         string_ = newString;
1:         asciiStream_ = new java.io.StringBufferInputStream(string_);
1:         unicodeStream_ = new java.io.StringBufferInputStream(string_);
0:         characterStream_ = new java.io.StringReader(string_);
1:         setSqlLength(string_.length());
1:     }
commit:66a9818
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4177c4f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d6844ab
/////////////////////////////////////////////////////////////////////////
1:         long index;
/////////////////////////////////////////////////////////////////////////
1:                 index = agent_.connection_.locatorProcedureCall()
/////////////////////////////////////////////////////////////////////////
1:                 //increase the index by one since String positions are
1:                 //0-based and Clob positions are 1-based
1:                 if (index != -1) {
1:                     index++;
1:                 }
1:         return index;
commit:a6f48dd
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedInputStream;
0: import java.io.BufferedReader;
/////////////////////////////////////////////////////////////////////////
0:             return new BufferedReader
0:                     (new ClobLocatorReader(agent_.connection_, this));
/////////////////////////////////////////////////////////////////////////
0:             return new BufferedInputStream(
0:                     new ClobLocatorInputStream(agent_.connection_,this));
/////////////////////////////////////////////////////////////////////////
1:             //Check if locator support is available for this LOB.
1:             if (isLocator()) {
1:                 //Locator support is available. Hence call
1:                 //CLOBGETPOSITIONFROMLOCATOR to determine the position
1:                 //of the given Clob inside the LOB.
0:                 index = (int)agent_.connection_.locatorProcedureCall()
1:                     .clobGetPositionFromLocator(locator_,
0:                         ((Clob)searchstr).getLocator(),
1:                         start);
1:             } else {
1:                 //Locator support is not available.
1:                 index = string_.indexOf(searchstr.getSubString(1L,
1:                                                     (int) searchstr.length()),
1:                                         (int) start - 1);
1:             }
0:         //When the LOB is locator enabled then
0:         //the stored procedure call returns the
0:         //correct position. There is no need
0:         //to increment by 1
0:         if (index != -1 && !isLocator()) {
/////////////////////////////////////////////////////////////////////////
0:                 //1) The Lob is locator enabled. Return the locator
0:                 //   enabled Implementation of a Clob Reader.
1:                 //2) len is the number of characters in the
1:                 //   stream starting from pos.
1:                 //3) checkPosAndLength will ensure that pos and
1:                 //   length fall within the boundaries of the
1:                 //   Clob object.
1:                 try {
0:                     retVal = new BufferedReader(
0:                             new ClobLocatorReader(agent_.connection_, this,
0:                             pos, length));
1:                 }
1:                 catch(SqlException sqle) {
1:                     throw sqle.getSQLException();
1:                 }
commit:c9382f0
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a <code>Reader</code> object that contains a partial
1:      * <code>Clob</code> value, starting with the character specified by pos,
1:      * which is length characters in length.
1:      *
1:      * @param pos the offset to the first character of the partial value to
1:      * be retrieved.  The first character in the Clob is at position 1.
1:      * @param length the length in characters of the partial value to be
1:      * retrieved.
1:      * @return <code>Reader</code> through which the partial <code>Clob</code>
1:      * value can be read.
1:      * @throws SQLException if pos is less than 1 or if pos is greater than the
1:      * number of
0:      * characters in the <code>Clob</code> or if pos + length is greater than
0:      * the number of
0:      * characters in the <code>Clob</code>
1:      *
0:      * @throws SQLException.
1:      */
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1: 
1:         synchronized (agent_.connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "getCharacterStream",
1:                     (int) pos, length);
1:             }
1:             checkPosAndLength(pos, length);
1:             String retVal_str = null;
1:             try {
1:                 retVal_str = getSubStringX(pos, (int)length);
1:             }
1:             catch(SqlException sqle) {
1:                 throw sqle.getSQLException();
1:             }
0:             Reader retVal = new java.io.StringReader(retVal_str);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "getCharacterStream", retVal);
1:             }
1:             return retVal;
1:         }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     private InputStream asciiStream_ = null;
1:     private InputStream unicodeStream_ = null;
1:     private Reader characterStream_ = null;
1:     private byte[] utf8String_;
/////////////////////////////////////////////////////////////////////////
0:     ClientClob(Agent agent, InputStream inputStream, String encoding)
/////////////////////////////////////////////////////////////////////////
1:     ClientClob(Agent agent, Reader reader, int length) {
/////////////////////////////////////////////////////////////////////////
1:     ClientClob(Agent agent, Reader reader) {
/////////////////////////////////////////////////////////////////////////
1:     int setStringX(long pos, String str, int offset, int len)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                             (this, pos);
/////////////////////////////////////////////////////////////////////////
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.client.am.ClientClob
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.OutputStream;
1: import java.io.StringReader;
0: import java.io.UnsupportedEncodingException;
1: import java.io.Writer;
1: import java.sql.Clob;
1: /**
1:  * This class implements the JDBC {@code java.sql.Clob} interface.
1:  */
1: public class ClientClob extends Lob implements Clob {
/////////////////////////////////////////////////////////////////////////
0:     protected InputStream asciiStream_ = null;
0:     protected InputStream unicodeStream_ = null;
0:     protected Reader characterStream_ = null;
/////////////////////////////////////////////////////////////////////////
1:     public ClientClob(Agent agent, String string) {
/////////////////////////////////////////////////////////////////////////
1:     public ClientClob(Agent agent,
/////////////////////////////////////////////////////////////////////////
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:     public ClientClob(Agent agent,
1:                 InputStream inputStream,
/////////////////////////////////////////////////////////////////////////
0:                     new InputStreamReader(inputStream, "UnicodeBigUnmarked");
0:             } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:      * Create a <code>ClientClob</code> of unknown length with the specified
1:      * Note that a <code>ClientClob</code> created with this constructor is
1:      * made for input to the database only. Do not pass it out to the user!
0:     public ClientClob(Agent agent, InputStream inputStream, String encoding)
/////////////////////////////////////////////////////////////////////////
0:     public ClientClob(Agent agent, Reader reader, int length) {
/////////////////////////////////////////////////////////////////////////
1:      * Create a <code>ClientClob</code> object for a Clob value stored
1:     public ClientClob(Agent agent, int locator)
/////////////////////////////////////////////////////////////////////////
1:      * Create a <code>ClientClob</code> of unknown length.
1:      * Note that a <code>ClientClob</code> created with this constructor is
1:      * made for input to the database only. Do not pass it out to the user!
0:     public ClientClob(Agent agent, Reader reader) {
/////////////////////////////////////////////////////////////////////////
1:     private ClientClob(Agent agent,
/////////////////////////////////////////////////////////////////////////
1:    * designated by this <code>ClientClob</code> object.
/////////////////////////////////////////////////////////////////////////
1:    * @return a <code>String</code> that is the specified substring in the
1:    *         <code>CLOB</code> value designated by this <code>ClientClob</code>
1:    *         object
/////////////////////////////////////////////////////////////////////////
1:     public Reader getCharacterStream() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 Reader retVal = getCharacterStreamX();
/////////////////////////////////////////////////////////////////////////
1:     Reader getCharacterStreamX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:         return new StringReader(string_);
1:     public InputStream getAsciiStream() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 InputStream retVal = getAsciiStreamX();
/////////////////////////////////////////////////////////////////////////
1:     InputStream getAsciiStreamX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:             return new AsciiStream(string_, new StringReader(string_));
/////////////////////////////////////////////////////////////////////////
1:     public long position(Clob searchstr, long start) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     private long positionX(Clob searchstr, long start) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                         ((ClientClob)searchstr).getLocator(),
/////////////////////////////////////////////////////////////////////////
1:         } catch (SQLException e) {
/////////////////////////////////////////////////////////////////////////
1:     public OutputStream setAsciiStream(long pos) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 OutputStream outStream = null;
/////////////////////////////////////////////////////////////////////////
1:     public Writer setCharacterStream(long pos) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 Writer writer = null;
/////////////////////////////////////////////////////////////////////////
1:                 retVal = new StringReader(retVal_str);
/////////////////////////////////////////////////////////////////////////
1:     public InputStream getUnicodeStream() {
/////////////////////////////////////////////////////////////////////////
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
0:     protected ClientClob createClobWrapper(Clob clob) throws SqlException {
0:         Reader rdr;
0:         } catch (SQLException e) {
/////////////////////////////////////////////////////////////////////////
0:         } catch (SQLException e) {
0:         return new ClientClob(this.agent_, rdr, (int) length);
0:                     new InputStreamReader(asciiStream_, "ISO-8859-1");
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:         characterStream_ = new StringReader(string_);
/////////////////////////////////////////////////////////////////////////
1:      * @throws org.apache.derby.client.am.SqlException
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
commit:2ef245a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         setSqlLength(string_.length());
/////////////////////////////////////////////////////////////////////////
0:             setSqlLength(string_.length());
/////////////////////////////////////////////////////////////////////////
1:         setSqlLength(length);
/////////////////////////////////////////////////////////////////////////
1:             setSqlLength(length / 2);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         setSqlLength(length);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 long length = super.sqlLength();
1:                     agent_.logWriter_.traceExit(this, "length", length);
1:                 return length;
/////////////////////////////////////////////////////////////////////////
1:                 if (pos > sqlLength() + 1) {
/////////////////////////////////////////////////////////////////////////
1:     private String getSubStringX(long pos, int length) throws SqlException 
1:     {
1:         checkForClosedConnection();
1:         // actual length is the lesser of the length requested
1:         // and the number of characters available from pos to the end
1:         long actualLength = Math.min(this.sqlLength() - pos + 1, (long) length);
0:         return string_.substring((int) pos - 1, (int) (pos - 1 + actualLength));
/////////////////////////////////////////////////////////////////////////
1:             if (searchstr.length() > sqlLength()) {
0:             index = string_.indexOf(searchstr.getSubString(1L, 
0:                                                       (int) searchstr.length()),
0:                                     (int) start - 1);
/////////////////////////////////////////////////////////////////////////
1:         if ( pos - 1 > sqlLength()) {
/////////////////////////////////////////////////////////////////////////
0:         setSqlLength(string_.length());
/////////////////////////////////////////////////////////////////////////
1:                 if ( len > sqlLength()) {
1:                 if (len == sqlLength()) {
/////////////////////////////////////////////////////////////////////////
0:                 setSqlLength(string_.length());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws SqlException
1:     protected void materializeStream()
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1e5b2aa
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:         
1:         if (str == null) {
1:             throw new SqlException(agent_.logWriter_,
1:                     new ClientMessageId(
1:                             SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
1:         }
1:         
1:         if (str.length() == 0) {
1:             return 0;
1:         }
1:         
1:         if ((offset < 0) || offset >= str.length() ) {
/////////////////////////////////////////////////////////////////////////
1:         
1:         if (offset + len > str.length()) {
1:             throw new SqlException(agent_.logWriter_,
1:                     new ClientMessageId(
1:                             SQLState.LANG_SUBSTR_START_ADDING_LEN_OUT_OF_RANGE),
0:                     new Integer(offset), new Integer(len), str);
1:         }
commit:8055511
/////////////////////////////////////////////////////////////////////////
1:  
1:     
1:     
1:                 
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:         if (!isValid_) return;
1:         isValid_ = false;
/////////////////////////////////////////////////////////////////////////
1: 
commit:c6ed70e
/////////////////////////////////////////////////////////////////////////
0:     java.io.Reader getCharacterStreamX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:     java.io.InputStream getAsciiStreamX() throws SqlException {
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:418a799
/////////////////////////////////////////////////////////////////////////
1:      * characters in the {@code Clob} or if {@code pos + length} is greater than
1:      * {@code Clob.length() +1}
commit:a63282c
/////////////////////////////////////////////////////////////////////////
1:                     // The Clob value has been modified.
1:                     // Increment the update count and update the length.
1:                     setSqlLength(len);
commit:faf6742
/////////////////////////////////////////////////////////////////////////
1:     //"ISO-8859-1", "UTF-8", or "UnicodeBigUnmarked"
/////////////////////////////////////////////////////////////////////////
0:         if (encoding.equals("ISO-8859-1")) {
/////////////////////////////////////////////////////////////////////////
1:      * @param encoding encoding to use for characters. Only "ISO-8859-1" is
/////////////////////////////////////////////////////////////////////////
0:         if (encoding.equals("ISO-8859-1")) {
/////////////////////////////////////////////////////////////////////////
0:                     new java.io.InputStreamReader(asciiStream_, "ISO-8859-1");
0:                 "ISO-8859-1", "CharacterStream", e);
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:da0b88f
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_,
1:                     new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:             throw new SqlException(agent_.logWriter_,
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
0:      * Create a <code>Clob</code> object for a Clob value stored
1:      * @param agent context for this <code>Clob</code>
0:     public Clob(Agent agent, int locator)
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:    * which only zero-length substrings can be returned.
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(agent_.logWriter_,
1:                         new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE),
0:                         new Long(pos));
/////////////////////////////////////////////////////////////////////////
0:     private String getSubStringX(long pos, int length) throws SqlException
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(agent_.logWriter_,
1:                     throw new SqlException(agent_.logWriter_,
1:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION),
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
1: 
1:             //Locator support is available. Hence call
1:             //CLOBGETPOSITIONFROMSTRING to determine the position
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(agent_.logWriter_,
0:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION),
1:                     throw new SqlException(agent_.logWriter_,
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.BLOB_BAD_POSITION),
/////////////////////////////////////////////////////////////////////////
0:         if ((offset < 0) || offset > str.length() ) {
1:             throw new SqlException(agent_.logWriter_,
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                     outStream = new
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                     throw new SqlException(agent_.logWriter_,
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         try {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "free");
1:                 }
1:                 if (isLocator()) {
1:                     agent_.connection_.locatorProcedureCall()
1:                         .clobReleaseLocator(locator_);
1:                 }
1:             }
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
0:      * Checks is isValid is true. If it is not true throws
/////////////////////////////////////////////////////////////////////////
1:         unicodeStream_ = super.materializeStream(isAsciiStream() ?
1:                                                         asciiStream_ :
1: 
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a8908bd
/////////////////////////////////////////////////////////////////////////
1:             //The Lob is locator enabled. Return an instance of the
1:             //update sensitive Reader that wraps inside it a
1:             //Buffered Locator Reader. The wrapper class
1:             //watches out for updates.
1:             return new UpdateSensitiveClobLocatorReader
1:                     (agent_.connection_, this);
/////////////////////////////////////////////////////////////////////////
1:             //of the update sensitive wrappers that wrap inside
1:             //it a Buffered Locator enabled InputStream. The
1:             //wrapper watches out for updates to the underlying
1:             //Clob.
1:             return new UpdateSensitiveClobLocatorInputStream
1:                     (agent_.connection_,this);
/////////////////////////////////////////////////////////////////////////
1:             //The Clob value has been
1:             //updated. Increment the
1:             //update count.
1:             incrementUpdateCount();
/////////////////////////////////////////////////////////////////////////
0:                     //The Clob value has been
0:                     //modified. Increment the
0:                     //update count.
1:                     incrementUpdateCount();
/////////////////////////////////////////////////////////////////////////
1:                 //1) The Lob is locator enabled. Return the update
1:                 //   sensitive wrapper that wraps inside it a
1:                 //   locator enabled Clob Reader. The wrapper
1:                 //   watches out for updates to the underlying
1:                 //   Clob.
1:                     retVal = new UpdateSensitiveClobLocatorReader
1:                             (agent_.connection_, this,
1:                             pos, length);
commit:61aec23
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Create a <code>Clob</code> object for a Clob value stored 
1:      * on the server and indentified by <code>locator</code>.
0:      * @param agent context for this <code>Clob</code> 
1:      *              object (incl. connection).
1:      * @param locator reference id to <code>Clob</code> value on server.
1:      */
0:     public Clob(Agent agent, int locator)  
1:     {
1:         super(agent, false);
1:         locator_ = locator;
1:         dataType_ |= LOCATOR;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         //Check to see if the Clob object is locator enabled.
1:         if (isLocator()) {
1:             //The Clob object is locator enabled. Hence call the stored
1:             //procedure CLOBGETLENGTH to determine the length of the Clob.
1:             return agent_.connection_.locatorProcedureCall()
1:                 .clobGetSubString(locator_, pos, (int)actualLength);
1:         }
1:         else {
1:             //The Clob object is not locator enabled.
1:             return string_.substring
1:                     ((int) pos - 1, (int) (pos - 1 + actualLength));
1:         }
/////////////////////////////////////////////////////////////////////////
1:         //check is this Lob is locator enabled
1:         if (isLocator()) {
0:             //The Lob is locator enabled. Return an instance of the Locator
0:             //enabled Writer implementation
0:             return new ClobLocatorReader(agent_.connection_, this);
1:         }
1:         else if (isCharacterStream())  // this Lob is used for input
/////////////////////////////////////////////////////////////////////////
1:         else if(isLocator()) { // Check to see if this Lob is locator enabled
1:             //The Lob is locator enabled. Return an instance
0:             //of the Locator enabled Clob specific InputStream
0:             //implementation.
0:             return new ClobLocatorInputStream(agent_.connection_,this);
1:         }
1:         else {
0:             return new AsciiStream(string_, new java.io.StringReader(string_));
1:         }
/////////////////////////////////////////////////////////////////////////
1:         long index = -1;
1:         
1:         //Check is locator support is available for this LOB.
1:         if (isLocator()) {
0:             //Locator support is available. Hence call 
0:             //CLOBGETPOSITIONFROMSTRING to determine the position 
1:             //of the given substring inside the LOB.
1:             index = agent_.connection_.locatorProcedureCall()
1:                 .clobGetPositionFromString(locator_, searchstr, start);
1:         } else {
1:             //Locator support is not available.
1:             index = string_.indexOf(searchstr, (int) start - 1);
1:             if (index != -1) {
1:                 index++; // api index starts at 1
1:             }
1:         return index;
/////////////////////////////////////////////////////////////////////////
1:         //check if the Clob object is locator enabled
1:         if (isLocator()) {
1:             //The Clob is locator enabled. Call the CLOBSETSTRING
1:             //stored procedure to set the given string in the Clob.
1:             agent_.connection_.locatorProcedureCall().clobSetString
1:                 (locator_, pos, length, str.substring(offset, offset + length));
1:             if (pos+length-1 > sqlLength()) { // Wrote beyond the old end
1:                 // Update length
1:                 setSqlLength(pos + length - 1);
1:             }
1:         }
1:         else {
1:             //The Clob is not locator enabled.
0:             String newString = string_.substring(0, (int) pos - 1);
0:             string_ = newString.concat(str.substring(offset, offset + length));
0:             asciiStream_ = new java.io.StringBufferInputStream(string_);
0:             unicodeStream_ = new java.io.StringBufferInputStream(string_);
0:             characterStream_ = new java.io.StringReader(string_);
0:             setSqlLength(string_.length());
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 java.io.OutputStream outStream = null;
1:                 
1:                 if(isLocator()) { // Check to see if the Lob is locator enabled
1:                     //The Lob is locator enabled. Return an instance of the
1:                     //Locator enabled Clob specific OutputStream implementation.
1:                     outStream = new ClobLocatorOutputStream
0:                             (agent_.connection_, this, pos);
1:                 }
1:                 else {
1:                     //The Lob is not locator enabled.
0:                     outStream = new 
1:                             ClobOutputStream(this, pos);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 java.io.Writer writer = null;
1:                 //Check to see if this Clob is locator enabled.
1:                 if (isLocator()) {
1:                     //return an instance of the locator enabled implementation
1:                     //of the writer interface
1:                     writer = new ClobLocatorWriter(agent_.connection_, this, pos);
1:                 }
1:                 else {//The Lob is not locator enabled.
1:                     writer = new ClobWriter(this, pos);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 
1:                 //check whether the Lob is locator enabled.
1:                 if (isLocator()) {
1:                     //The Lob is locator enabled then call the stored
1:                     //procedure CLOBTRUNCATE to truncate this Lob.
1:                     agent_.connection_.locatorProcedureCall().
1:                             clobTruncate(locator_, len);
1:                 }
1:                 else {
1:                     //The Lob is not locator enabled.
0:                     String newstr = string_.substring(0, (int) len);
0:                     string_ = newstr;
0:                     asciiStream_ = new java.io.StringBufferInputStream(string_);
0:                     unicodeStream_ = new java.io.StringBufferInputStream(string_);
0:                     characterStream_ = new java.io.StringReader(string_);
0:                     setSqlLength(string_.length());
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             Reader retVal = null;
1:             //check if the Lob is locator enabled.
1:             if(isLocator()) {
0:                 //The Lob is locator enabled. Return the locator enabled
0:                 //Implementation of a Clob Reader.
0:                 retVal = new ClobLocatorReader(agent_.connection_, this, 
0:                         pos, length);
1:             else {
1:                 //The Lob is not locator enabled.
0:                 String retVal_str = null;
1:                 try {
0:                     retVal_str = getSubStringX(pos, (int)length);
1:                 }
0:                 catch(SqlException sqle) {
0:                     throw sqle.getSQLException();
1:                 }
0:                 retVal = new java.io.StringReader(retVal_str);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getCharacterStream", retVal);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     /*---------------------------------------------------------------------
1:       Methods used in the locator implementation.
1:      ----------------------------------------------------------------------*/
1:     
1:     /**
1:      * Get the length in bytes of the <code>Clob</code> value represented by
1:      * this locator based <code>Clob</code> object.
1:      *
1:      * A stored procedure call will be made to get it from the server.
0:      * @throws org.apache.derby.client.am.SqlException
1:      * @return length of <code>Clob</code> in bytes
1:      */
1:     long getLocatorLength() throws SqlException
1:     {
1:         return agent_.connection_.locatorProcedureCall()
1:             .clobGetLength(locator_);
1:     }
commit:956354d
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStream;
1: import org.apache.derby.client.net.EncodedInputStream;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Create a <code>Clob</code> of unknown length with the specified
1:      * encoding.
1:      *
1:      * This constructor was added to support the JDBC 4 length less overloads.
0:      * Note that a <code>Clob</code> created with this constructor is made for
0:      * input to the database only. Do not pass it out to the user!
1:      *
1:      * @param agent
1:      * @param inputStream the data to insert
0:      * @param encoding encoding to use for characters. Only "US-ASCII" is
1:      *      allowed.
1:      */
0:     public Clob(Agent agent, java.io.InputStream inputStream, String encoding)
1:             throws SqlException {
0:         this(agent);
1: 
0:         lengthObtained_ = false;
1: 
0:         if (encoding.equals("US-ASCII")) {
1:             asciiStream_ = inputStream;
1:             dataType_ |= ASCII_STREAM;
1:         } else {
1:             throw new SqlException(agent_.logWriter_, 
0:                 new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
1:                 encoding + " InputStream", "String/Clob");
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Create a <code>Clob</code> of unknown length.
1:      *
1:      * This constructor was added to support the JDBC 4 length less overloads.
0:      * Note that a <code>Clob</code> created with this constructor is made for
0:      * input to the database only. Do not pass it out to the user!
1:      *
1:      * @param agent
1:      * @param reader the data to insert
1:      */
0:     public Clob(Agent agent, Reader reader) {
0:         this(agent);
0:         lengthObtained_ = false;
1:         // Wrap reader in stream to share code.
1:         unicodeStream_ = EncodedInputStream.createUTF8Stream(reader);
1:         // Override type to share logic with the other stream types.
1:         dataType_ |= UNICODE_STREAM;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 materializeStream();
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Materialize the stream used for input to the database.
1:      */
0:     private void materializeStream()
1:         throws SqlException {
0:         unicodeStream_ = super.materializeStream(isAsciiStream() ? 
0:                                                         asciiStream_ : 
1:                                                         unicodeStream_,
1:                                                  "java.sql.Clob");
1:         dataType_ = UNICODE_STREAM;
1:     }
commit:125c328
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1:     
0:     //This boolean variable indicates whether the Clob object has
0:     //been invalidated by calling free() on it
0:     private boolean isValid = true;
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This method frees the <code>Clob</code> object and releases the resources the resources
1:      * that it holds.  The object is invalid once the <code>free</code> method
1:      * is called. If <code>free</code> is called multiple times, the
1:      * subsequent calls to <code>free</code> are treated as a no-op.
0:      *
1:      * @throws SQLException if an error occurs releasing
1:      * the Clob's resources
1:      */
1:         
1:         //calling free() on a already freed object is treated as a no-op
0:         if (!isValid) return;
1:         
1:         //now that free has been called the Blob object is no longer
1:         //valid
0:         isValid = false;
1:         
1:         if(isString()) {
1:             string_ = null;
1:             utf8String_ = null;
1:         }
1:         if(isAsciiStream()) {
1:             try {
1:                 asciiStream_.close();
1:             }
1:             catch(IOException ioe) {
1:                 throw new SqlException(null, new ClientMessageId(SQLState.IO_ERROR_UPON_LOB_FREE)).getSQLException();
1:             }
1:         }
1:         if(isUnicodeStream()) {
1:             try {
1:                 unicodeStream_.close();
1:             }
1:             catch(IOException ioe) {
1:                 throw new SqlException(null, new ClientMessageId(SQLState.IO_ERROR_UPON_LOB_FREE)).getSQLException();
1:             }
1:         }
1:         if(isCharacterStream()) {
1:             try {
1:                 characterStream_.close();
1:             }
1:             catch(IOException ioe) {
1:                 throw new SqlException(null, new ClientMessageId(SQLState.IO_ERROR_UPON_LOB_FREE)).getSQLException();
1:             }
1:         }
1:         
0:         lengthInBytes_ = 0;
1:         
0:         if (internalLengthStmt_ != null) {
1:             try {
0:                 internalLengthStmt_.closeX();
1:             }
0:             catch(SqlException sqle) {
0:                 throw sqle.getSQLException();
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*
0:      * Checks is isValid is true. If it is not true throws 
0:      * a SQLException stating that a method has been called on
0:      * an invalid LOB object
0:      *
0:      * throws SQLException if isvalid is not true.
1:      */
0:     private void checkValidity() throws SQLException{
0:         if(!isValid)
0:             throw new SqlException(null,new ClientMessageId(SQLState.LOB_OBJECT_INVALID))
0:                                                   .getSQLException();
1:     }
commit:a4846de
/////////////////////////////////////////////////////////////////////////
1: import java.io.Reader;
1: 
/////////////////////////////////////////////////////////////////////////
1:     //---------------------------- jdbc 4.0 -------------------------------------
1: 
1:     public void free()
1:         throws SQLException {
0:         throw SQLExceptionFactory.notImplemented("free()");
1:     }
1: 
1:     public Reader getCharacterStream(long pos, long length)
1:         throws SQLException {
0:         throw SQLExceptionFactory.notImplemented(
0:                 "getCharacterStream(long,long");
1:     }
1:     
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:fefd864
/////////////////////////////////////////////////////////////////////////
1:     
1:         
1:         this(agent,
1:              false);
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         this(agent,
1:              false);
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         this(agent,
1:              false);
/////////////////////////////////////////////////////////////////////////
1:         
1:         this(agent,
1:              isLayerBStreamingPossible( agent ));
1:         
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         this(agent,
1:              false);
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         this(agent,
1:              isLayerBStreamingPossible( agent ) );
1:         
/////////////////////////////////////////////////////////////////////////
0:     private Clob(Agent agent,
1:                  boolean willBeLayerBStreamed) {
1:         super(agent,
1:               willBeLayerBStreamed);
/////////////////////////////////////////////////////////////////////////
1: 
0:                 if( willBeLayerBStreamed() )
0:                     throw new SqlException(agent_.logWriter_,
0:                                            LOB_OBJECT_LENGTH_UNKNOWN_YET);
1:                 
/////////////////////////////////////////////////////////////////////////
1:     
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f433a64
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Returns a copy of the specified substring
1:    * in the <code>CLOB</code> value
0:    * designated by this <code>Clob</code> object.
1:    * The substring begins at position
1:    * <code>pos</code> and has up to <code>length</code> consecutive
1:    * characters. The starting position must be between 1 and the length
1:    * of the CLOB plus 1. This allows for zero-length CLOB values, from
0:    * which only zero-length substrings can be returned. 
1:    * If a larger length is requested than there are characters available,
1:    * characters to the end of the CLOB are returned.
1:    * @param pos the first character of the substring to be extracted.
1:    *            The first character is at position 1.
1:    * @param length the number of consecutive characters to be copied
0:    * @return a <code>String</code> that is the specified substring in
0:    *         the <code>CLOB</code> value designated by this <code>Clob</code> object
1:    * @exception SQLException if there is an error accessing the
1:    * <code>CLOB</code>
1: 
1:    * NOTE: If the starting position is the length of the CLOB plus 1,
1:    * zero characters are returned regardless of the length requested.
1:    */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if (pos > this.length() + 1) {
0:                     throw new SqlException(agent_.logWriter_, 
0:                         new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), 
0:                         new Long(pos));                    
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             // actual length is the lesser of the length requested
0:             // and the number of characters available from pos to the end
/////////////////////////////////////////////////////////////////////////
1:                 if (start < 1) {
0:                     throw new SqlException(agent_.logWriter_, 
0:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), 
0:                             new Long(start));
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (start < 1) {
0:                     throw new SqlException(agent_.logWriter_, 
0:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), 
0:                             new Long(start));
1:                 }
1: 
commit:b2a1747
/////////////////////////////////////////////////////////////////////////
0:             throw SqlException.javaException(agent_.logWriter_, e);
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION),
1:                         new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.INVALID_API_PARAMETER),
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.INVALID_API_PARAMETER),
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.BLOB_BAD_POSITION), 
0:                 new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE),
0:                 new ClientMessageId(SQLState.BLOB_INVALID_OFFSET),
1:                 new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
1:                         new ClientMessageId(SQLState.BLOB_LENGTH_TOO_LONG),
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.BLOB_TOO_LARGE_FOR_CLIENT),
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.UNSUPPORTED_ENCODING), 
commit:e6936ea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
0:                     new MessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                 "byte[]", charsetName + " String", e);
1:                 
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.UNSUPPORTED_ENCODING), 
0:                     "UnicodeBigUnmarked", "InputStreamReader", e);
/////////////////////////////////////////////////////////////////////////
1:                 if ( pos <= 0 ) {
0:                     throw new SqlException(agent_.logWriter_,
0:                         new MessageId(SQLState.BLOB_BAD_POSITION),
0:                         new Long(pos));
1:                 }
1:                 
1:                 if ( length < 0 ) {
0:                     throw new SqlException(agent_.logWriter_,
0:                         new MessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
0:                         new Integer(length));
/////////////////////////////////////////////////////////////////////////
0:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.INVALID_API_PARAMETER),
0:                 new Long(start), "start", "Clob.position()");
/////////////////////////////////////////////////////////////////////////
0:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.INVALID_API_PARAMETER),
0:                 new Long(start), "start", "Clob.position()");
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(e);
/////////////////////////////////////////////////////////////////////////
1:         if ((int) pos <= 0 ) {
0:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.BLOB_BAD_POSITION), 
0:                 new Long(pos));
0:         if ( pos - 1 > sqlLength_) {
0:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.BLOB_POSITION_TOO_LARGE),
0:                 new Long(pos));
0:         if ((offset < 0) || offset > str.length() ) { 
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.BLOB_INVALID_OFFSET),
0:                 new Integer(offset));
1:         }
0:         
1:         if ( len < 0 ) {
0:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
0:                 new Integer(len));
1:         }
0:         
/////////////////////////////////////////////////////////////////////////
1:                 if (len < 0 ) {
0:                     throw new SqlException(agent_.logWriter_,
0:                         new MessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
0:                         new Long(len));
0:                 
0:                 if ( len > this.length()) {
0:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.BLOB_LENGTH_TOO_LONG),
0:                         new Long(len));
1:                 }
0:                 
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                 "String", "UTF8 byte[]", e);
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(e);
0:         if (length > Integer.MAX_VALUE) {
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.BLOB_TOO_LARGE_FOR_CLIENT),
0:                 new Long(length), new Integer(Integer.MAX_VALUE));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.UNSUPPORTED_ENCODING), 
0:                 "US-ASCII", "CharacterStream", e);
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
0: 
/////////////////////////////////////////////////////////////////////////
1:     public long length() throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "length");
1:                 }
0:                 if (lengthObtained_) {
0:                     return sqlLength_;
1:                 }
0: 
0:                 lengthInBytes_ = super.sqlLength();
0: 
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "length", sqlLength_);
1:                 }
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public String getSubString(long pos, int length) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 String retVal = null;
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getSubString", (int) pos, length);
1:                 }
0: 
0:                 // We can also do a check for pos > length()
0:                 // Defer it till FP7 so that proper testing can be performed on this
0:                 if ((pos <= 0) || (length < 0)) {
0:                     throw new SqlException(agent_.logWriter_, "Invalid position " + pos + " or length " + length);
1:                 }
0: 
1:                 retVal = getSubStringX(pos, length);
0: 
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getSubString", retVal);
1:                 }
1:                 return retVal;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         try
1:         {
1:             checkForClosedConnection();
0:             long actualLength = Math.min(this.length() - pos + 1, (long) length);
0:             return string_.substring((int) pos - 1, (int) (pos - 1 + actualLength));
1:         }
0:         catch ( SQLException se )
1:         {
0:             throw new SqlException(se);
1:         }
0:     public java.io.Reader getCharacterStream() throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getCharacterStream");
1:                 }
0:                 java.io.Reader retVal = getCharacterStreamX();
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getCharacterStream", retVal);
1:                 }
1:                 return retVal;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public java.io.InputStream getAsciiStream() throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getAsciiStream");
1:                 }
0:                 java.io.InputStream retVal = getAsciiStreamX();
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getAsciiStream", retVal);
1:                 }
1:                 return retVal;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public long position(String searchstr, long start) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this,
1:                             "position(String, long)",
1:                             searchstr,
1:                             start);
1:                 }
1:                 if (searchstr == null) {
0:                     throw new SqlException(agent_.logWriter_, "Search string cannot be null.");
1:                 }
1:                 long pos = positionX(searchstr, start);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "position(String, long)", pos);
1:                 }
1:                 return pos;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public long position(java.sql.Clob searchstr, long start) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this,
1:                             "position(Clob, long)",
1:                             searchstr,
1:                             start);
1:                 }
1:                 if (searchstr == null) {
0:                     throw new SqlException(agent_.logWriter_, "Search string cannot be null.");
1:                 }
1:                 long pos = positionX(searchstr, start);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "position(Clob, long)", pos);
1:                 }
1:                 return pos;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public int setString(long pos, String str) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setString", (int) pos, str);
1:                 }
1:                 int length = setStringX(pos, str, 0, str.length());
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "setString", length);
1:                 }
1:                 return length;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public int setString(long pos, String str, int offset, int len) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setString", (int) pos, str, offset, len);
1:                 }
1:                 int length = setStringX(pos, str, offset, len);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "setString", length);
1:                 }
1:                 return length;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public java.io.OutputStream setAsciiStream(long pos) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setAsciiStream", (int) pos);
1:                 }
0:                 ClobOutputStream outStream = new ClobOutputStream(this, pos);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "setAsciiStream", outStream);
1:                 }
1:                 return outStream;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.io.Writer setCharacterStream(long pos) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setCharacterStream", (int) pos);
1:                 }
0:                 ClobWriter writer = new ClobWriter(this, pos);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "setCharacterStream", writer);
1:                 }
1:                 return writer;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public void truncate(long len) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, " truncate", (int) len);
1:                 }
0:                 if (len < 0 || len > this.length()) {
0:                     throw new SqlException(agent_.logWriter_, "Invalid length " + len);
1:                 }
0:                 if (len == this.length()) {
1:                     return;
1:                 }
0:                 String newstr = string_.substring(0, (int) len);
0:                 string_ = newstr;
0:                 asciiStream_ = new java.io.StringBufferInputStream(string_);
0:                 unicodeStream_ = new java.io.StringBufferInputStream(string_);
0:                 characterStream_ = new java.io.StringReader(string_);
0:                 sqlLength_ = string_.length();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public long getByteLength() throws SQLException {
0:             if (lengthObtained_ == true) {
0:                 return lengthInBytes_;
1:             }
0:             length();
0:             return lengthInBytes_;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public class Clob extends Lob implements java.sql.Clob {
1:     //---------------------navigational members-----------------------------------
1:     //-----------------------------state------------------------------------------
1:     protected String string_ = null;
1:     // Only used for input purposes.  For output, each getXXXStream call
1:     // must generate an independent stream.
0:     protected java.io.InputStream asciiStream_ = null;
0:     protected java.io.InputStream unicodeStream_ = null;
0:     protected java.io.Reader characterStream_ = null;
1:     // used for input
1:     // Therefore, we always convert a String to UTF-8 before we flow it for input
0:     protected byte[] utf8String_;
0:     // the length of the clob returned by the LENGTH function.
0:     protected long lengthInBytes_ = 0;
0:     private PreparedStatement internalLengthStmt_ = null;
0:     protected String encoding_ = "UNICODE";
1:     //---------------------constructors/finalizer---------------------------------
0:     public Clob(Agent agent, String string) {
0:         this(agent);
1:         string_ = string;
0:         sqlLength_ = string_.length();
0:         lengthObtained_ = true;
1:         dataType_ |= STRING;
0: 
1:     // CTOR for output, when a btc isn't available; the encoding is
0:     public Clob(Agent agent,
1:                 byte[] unconvertedBytes,
0:                 String charsetName,
1:                 int dataOffset) throws SqlException {
0:         this(agent);
0:         try {
0:             // check for null encoding is needed because the net layer
0:             // will no longer throw an exception if the server didn't specify
0:             // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
0:             // cursor is only required for types which can have mixed or double
0:             // byte ccsids.
0:             if (charsetName == null) {
0:                 throw new SqlException(agent.logWriter_,
0:                         "Required character converter not available for data type.");
1:             }
0: 
0:             string_ = new String(unconvertedBytes,
0:                     dataOffset,
0:                     unconvertedBytes.length - dataOffset,
0:                     charsetName);
0:             sqlLength_ = string_.length();
0:             lengthObtained_ = true;
1:             dataType_ |= STRING;
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e.getMessage());
1:         }
1:     // CTOR for ascii/unicode stream input
0:     //"US-ASCII", "UTF-8", or "UnicodeBigUnmarked"
0:     public Clob(Agent agent,
0:                 java.io.InputStream inputStream,
0:                 String encoding,
0:                 int length) throws SqlException {
0:         this(agent);
0:         sqlLength_ = length;
0:         lengthObtained_ = true;
0:         if (encoding.equals("US-ASCII")) {
1:             asciiStream_ = inputStream;
1:             dataType_ |= ASCII_STREAM;
0:         } else if (encoding.equals("UTF-8")) { // "UTF-8"
1:             unicodeStream_ = inputStream;
1:             dataType_ |= UNICODE_STREAM;
0:         } else if (encoding.equals("UnicodeBigUnmarked")) { // "UnicodeBigUnmarked"
0:             try {
0:                 characterStream_ =
0:                         new java.io.InputStreamReader(inputStream, "UnicodeBigUnmarked");
0:             } catch (java.io.UnsupportedEncodingException e) {
0:                 throw new SqlException(agent_.logWriter_, e.getMessage());
1:             }
1:             dataType_ |= CHARACTER_STREAM;
0:             sqlLength_ = length / 2;
1:         }
0: 
1:     // CTOR for character stream input
1:     // THE ENCODING IS ASSUMED TO BE "UTF-16BE"
0:     public Clob(Agent agent, java.io.Reader reader, int length) {
0:         this(agent);
0:         sqlLength_ = length;
0:         lengthObtained_ = true;
1:         characterStream_ = reader;
1:         dataType_ |= CHARACTER_STREAM;
0: 
0:     private Clob(Agent agent) {
0:         super(agent);
0:     protected void finalize() throws java.lang.Throwable {
0:         super.finalize();
0:         if (internalLengthStmt_ != null) {
0:             internalLengthStmt_.closeX();
1:         }
1:     // ---------------------------jdbc 2------------------------------------------
1:     // Create another method lengthX for internal calls
0:     public long length() throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "length");
1:             }
0:             if (lengthObtained_) {
0:                 return sqlLength_;
1:             }
0:             lengthInBytes_ = super.sqlLength();
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "length", sqlLength_);
1:             }
0:             return sqlLength_;
1:         }
0:     public String getSubString(long pos, int length) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             String retVal = null;
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getSubString", (int) pos, length);
1:             }
0:             // We can also do a check for pos > length()
0:             // Defer it till FP7 so that proper testing can be performed on this
0:             if ((pos <= 0) || (length < 0)) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid position " + pos + " or length " + length);
1:             }
0: 
0:             retVal = getSubStringX(pos, length);
0: 
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getSubString", retVal);
1:             }
0:             return retVal;
1:         }
0:     private String getSubStringX(long pos, int length) throws SqlException {
1:         checkForClosedConnection();
0:         long actualLength = Math.min(this.length() - pos + 1, (long) length);
0:         return string_.substring((int) pos - 1, (int) (pos - 1 + actualLength));
0:     public java.io.Reader getCharacterStream() throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getCharacterStream");
1:             }
0:             java.io.Reader retVal = getCharacterStreamX();
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getCharacterStream", retVal);
1:             }
0:             return retVal;
1:         }
0:     private java.io.Reader getCharacterStreamX() throws SqlException {
1:         checkForClosedConnection();
0:         if (isCharacterStream())  // this Lob is used for input
0:         {
1:             return characterStream_;
1:         }
0:         return new java.io.StringReader(string_);
0: 
0:     public java.io.InputStream getAsciiStream() throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getAsciiStream");
1:             }
0: 
0:             java.io.InputStream retVal = getAsciiStreamX();
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getAsciiStream", retVal);
1:             }
0:             return retVal;
1:         }
1:     }
0: 
0:     private java.io.InputStream getAsciiStreamX() throws SqlException {
1:         checkForClosedConnection();
0: 
1:         if (isAsciiStream())  // this Lob is used for input
0:         {
1:             return asciiStream_;
1:         }
0: 
0:         return new AsciiStream(string_, new java.io.StringReader(string_));
1:     }
0: 
0:     public long position(String searchstr, long start) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this,
0:                         "position(String, long)",
0:                         searchstr,
0:                         start);
1:             }
0:             if (searchstr == null) {
0:                 throw new SqlException(agent_.logWriter_, "Search string cannot be null.");
1:             }
0: 
0:             long pos = positionX(searchstr, start);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "position(String, long)", pos);
1:             }
0:             return pos;
1:         }
1:     }
0: 
1:     private long positionX(String searchstr, long start) throws SqlException {
1:         checkForClosedConnection();
0: 
0: 
1:         if (start <= 0) {
0:             throw new SqlException(agent_.logWriter_, "Clob.position(): start must be >= 1.");
1:         }
0: 
0:         int index = string_.indexOf(searchstr, (int) start - 1);
0:         if (index != -1) {
0:             index++; // api index starts at 1
1:         }
0:         return (long) index;
1:     }
0: 
0:     public long position(java.sql.Clob searchstr, long start) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this,
0:                         "position(Clob, long)",
0:                         searchstr,
0:                         start);
1:             }
0:             if (searchstr == null) {
0:                 throw new SqlException(agent_.logWriter_, "Search string cannot be null.");
1:             }
0:             long pos = positionX(searchstr, start);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "position(Clob, long)", pos);
1:             }
0:             return pos;
1:         }
1:     }
0: 
0:     private long positionX(java.sql.Clob searchstr, long start) throws SqlException {
1:         checkForClosedConnection();
0: 
1:         if (start <= 0) {
0:             throw new SqlException(agent_.logWriter_, "Clob.position(): start must be >= 1.");
1:         }
0: 
1:         // if the searchstr is longer than the source, no match
0:         int index;
0:         try {
0:             if (searchstr.length() > length()) {
1:                 return -1;
1:             }
0: 
0:             index = string_.indexOf(searchstr.getSubString(1L, (int) searchstr.length()), (int) start - 1);
0:         } catch (java.sql.SQLException e) {
0:             throw new SqlException(agent_.logWriter_, e.getMessage());
1:         }
0:         if (index != -1) {
0:             index++; // api index starts at 1
1:         }
0:         return (long) index;
1:     }
0:     public int setString(long pos, String str) throws SqlException {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setString", (int) pos, str);
1:             }
0:             int length = setStringX(pos, str, 0, str.length());
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "setString", length);
1:             }
1:             return length;
0:     public int setString(long pos, String str, int offset, int len) throws SqlException {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setString", (int) pos, str, offset, len);
1:             }
0:             int length = setStringX(pos, str, offset, len);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "setString", length);
1:             }
1:             return length;
0:     public int setStringX(long pos, String str, int offset, int len) throws SqlException {
0:         if ((int) pos <= 0 || pos - 1 > sqlLength_) {
0:             throw new SqlException(agent_.logWriter_, "Invalid position " + pos
0:                     + " , offset " + offset + " or length " + len);
1:         }
0:         if ((offset < 0) || offset > str.length() || len < 0) {
0:             throw new SqlException(agent_.logWriter_, "Invalid position " + pos
0:                     + " , offset " + offset + " or length " + len);
1:         }
1:         if (len == 0) {
1:             return 0;
1:         }
1:         int length = 0;
1:         length = Math.min((str.length() - offset), len);
0:         String newString = string_.substring(0, (int) pos - 1);
0:         string_ = newString.concat(str.substring(offset, offset + length));
0:         asciiStream_ = new java.io.StringBufferInputStream(string_);
0:         unicodeStream_ = new java.io.StringBufferInputStream(string_);
0:         characterStream_ = new java.io.StringReader(string_);
0:         sqlLength_ = string_.length();
1:         return length;
0:     public java.io.OutputStream setAsciiStream(long pos) throws SqlException {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setAsciiStream", (int) pos);
1:             }
0:             ClobOutputStream outStream = new ClobOutputStream(this, pos);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "setAsciiStream", outStream);
1:             }
1:     }
0:     public java.io.Writer setCharacterStream(long pos) throws SqlException {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setCharacterStream", (int) pos);
1:             }
0:             ClobWriter writer = new ClobWriter(this, pos);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "setCharacterStream", writer);
1:             }
1:     }
0:     public void truncate(long len) throws SqlException {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, " truncate", (int) len);
1:             }
0:             if (len < 0 || len > this.length()) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid length " + len);
1:             }
0:             if (len == this.length()) {
0:                 return;
1:             }
0:             String newstr = string_.substring(0, (int) len);
/////////////////////////////////////////////////////////////////////////
1:     //----------------------------helper methods----------------------------------
1:     public boolean isString() {
1:         return ((dataType_ & STRING) == STRING);
1:     public boolean isAsciiStream() {
1:         return ((dataType_ & ASCII_STREAM) == ASCII_STREAM);
1:     public boolean isCharacterStream() {
1:         return ((dataType_ & CHARACTER_STREAM) == CHARACTER_STREAM);
0: 
1:     public boolean isUnicodeStream() {
1:         return ((dataType_ & UNICODE_STREAM) == UNICODE_STREAM);
0:     public java.io.InputStream getUnicodeStream() {
1:         return unicodeStream_;
0:     }
1:     public String getString() {
1:         return string_;
0:     }
0: 
1:     public byte[] getUtf8String() {
1:         return utf8String_;
0:     }
0: 
1:     // Return the length of the equivalent UTF-8 string
1:     // precondition: string_ is not null and dataType_ includes STRING
0:     public int getUTF8Length() throws SqlException {
1:         if (utf8String_ != null) {
1:             return utf8String_.length;
0:         }
0: 
0:         try {
0:             utf8String_ = string_.getBytes("UTF-8");
1:             return utf8String_.length;
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e.getMessage());
0:         }
0:     }
0: 
0:     // auxiliary method for position (Clob, long)
0:     protected Clob createClobWrapper(java.sql.Clob clob) throws SqlException {
0:         long length;
0:         java.io.Reader rdr;
0: 
0:         try {
0:             length = clob.length();
0:         } catch (java.sql.SQLException e) {
0:             throw new SqlException(agent_.logWriter_, e.getMessage());
0:         }
0: 
0:         if (length > java.lang.Integer.MAX_VALUE) {
0:             throw new SqlException(agent_.logWriter_, "searchstr Clob object is too large");
0:         }
0: 
0:         try {
0:             rdr = clob.getCharacterStream();
0:         } catch (java.sql.SQLException e) {
0:             throw new SqlException(agent_.logWriter_, e.getMessage());
0:         }
0: 
0:         return new Clob(this.agent_, rdr, (int) length);
0:     }
0: 
0:     public void convertFromAsciiToCharacterStream() throws SqlException {
0:         try {
0:             characterStream_ =
0:                     new java.io.InputStreamReader(asciiStream_, "US-ASCII");
0:             dataType_ = CHARACTER_STREAM;
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e.getMessage());
0:         }
0:     }
0: 
0:     // this method is primarily for mixed clob length calculations.
0:     // it was introduced to prevent recursion in the actual char length calculation
0:     public long getByteLength() throws SqlException {
0:         if (lengthObtained_ == true) {
0:             return lengthInBytes_;
0:         }
0: 
0:         length();
0:         return lengthInBytes_;
0:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derby.client.am.Clob
0: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0: */
0: 
1: package org.apache.derby.client.am;
0: 
0: public class Clob extends Lob implements java.sql.Clob
0: {
0:   //---------------------navigational members-----------------------------------
0: 
0:   //-----------------------------state------------------------------------------
0:   protected String string_ = null;
0: 
0:   // Only used for input purposes.  For output, each getXXXStream call
0:   // must generate an independent stream.
0:   protected java.io.InputStream asciiStream_ = null;
0:   protected java.io.InputStream unicodeStream_ = null;
0:   protected java.io.Reader characterStream_ = null;
0: 
0:   // used for input
0:   // Therefore, we always convert a String to UTF-8 before we flow it for input
0:   protected byte[] utf8String_;
0: 
0:   // the length of the clob returned by the LENGTH function.
0:   protected long lengthInBytes_ = 0;
0: 
0:   private PreparedStatement internalLengthStmt_ = null;
0: 
0:   protected String encoding_ = "UNICODE";
0: 
0:   //---------------------constructors/finalizer---------------------------------
0:   public Clob(Agent agent, String string)
0:   {
0:     this (agent);
0:     string_ = string;
0:     sqlLength_ = string_.length();
0:     lengthObtained_ = true;
0:     dataType_ |= STRING;
0:   }
0: 
0:   // CTOR for output, when a btc isn't available; the encoding is
0:   public Clob (Agent agent,
0:                byte[] unconvertedBytes,
0:                String charsetName,
0:                int dataOffset) throws SqlException
0:   {
0:     this (agent);
0:     try {
0:       // check for null encoding is needed because the net layer
0:       // will no longer throw an exception if the server didn't specify
0:       // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
0:       // cursor is only required for types which can have mixed or double
0:       // byte ccsids.
0:       if (charsetName == null) {
0:         throw new SqlException (agent.logWriter_,
0:           "Required character converter not available for data type.");
0:       }
0: 
0:       string_ = new  String(unconvertedBytes,
0:                             dataOffset,
0:                             unconvertedBytes.length - dataOffset,
0:                             charsetName);
0:       sqlLength_ = string_.length();
0:       lengthObtained_ = true;
0:       dataType_ |= STRING;
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (agent_.logWriter_, e.getMessage());
0:     }
0:   }
0: 
0:   // CTOR for ascii/unicode stream input
0:   //"US-ASCII", "UTF-8", or "UnicodeBigUnmarked"
0:   public Clob (Agent agent,
0:                java.io.InputStream inputStream,
0:               String encoding,
0:                int length) throws SqlException
0:   {
0:     this (agent);
0: 
0:     sqlLength_ = length;
0:     lengthObtained_ = true;
0: 
0:     if (encoding.equals ("US-ASCII")) {
0:       asciiStream_ = inputStream;
0:       dataType_ |= ASCII_STREAM;
0:     }
0:     else if (encoding.equals ("UTF-8")){ // "UTF-8"
0:       unicodeStream_ = inputStream;
0:       dataType_ |= UNICODE_STREAM;
0:     }
0:     else if (encoding.equals ("UnicodeBigUnmarked")){ // "UnicodeBigUnmarked"
0:       try {
0:         characterStream_ =
0:           new java.io.InputStreamReader(inputStream, "UnicodeBigUnmarked");
0:       }
0:       catch(java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, e.getMessage());
0:       }
0:       dataType_ |= CHARACTER_STREAM;
0:       sqlLength_ = length / 2;
0:     }
0:   }
0: 
0:   // CTOR for character stream input
0:   // THE ENCODING IS ASSUMED TO BE "UTF-16BE"
0:   public Clob(Agent agent, java.io.Reader reader, int length)
0:   {
0:     this (agent);
0:     sqlLength_ = length;
0:     lengthObtained_ = true;
0:     characterStream_ = reader;
0:     dataType_ |= CHARACTER_STREAM;
0:   }
0: 
0:   private Clob(Agent agent)
0:   {
0:     super (agent);
0:   }
0: 
0:   protected void finalize () throws java.lang.Throwable
0:   {
0:     super.finalize();
0:     if (internalLengthStmt_ != null)
0:       internalLengthStmt_.closeX();
0:   }
0: 
0:   // ---------------------------jdbc 2------------------------------------------
0:   // Create another method lengthX for internal calls
0:   public long length() throws SqlException
0:   {
0:     synchronized (agent_.connection_) {
0:       if (agent_.loggingEnabled())
0:         agent_.logWriter_.traceEntry(this, "length");
0: 
0:       if (lengthObtained_)
0:         return sqlLength_;
0: 
0:       lengthInBytes_ = super.sqlLength ();
0: 
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "length", sqlLength_);
0:       return sqlLength_;
0:     }
0:   }
0: 
0:   public String getSubString (long pos, int length) throws SqlException
0:   {
0:     synchronized (agent_.connection_) {
0:       String retVal = null;
0: 
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getSubString", (int) pos, length);
0: 
0:       // We can also do a check for pos > length()
0:       // Defer it till FP7 so that proper testing can be performed on this
0:       if ((pos <= 0) || (length < 0))
0:         throw new SqlException(agent_.logWriter_, "Invalid position " + pos +" or length " + length);
0: 
0:       retVal = getSubStringX (pos, length);
0: 
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getSubString", retVal);
0:       return retVal;
0:     }
0:   }
0: 
0:   private String getSubStringX (long pos, int length) throws SqlException
0:   {
0:     checkForClosedConnection ();
0:     long actualLength = Math.min (this.length() - pos + 1, (long) length);
0:     return string_.substring((int)pos - 1, (int)(pos - 1 + actualLength));
0:   }
0: 
0:   public java.io.Reader getCharacterStream () throws SqlException
0:   {
0:     synchronized (agent_.connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getCharacterStream");
0: 
0:       java.io.Reader retVal = getCharacterStreamX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getCharacterStream", retVal);
0:       return retVal;
0:     }
0:   }
0: 
0:   private java.io.Reader getCharacterStreamX () throws SqlException
0:   {
0:     checkForClosedConnection ();
0: 
0:     if (isCharacterStream ())  // this Lob is used for input
0:       return characterStream_;
0: 
0:     return new java.io.StringReader (string_);
0:   }
0: 
0:   public java.io.InputStream getAsciiStream () throws SqlException
0:   {
0:   	synchronized (agent_.connection_) {
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getAsciiStream");
0: 
0:         java.io.InputStream retVal = getAsciiStreamX();
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getAsciiStream", retVal);
0:         return retVal;
0:   	}
0:   }
0: 
0:   private java.io.InputStream getAsciiStreamX () throws SqlException
0:   {
0:     checkForClosedConnection ();
0: 
0:     if (isAsciiStream ())  // this Lob is used for input
0:       return asciiStream_;
0: 
0:     return new AsciiStream (string_, new java.io.StringReader (string_));
0:   }
0: 
0:   public long position (String searchstr, long start) throws SqlException
0:   {
0:   	synchronized (agent_.connection_) {
0:         if (agent_.loggingEnabled())
0:           agent_.logWriter_.traceEntry(this,
0:                                        "position(String, long)",
0:                                        searchstr,
0:                                        start);
0:         if (searchstr == null)
0:           throw new SqlException(agent_.logWriter_, "Search string cannot be null.");
0: 
0:         long pos = positionX (searchstr, start);
0:         if (agent_.loggingEnabled())
0:           agent_.logWriter_.traceExit(this, "position(String, long)", pos);
0:         return pos;
0:     }
0:   }
0: 
0:   private long positionX (String searchstr, long start) throws SqlException
0:   {
0:     checkForClosedConnection ();
0: 
0: 
0:     if (start <= 0)
0:           throw new SqlException (agent_.logWriter_, "Clob.position(): start must be >= 1.");
0: 
0:     int index = string_.indexOf(searchstr, (int) start - 1);
0:     if (index != -1)
0:       index++; // api index starts at 1
0:     return (long) index;
0:   }
0: 
0:   public long position (java.sql.Clob searchstr, long start) throws SqlException
0:   {
0:   	synchronized (agent_.connection_) {
0:         if (agent_.loggingEnabled())
0:           agent_.logWriter_.traceEntry(this,
0:                                        "position(Clob, long)",
0:                                        searchstr,
0:                                        start);
0:         if (searchstr == null)
0:           throw new SqlException(agent_.logWriter_, "Search string cannot be null.");
0:         long pos = positionX (searchstr, start);
0:         if (agent_.loggingEnabled())
0:           agent_.logWriter_.traceExit(this, "position(Clob, long)", pos);
0:         return pos;
0:     }
0:   }
0: 
0:   private long positionX (java.sql.Clob searchstr, long start) throws SqlException
0:   {
0:     checkForClosedConnection ();
0: 
0:     if (start <= 0)
0:        throw new SqlException (agent_.logWriter_, "Clob.position(): start must be >= 1.");
0: 
0:     // if the searchstr is longer than the source, no match
0:     int index;
0:     try {
0:       if (searchstr.length() > length())
0:         return -1;
0: 
0:       index = string_.indexOf(searchstr.getSubString (1L, (int) searchstr.length()), (int) start -1);
0:     } catch (java.sql.SQLException e) {
0:           throw new SqlException (agent_.logWriter_, e.getMessage());
0:     }
0:     if (index != -1) index++; // api index starts at 1
0:     return (long) index;
0:   }
0: 
1:     //---------------------------- jdbc 3.0 -----------------------------------
0: 
0:     public int setString (long pos, String str) throws SqlException
0:     {
0:         synchronized (agent_.connection_) {
0:           if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setString", (int) pos, str);
0:           int length = setStringX (pos,str, 0,str.length());
0:           if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "setString", length);
0:           return length;
0:         }
0:     }
0: 
0:     public int setString (long pos, String str, int offset, int len) throws SqlException
0:     {
0:         synchronized (agent_.connection_) {
0:           if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setString", (int) pos, str, offset, len);
0:           int length = setStringX (pos, str, offset, len);
0:           if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "setString", length);
0:           return length;
0:         }
0:     }
0: 
0:     public int setStringX (long pos, String str, int offset, int len) throws SqlException
0:     {
0:       if ( (int) pos <= 0 || pos - 1 > sqlLength_)
0:       throw new SqlException(agent_.logWriter_, "Invalid position " + pos
0:                              + " , offset " + offset + " or length " + len);
0:       if ( (offset < 0) || offset > str.length() || len < 0 )
0:       throw new SqlException(agent_.logWriter_, "Invalid position " + pos
0:                              + " , offset " + offset + " or length " + len);
0:     if (len == 0)  return 0;
0: 
0:       int length = 0;
0:       length = Math.min((str.length()  - offset ),len);
0:       String newString = string_.substring(0,(int)pos-1);
0:       string_ = newString.concat(str.substring(offset,offset+length));
0:       asciiStream_ = new java.io.StringBufferInputStream(string_);
0:       unicodeStream_ = new java.io.StringBufferInputStream(string_);
0:       characterStream_ = new java.io.StringReader(string_);
0:       sqlLength_ = string_.length();
0:       return length;
0:     }
0: 
0:     public java.io.OutputStream setAsciiStream (long pos) throws SqlException
0:     {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setAsciiStream", (int) pos);
0:             ClobOutputStream outStream = new ClobOutputStream (this,pos);
0: 
0:             if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "setAsciiStream", outStream);
0:             return outStream;
0:         }
0:       }
0: 
0:     public java.io.Writer setCharacterStream (long pos) throws SqlException
0:     {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setCharacterStream", (int) pos);
0:             ClobWriter writer = new  ClobWriter (this,pos);
0: 
0:             if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "setCharacterStream", writer);
0:             return writer;
0:         }
0:       }
0: 
0:     public void truncate (long len) throws SqlException
0:     {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, " truncate", (int) len);
0:             if (len < 0 || len > this.length())
0:         throw new SqlException(agent_.logWriter_, "Invalid length " + len);
0:             if (len == this.length())
0:               return;
0:             String newstr = string_.substring(0,(int)len);
0:             string_ = newstr;
0:             asciiStream_ = new java.io.StringBufferInputStream(string_);
0:             unicodeStream_ = new java.io.StringBufferInputStream(string_);
0:             characterStream_ = new java.io.StringReader(string_);
0:             sqlLength_ = string_.length();
0:         }
0:     }
0: 
0:   //----------------------------helper methods----------------------------------
0: 
0:   public boolean isString ()
0:   {
0:     return ((dataType_ & STRING) == STRING);
0:   }
0: 
0:   public boolean isAsciiStream ()
0:   {
0:     return ((dataType_ & ASCII_STREAM) == ASCII_STREAM);
0:   }
0: 
0:   public boolean isCharacterStream ()
0:   {
0:     return ((dataType_ & CHARACTER_STREAM) == CHARACTER_STREAM);
0:   }
0: 
0:   public boolean isUnicodeStream ()
0:   {
0:     return ((dataType_ & UNICODE_STREAM) == UNICODE_STREAM);
0:   }
0: 
0:   public java.io.InputStream getUnicodeStream ()
0:   {
0:     return unicodeStream_;
0:   }
0: 
0:   public String getString ()
0:   {
0:     return string_;
0:   }
0: 
0:   public byte[] getUtf8String ()
0:   {
0:     return utf8String_;
0:   }
0: 
0:   // Return the length of the equivalent UTF-8 string
0:   // precondition: string_ is not null and dataType_ includes STRING
0:   public int getUTF8Length () throws SqlException
0:   {
0:     if (utf8String_ != null) return utf8String_.length;
0: 
0:     try {
0:       utf8String_ = string_.getBytes("UTF-8");
0:       return utf8String_.length;
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (agent_.logWriter_, e.getMessage());
0:     }
0:   }
0: 
0:   // auxiliary method for position (Clob, long)
0:   protected Clob createClobWrapper (java.sql.Clob clob) throws SqlException
0:   {
0:     long length;
0:     java.io.Reader rdr;
0: 
0:     try {
0:       length = clob.length();
0:     }
0:     catch (java.sql.SQLException e) {
0:       throw new SqlException (agent_.logWriter_, e.getMessage());
0:     }
0: 
0:     if (length > java.lang.Integer.MAX_VALUE)
0:       throw new SqlException (agent_.logWriter_, "searchstr Clob object is too large");
0: 
0:     try {
0:       rdr = clob.getCharacterStream ();
0:     }
0:     catch (java.sql.SQLException e) {
0:       throw new SqlException (agent_.logWriter_, e.getMessage());
0:     }
0: 
0:     return new Clob (this.agent_, rdr, (int)length);
0:   }
0: 
0:   public void convertFromAsciiToCharacterStream () throws SqlException
0:   {
0:     try {
0:       characterStream_ =
0:         new java.io.InputStreamReader(asciiStream_, "US-ASCII");
0:       dataType_ = CHARACTER_STREAM;
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (agent_.logWriter_, e.getMessage());
0:     }
0:   }
0: 
0:   // this method is primarily for mixed clob length calculations.
0:   // it was introduced to prevent recursion in the actual char length calculation
0:   public long getByteLength () throws SqlException
0:   {
0:     if (lengthObtained_ == true)
0:       return lengthInBytes_;
0: 
0:     length();
0:     return lengthInBytes_;
0:   }
0: }
============================================================================