1:eac0369: /*
1:cd3749b: 
1:cd3749b:    Derby - Class org.apache.derby.iapi.services.cache.ClassSizeCrawler
1:cd3749b: 
1:de243e0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:de243e0:    contributor license agreements.  See the NOTICE file distributed with
1:de243e0:    this work for additional information regarding copyright ownership.
1:de243e0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:de243e0:    (the "License"); you may not use this file except in compliance with
1:de243e0:    the License.  You may obtain a copy of the License at
1:cd3749b: 
1:cd3749b:       http://www.apache.org/licenses/LICENSE-2.0
1:cd3749b: 
1:cd3749b:    Unless required by applicable law or agreed to in writing, software
1:cd3749b:    distributed under the License is distributed on an "AS IS" BASIS,
1:cd3749b:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cd3749b:    See the License for the specific language governing permissions and
1:cd3749b:    limitations under the License.
2:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derbyBuild;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: 
1:eac0369: import java.io.File;
1:eac0369: import java.io.FileWriter;
1:eac0369: import java.io.PrintWriter;
1:eac0369: import java.io.IOException;
1:eac0369: import java.util.Hashtable;
1:eac0369: import java.util.Enumeration;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * This class implements a program that catalogs the size estimate coefficients of various classes.
1:eac0369:  * @see ClassSize#getSizeCoefficients.
1:eac0369:  *<p>
1:eac0369:  * The program is invoked as:
1:eac0369:  *<p>
1:eac0369:  * java -DWS=<i>work-space</i> [-DclassDir=<i>class-dir</i>] [-Dout=<i>out-file</i> [-Dprefix[.<i>x</i>=<i>package-prefix</i>]] [-Dverbose=true] org.apache.derby.iapi.services.cache.ClassSizeCrawler <i>class-or-interface</i> ...<br>
1:eac0369:  *<p>
1:eac0369:  * This program gets the size coefficients for each class in the <i>class-or-interface</i> list,
1:eac0369:  * and for each class that implements an interface in the list. If there is an interface in the list
1:eac0369:  * this program crawls through the classes hierarcy, starting at points specified by the prefix
1:eac0369:  * properties, looking for classes that implement the interfaces.
1:eac0369:  *<p>
1:eac0369:  * If the <i>class-or-interface</i> list is empty then this program searches for implementations
1:eac0369:  * of org.apache.derby.iapi.types.DataValueDescriptor, and at least one prefix property
1:eac0369:  * must be specified
1:eac0369:  *<p>
1:eac0369:  * The catalog is written as a java source file
1:eac0369:  * into <i>out-file</i>, by default
1:8b47bc7:  * <i>work-space</i>/java/org.apache.derby.iapi.services.cache.ClassSizeCatalogImpl.java.
1:eac0369:  *<p>
1:eac0369:  * <i>work-space</i> is the directory containing the java and classes directories. $WS in the
1:eac0369:  * standard development environment. This property is required.
1:eac0369:  *<p>
1:eac0369:  * <i>class-dir</i> is the directory containing the compiled classes. By default it is <i>work-space</i>/classes.
1:eac0369:  *<p>
1:eac0369:  * <i>package-prefix</i> is the first part of a package name. e.g. "com.ibm.db2j.impl". At least
1:eac0369:  * one prefix property must be specified if there is an interface in the list.
1:eac0369:  *<p>
1:eac0369:  * For example:<br>
1:eac0369:  * <pre>
1:eac0369:  * <code>
1:eac0369:  * java -DWS=$WS \
1:eac0369:  *      -Dprefix.1=org.apache.derby.iapi.types \
1:eac0369:  *      org.apache.derby.iapi.services.cache.ClassSizeCrawler \
1:eac0369:  *        org.apache.derby.iapi.types.DataValueDescriptor \
1:eac0369:  *        java.math.BigDecimal \
1:eac0369:  *        org.apache.derby.impl.services.cache.Generic.CachedItem
1:eac0369:  *</code>
1:eac0369:  *</pre>
1:eac0369:  */
1:eac0369: public class ClassSizeCrawler
1:eac0369: {
1:eac0369:     public static void main( String[] arg)
1:eac0369:     {
1:eac0369:         String[] classAndInterfaceList = {"org.apache.derby.iapi.types.DataValueDescriptor"};
1:eac0369:         if(arg.length > 0)
1:eac0369:             classAndInterfaceList = arg;
1:eac0369:         Class[] interfaceList = new Class[classAndInterfaceList.length];
1:eac0369:         int interfaceCount = 0;
1:eac0369:         Class[] classList = new Class[classAndInterfaceList.length];
1:eac0369:         int classCount = 0;
1:eac0369: 
1:eac0369:         Class classSizeClass = ClassSize.class; // Make sure that the garbage collector does not unload it
1:eac0369:         ClassSize.setDummyCatalog();
1:eac0369:         /* Most of the classes we will catalog invoke ClassSize.estimateBaseFromCatalog in
1:eac0369:          * their static initializer. This dummy the catalog out so that this will not generate
1:eac0369:          * errors. We will not actually use the classes, just examine their fields.
1:eac0369:          */
1:eac0369: 
1:eac0369:         for( int i = 0; i < classAndInterfaceList.length; i++)
1:eac0369:         {
1:eac0369:             Class cls = null;
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 cls = Class.forName( classAndInterfaceList[i]);
1:eac0369:             }
1:eac0369:             catch( ClassNotFoundException cnfe)
1:eac0369:             {
1:eac0369:                 System.err.println( "*** Could not find class " + classAndInterfaceList[i]);
1:eac0369:                 System.exit(1);
1:eac0369:             }
1:eac0369:             if( cls.isInterface())
1:eac0369:                 interfaceList[ interfaceCount++] = cls;
1:eac0369:             else
1:eac0369:                 classList[ classCount++] = cls;
1:eac0369:         }
1:eac0369: 
1:eac0369:         String WS = System.getProperty( "WS");
1:eac0369:         if( WS == null)
1:eac0369:         {
1:eac0369:             System.err.println( "*** WS is not set.");
1:eac0369:             System.exit(1);
1:eac0369:         }
1:eac0369: 
1:eac0369:         StringBuffer baseDir = new StringBuffer( System.getProperty( "classDir", ""));
1:eac0369:         if( baseDir.length() == 0)
1:eac0369:         {
1:eac0369:             baseDir.append( WS);
1:eac0369:             baseDir.append( '/');
1:eac0369:             baseDir.append( "classes");
1:eac0369:         }
1:eac0369:         int baseDirLength = baseDir.length();
1:eac0369: 
1:eac0369:         StringBuffer packagePrefix = new StringBuffer( );
1:eac0369: 
1:38b9499:         Hashtable<String, int[]> classSizes = new Hashtable<String, int[]>();
1:eac0369: 
1:eac0369:         ClassSizeCrawler crawler = new ClassSizeCrawler(interfaceList, interfaceCount, classSizes);
1:eac0369: 
1:eac0369:         if( interfaceCount > 0)
1:eac0369:         {
1:eac0369:             boolean gotPrefix = false;
1:eac0369:             // Crawl through the class hierarchies for classes implementing the interfaces
1:eac0369:             for( Enumeration e = System.getProperties().propertyNames();
1:eac0369:                  e.hasMoreElements();)
1:eac0369:             {
1:eac0369:                 String propertyName = (String) e.nextElement();
1:eac0369:                 if( propertyName.equals( "prefix") || propertyName.startsWith( "prefix."))
1:eac0369:                 {
1:eac0369:                     gotPrefix = true;
1:eac0369:                     packagePrefix.setLength( 0);
1:eac0369:                     packagePrefix.append( System.getProperty( propertyName));
1:eac0369:                     baseDir.setLength( baseDirLength);
1:eac0369:                     if( packagePrefix.length() > 0)
1:eac0369:                     {
1:eac0369:                         baseDir.append( '/');
1:eac0369:                         for( int offset = 0; offset < packagePrefix.length(); offset++)
1:eac0369:                         {
1:eac0369:                             char c = packagePrefix.charAt( offset);
1:eac0369:                             if( c == '.')
1:eac0369:                                 baseDir.append( '/');
1:eac0369:                             else
1:eac0369:                                 baseDir.append( c);
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                     crawler.crawl( new File( baseDir.toString()), packagePrefix);
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             if( ! gotPrefix)
1:eac0369:             {
1:eac0369:                 System.err.println( "*** Could not search the class hierarchy because no starting");
1:eac0369:                 System.err.println( "    prefixes where specified.");
1:eac0369:                 System.exit(1);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         for( int i = 0; i < classCount; i++)
1:eac0369:             crawler.addClass( classList[i]);
1:eac0369: 
1:eac0369:         baseDir.setLength( baseDirLength);
1:eac0369:         String outputFileName =
1:8b47bc7:           System.getProperty( "out", WS + "/java/org.apache.derby.iapi.services.cache.ClassSizeCatalogImpl.java");
1:eac0369:         try
1:eac0369:         {
1:eac0369:             PrintWriter out = new PrintWriter( new FileWriter( outputFileName));
1:cd3749b:             out.print( "/*\n\n" +
1:eac0369: 
1:4ecc65a:                        "   Licensed to the Apache Software Foundation (ASF) under one or more\n" +
1:4ecc65a:                        "   contributor license agreements.  See the NOTICE file distributed with\n" +
1:4ecc65a:                        "   this work for additional information regarding copyright ownership.\n" +
1:4ecc65a:                        "   The ASF licenses this file to You under the Apache License, Version 2.0\n" +
1:4ecc65a:                        "   (the \"License\"); you may not use this file except in compliance with\n" +
1:4ecc65a:                        "   the License.  You may obtain a copy of the License at\n" +
1:4ecc65a:                        "\n" +
1:4ecc65a:                        "      http://www.apache.org/licenses/LICENSE-2.0\n" +
1:4ecc65a:                        "\n" +
1:4ecc65a:                        "   Unless required by applicable law or agreed to in writing, software\n" +
1:4ecc65a:                        "   distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
1:4ecc65a:                        "   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
1:4ecc65a:                        "   See the License for the specific language governing permissions and\n" +
1:4ecc65a:                        "   limitations under the License.\n" +
1:eac0369:                        " */\n");
1:eac0369:             out.print( "package org.apache.derby.iapi.services.cache;\n" +
1:8b47bc7:                        "class ClassSizeCatalogImpl extends ClassSizeCatalog\n" +
1:eac0369:                        "{\n" +
1:4469400:                        "    public ClassSizeCatalogImpl()\n" +
1:eac0369:                        "    {\n");
1:eac0369:             for( Enumeration e = classSizes.keys();
1:eac0369:                  e.hasMoreElements();)
1:eac0369:             {
1:eac0369:                 String className = (String) e.nextElement();
1:eac0369:                 int[] coeff = (int[]) classSizes.get( className);
1:eac0369:                 out.print( "        put( \"" + className + "\", new int[]{" + coeff[0] + "," + coeff[1] + "});\n");
1:eac0369:             }
1:eac0369:             out.print("    }\n" +
1:eac0369:                       "}\n");
1:eac0369:             out.flush();
1:eac0369:             out.close();
1:eac0369:         }
1:eac0369:         catch( IOException ioe)
1:eac0369:         {
1:eac0369:             System.err.println( "*** Cannot write to " + outputFileName);
1:eac0369:             System.err.println( "   " + ioe.getMessage());
1:eac0369:             System.exit(1);
1:eac0369:         }
1:eac0369:     } // end of main
1:eac0369: 
1:38b9499:     private Class<?>[] interfaceList; // Search for classes that implement these interfaces
1:eac0369:     private int interfaceCount;
1:38b9499:     private Hashtable<String, int[]> classSizes;
1:eac0369:     private boolean verbose = false;
1:eac0369: 
1:eac0369:     private ClassSizeCrawler( Class[] interfaceList,
1:eac0369:                               int interfaceCount,
1:38b9499:                               Hashtable<String, int[]> classSizes)
1:eac0369:     {
1:eac0369:         this.interfaceList = interfaceList;
1:eac0369:         this.classSizes = classSizes;
1:eac0369:         this.interfaceCount = interfaceCount;
1:ce40a31:         verbose = Boolean.parseBoolean( System.getProperty( "verbose", "false"));
1:eac0369:     }
1:eac0369: 
1:eac0369:     private void crawl( File curDir, StringBuffer className)
1:eac0369:     {
1:eac0369:         if( verbose)
1:eac0369:             System.out.println( "Searching directory " + curDir.getPath());
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if( ! curDir.isDirectory())
1:eac0369:             {
1:eac0369:                 System.err.println( "*** " + curDir.getPath() + " is not a directory.");
1:eac0369:                 System.exit(1);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         catch( SecurityException se)
1:eac0369:         {
1:eac0369:             System.err.println( "Cannot access " + curDir.getPath());
1:eac0369:             System.exit(1);
1:eac0369:         }
1:eac0369:         String[] filenames = curDir.list( );
1:eac0369:         if( className.length() != 0)
1:eac0369:             className.append( ".");
1:eac0369: 
1:eac0369:         int classNameLength = className.length();
1:eac0369:         for( int fileIdx = 0; fileIdx < filenames.length; fileIdx++)
1:eac0369:         {
1:eac0369:             if( filenames[fileIdx].endsWith( ".class"))
1:eac0369:             {
1:eac0369:                 // Strip off the ".class" suffix
1:eac0369:                 String s = filenames[fileIdx].substring( 0, filenames[fileIdx].length() - 6);
1:eac0369:                 className.append( s);
1:38b9499:                 Class<?> targetClass = null;
1:eac0369:                 String targetClassName = className.toString();
1:eac0369:                 try
1:eac0369:                 {
1:eac0369:                     targetClass = Class.forName( targetClassName);
1:eac0369:                     if( !targetClass.isInterface())
1:eac0369:                     {
1:eac0369:                         for( int interfaceIdx = 0; interfaceIdx < interfaceCount; interfaceIdx++)
1:eac0369:                         {
1:eac0369:                             if( interfaceList[interfaceIdx].isAssignableFrom( targetClass))
1:eac0369:                                 addClass( targetClass);
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:                 catch( ClassNotFoundException cnfe)
1:eac0369:                 {
1:eac0369:                     System.err.println( "Could not find class " + targetClassName);
1:eac0369:                     System.exit(1);
1:eac0369:                 }
1:eac0369:                 catch( Throwable t){}
1:eac0369:                 className.setLength( classNameLength);
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 File nextDir = new File( curDir, filenames[fileIdx]);
1:eac0369:                 if( nextDir.isDirectory())
1:eac0369:                 {
1:eac0369:                     className.append( filenames[fileIdx]);
1:eac0369:                     crawl( nextDir, className);
1:eac0369:                     className.setLength( classNameLength);
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:     } // end of crawl
1:eac0369: 
1:eac0369:     private void addClass( Class targetClass)
1:eac0369:     {
1:eac0369:         int[] coefficients = ClassSize.getSizeCoefficients( targetClass);
1:eac0369:         if( verbose)
1:eac0369:             System.out.println( targetClass.getName() + " " + coefficients[0] + ", " + coefficients[1]);
1:eac0369:         classSizes.put( targetClass.getName(), coefficients);
1:eac0369:     } // end of addClass
1:eac0369: } // end of ClassSizeCrawler
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                        "    public ClassSizeCatalogImpl()\n" +
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:         verbose = Boolean.parseBoolean( System.getProperty( "verbose", "false"));
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8b47bc7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * <i>work-space</i>/java/org.apache.derby.iapi.services.cache.ClassSizeCatalogImpl.java.
/////////////////////////////////////////////////////////////////////////
1:           System.getProperty( "out", WS + "/java/org.apache.derby.iapi.services.cache.ClassSizeCatalogImpl.java");
/////////////////////////////////////////////////////////////////////////
1:                        "class ClassSizeCatalogImpl extends ClassSizeCatalog\n" +
0:                        "    ClassSizeCatalogImpl()\n" +
commit:38b9499
/////////////////////////////////////////////////////////////////////////
1:         Hashtable<String, int[]> classSizes = new Hashtable<String, int[]>();
/////////////////////////////////////////////////////////////////////////
1:     private Class<?>[] interfaceList; // Search for classes that implement these interfaces
1:     private Hashtable<String, int[]> classSizes;
1:                               Hashtable<String, int[]> classSizes)
/////////////////////////////////////////////////////////////////////////
1:                 Class<?> targetClass = null;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ea4a56
/////////////////////////////////////////////////////////////////////////
commit:cd3749b
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.cache.ClassSizeCrawler
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
/////////////////////////////////////////////////////////////////////////
1:             out.print( "/*\n\n" +
0:                        "    Copyright " + year + " The Apache Software Foundation or its licensors, as applicable.\n" +
0:                        "    Licensed under the Apache License, Version 2.0 (the \"License\").\n" +
commit:50d75f3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.cache
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyBuild;
1: 
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: 
1: import java.io.File;
1: import java.io.FileWriter;
1: import java.io.PrintWriter;
1: import java.io.IOException;
0: import java.io.FileOutputStream;
0: import java.io.ObjectOutput;
0: import java.io.ObjectOutputStream;
0: import java.lang.SecurityException;
0: import java.lang.ClassNotFoundException;
1: import java.util.Hashtable;
1: import java.util.Enumeration;
0: import java.util.Calendar;
0: import java.util.Date;
1: 
1: /**
1:  * This class implements a program that catalogs the size estimate coefficients of various classes.
1:  * @see ClassSize#getSizeCoefficients.
1:  *<p>
1:  * The program is invoked as:
1:  *<p>
1:  * java -DWS=<i>work-space</i> [-DclassDir=<i>class-dir</i>] [-Dout=<i>out-file</i> [-Dprefix[.<i>x</i>=<i>package-prefix</i>]] [-Dverbose=true] org.apache.derby.iapi.services.cache.ClassSizeCrawler <i>class-or-interface</i> ...<br>
1:  *<p>
1:  * This program gets the size coefficients for each class in the <i>class-or-interface</i> list,
1:  * and for each class that implements an interface in the list. If there is an interface in the list
1:  * this program crawls through the classes hierarcy, starting at points specified by the prefix
1:  * properties, looking for classes that implement the interfaces.
1:  *<p>
1:  * If the <i>class-or-interface</i> list is empty then this program searches for implementations
1:  * of org.apache.derby.iapi.types.DataValueDescriptor, and at least one prefix property
1:  * must be specified
1:  *<p>
1:  * The catalog is written as a java source file
1:  * into <i>out-file</i>, by default
0:  * <i>work-space</i>/java/org.apache.derby.iapi.services.cache.ClassSizeCatalog.java.
1:  *<p>
1:  * <i>work-space</i> is the directory containing the java and classes directories. $WS in the
1:  * standard development environment. This property is required.
1:  *<p>
1:  * <i>class-dir</i> is the directory containing the compiled classes. By default it is <i>work-space</i>/classes.
1:  *<p>
1:  * <i>package-prefix</i> is the first part of a package name. e.g. "com.ibm.db2j.impl". At least
1:  * one prefix property must be specified if there is an interface in the list.
1:  *<p>
1:  * For example:<br>
1:  * <pre>
1:  * <code>
1:  * java -DWS=$WS \
1:  *      -Dprefix.1=org.apache.derby.iapi.types \
1:  *      org.apache.derby.iapi.services.cache.ClassSizeCrawler \
1:  *        org.apache.derby.iapi.types.DataValueDescriptor \
1:  *        java.math.BigDecimal \
1:  *        org.apache.derby.impl.services.cache.Generic.CachedItem
1:  *</code>
1:  *</pre>
1:  */
1: public class ClassSizeCrawler
1: {
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1:     public static void main( String[] arg)
1:     {
1:         String[] classAndInterfaceList = {"org.apache.derby.iapi.types.DataValueDescriptor"};
1:         if(arg.length > 0)
1:             classAndInterfaceList = arg;
1:         Class[] interfaceList = new Class[classAndInterfaceList.length];
1:         int interfaceCount = 0;
1:         Class[] classList = new Class[classAndInterfaceList.length];
1:         int classCount = 0;
1: 
1:         Class classSizeClass = ClassSize.class; // Make sure that the garbage collector does not unload it
1:         ClassSize.setDummyCatalog();
1:         /* Most of the classes we will catalog invoke ClassSize.estimateBaseFromCatalog in
1:          * their static initializer. This dummy the catalog out so that this will not generate
1:          * errors. We will not actually use the classes, just examine their fields.
1:          */
1: 
1:         for( int i = 0; i < classAndInterfaceList.length; i++)
1:         {
1:             Class cls = null;
1:             try
1:             {
1:                 cls = Class.forName( classAndInterfaceList[i]);
1:             }
1:             catch( ClassNotFoundException cnfe)
1:             {
1:                 System.err.println( "*** Could not find class " + classAndInterfaceList[i]);
1:                 System.exit(1);
1:             }
1:             if( cls.isInterface())
1:                 interfaceList[ interfaceCount++] = cls;
1:             else
1:                 classList[ classCount++] = cls;
1:         }
1: 
1:         String WS = System.getProperty( "WS");
1:         if( WS == null)
1:         {
1:             System.err.println( "*** WS is not set.");
1:             System.exit(1);
1:         }
1: 
1:         StringBuffer baseDir = new StringBuffer( System.getProperty( "classDir", ""));
1:         if( baseDir.length() == 0)
1:         {
1:             baseDir.append( WS);
1:             baseDir.append( '/');
1:             baseDir.append( "classes");
1:         }
1:         int baseDirLength = baseDir.length();
1: 
1:         StringBuffer packagePrefix = new StringBuffer( );
1: 
0:         Hashtable classSizes = new Hashtable();
1: 
1:         ClassSizeCrawler crawler = new ClassSizeCrawler(interfaceList, interfaceCount, classSizes);
1: 
1:         if( interfaceCount > 0)
1:         {
1:             boolean gotPrefix = false;
1:             // Crawl through the class hierarchies for classes implementing the interfaces
1:             for( Enumeration e = System.getProperties().propertyNames();
1:                  e.hasMoreElements();)
1:             {
1:                 String propertyName = (String) e.nextElement();
1:                 if( propertyName.equals( "prefix") || propertyName.startsWith( "prefix."))
1:                 {
1:                     gotPrefix = true;
1:                     packagePrefix.setLength( 0);
1:                     packagePrefix.append( System.getProperty( propertyName));
1:                     baseDir.setLength( baseDirLength);
1:                     if( packagePrefix.length() > 0)
1:                     {
1:                         baseDir.append( '/');
1:                         for( int offset = 0; offset < packagePrefix.length(); offset++)
1:                         {
1:                             char c = packagePrefix.charAt( offset);
1:                             if( c == '.')
1:                                 baseDir.append( '/');
1:                             else
1:                                 baseDir.append( c);
1:                         }
1:                     }
1:                     crawler.crawl( new File( baseDir.toString()), packagePrefix);
1:                 }
1:             }
1:             if( ! gotPrefix)
1:             {
1:                 System.err.println( "*** Could not search the class hierarchy because no starting");
1:                 System.err.println( "    prefixes where specified.");
1:                 System.exit(1);
1:             }
1:         }
1:         for( int i = 0; i < classCount; i++)
1:             crawler.addClass( classList[i]);
1: 
1:         baseDir.setLength( baseDirLength);
1:         String outputFileName =
0:           System.getProperty( "out", WS + "/java/org.apache.derby.iapi.services.cache.ClassSizeCatalog.java");
1:         try
1:         {
0:             Calendar cal = Calendar.getInstance();
0:             cal.setTime( new Date());
0:             int year = cal.get( Calendar.YEAR);
1:             PrintWriter out = new PrintWriter( new FileWriter( outputFileName));
0:             out.print( "/* IBM Confidential\n" +
0:                        " *\n" +
0:                        " * Product ID: 5697-F53\n" +
0:                        " *\n" +
0:                        " * (C) Copyright IBM Corp. " + year + "\n" +
0:                        " *\n" +
0:                        " * The source code for this program is not published or otherwise divested\n" +
0:                        " * of its trade secrets, irrespective of what has been deposited with the\n" +
0:                        " * U.S. Copyright Office.\n" +
1:                        " */\n");
1:             out.print( "package org.apache.derby.iapi.services.cache;\n" +
0:                        "import java.util.Hashtable;\n" +
0:                        "class ClassSizeCatalog extends java.util.Hashtable\n" +
1:                        "{\n" +
0:                        "    public static final String copyrightNotice = \"(c) Copyright IBM Corp. 2003. All Rights Reserved.\";\n" +
0:                        "    ClassSizeCatalog()\n" +
1:                        "    {\n");
1:             for( Enumeration e = classSizes.keys();
1:                  e.hasMoreElements();)
1:             {
1:                 String className = (String) e.nextElement();
1:                 int[] coeff = (int[]) classSizes.get( className);
1:                 out.print( "        put( \"" + className + "\", new int[]{" + coeff[0] + "," + coeff[1] + "});\n");
1:             }
1:             out.print("    }\n" +
1:                       "}\n");
1:             out.flush();
1:             out.close();
1:         }
1:         catch( IOException ioe)
1:         {
1:             System.err.println( "*** Cannot write to " + outputFileName);
1:             System.err.println( "   " + ioe.getMessage());
1:             System.exit(1);
1:         }
1:     } // end of main
1: 
0:     private Class[] interfaceList; // Search for classes that implement these interfaces
1:     private int interfaceCount;
0:     private Hashtable classSizes;
1:     private boolean verbose = false;
1: 
1:     private ClassSizeCrawler( Class[] interfaceList,
1:                               int interfaceCount,
0:                               Hashtable classSizes)
1:     {
1:         this.interfaceList = interfaceList;
1:         this.classSizes = classSizes;
1:         this.interfaceCount = interfaceCount;
0:         verbose = new Boolean( System.getProperty( "verbose", "false")).booleanValue();
1:     }
1: 
1:     private void crawl( File curDir, StringBuffer className)
1:     {
1:         if( verbose)
1:             System.out.println( "Searching directory " + curDir.getPath());
1: 
1:         try
1:         {
1:             if( ! curDir.isDirectory())
1:             {
1:                 System.err.println( "*** " + curDir.getPath() + " is not a directory.");
1:                 System.exit(1);
1:             }
1:         }
1:         catch( SecurityException se)
1:         {
1:             System.err.println( "Cannot access " + curDir.getPath());
1:             System.exit(1);
1:         }
1:         String[] filenames = curDir.list( );
1:         if( className.length() != 0)
1:             className.append( ".");
1: 
1:         int classNameLength = className.length();
1:         for( int fileIdx = 0; fileIdx < filenames.length; fileIdx++)
1:         {
1:             if( filenames[fileIdx].endsWith( ".class"))
1:             {
1:                 // Strip off the ".class" suffix
1:                 String s = filenames[fileIdx].substring( 0, filenames[fileIdx].length() - 6);
1:                 className.append( s);
0:                 Class targetClass = null;
1:                 String targetClassName = className.toString();
1:                 try
1:                 {
1:                     targetClass = Class.forName( targetClassName);
1:                     if( !targetClass.isInterface())
1:                     {
1:                         for( int interfaceIdx = 0; interfaceIdx < interfaceCount; interfaceIdx++)
1:                         {
1:                             if( interfaceList[interfaceIdx].isAssignableFrom( targetClass))
1:                                 addClass( targetClass);
1:                         }
1:                     }
1:                 }
1:                 catch( ClassNotFoundException cnfe)
1:                 {
1:                     System.err.println( "Could not find class " + targetClassName);
1:                     System.exit(1);
1:                 }
1:                 catch( Throwable t){}
1:                 className.setLength( classNameLength);
1:             }
1:             else
1:             {
1:                 File nextDir = new File( curDir, filenames[fileIdx]);
1:                 if( nextDir.isDirectory())
1:                 {
1:                     className.append( filenames[fileIdx]);
1:                     crawl( nextDir, className);
1:                     className.setLength( classNameLength);
1:                 }
1:             }
1:         }
1:     } // end of crawl
1: 
1:     private void addClass( Class targetClass)
1:     {
1:         int[] coefficients = ClassSize.getSizeCoefficients( targetClass);
1:         if( verbose)
1:             System.out.println( targetClass.getName() + " " + coefficients[0] + ", " + coefficients[1]);
1:         classSizes.put( targetClass.getName(), coefficients);
1:     } // end of addClass
1: } // end of ClassSizeCrawler
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:4ecc65a
/////////////////////////////////////////////////////////////////////////
0: 
1:                        "   Licensed to the Apache Software Foundation (ASF) under one or more\n" +
1:                        "   contributor license agreements.  See the NOTICE file distributed with\n" +
1:                        "   this work for additional information regarding copyright ownership.\n" +
1:                        "   The ASF licenses this file to You under the Apache License, Version 2.0\n" +
1:                        "   (the \"License\"); you may not use this file except in compliance with\n" +
1:                        "   the License.  You may obtain a copy of the License at\n" +
1:                        "\n" +
1:                        "      http://www.apache.org/licenses/LICENSE-2.0\n" +
1:                        "\n" +
1:                        "   Unless required by applicable law or agreed to in writing, software\n" +
1:                        "   distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
1:                        "   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
1:                        "   See the License for the specific language governing permissions and\n" +
1:                        "   limitations under the License.\n" +
author:David Van Couvering
-------------------------------------------------------------------------------
commit:de243e0
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.cache
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derbyBuild;
0: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: 
0: import java.io.File;
0: import java.io.FileWriter;
0: import java.io.PrintWriter;
0: import java.io.IOException;
0: import java.io.FileOutputStream;
0: import java.io.ObjectOutput;
0: import java.io.ObjectOutputStream;
0: import java.lang.SecurityException;
0: import java.lang.ClassNotFoundException;
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import java.util.Calendar;
0: import java.util.Date;
0: 
0: /**
0:  * This class implements a program that catalogs the size estimate coefficients of various classes.
0:  * @see ClassSize#getSizeCoefficients.
0:  *<p>
0:  * The program is invoked as:
0:  *<p>
0:  * java -DWS=<i>work-space</i> [-DclassDir=<i>class-dir</i>] [-Dout=<i>out-file</i> [-Dprefix[.<i>x</i>=<i>package-prefix</i>]] [-Dverbose=true] org.apache.derby.iapi.services.cache.ClassSizeCrawler <i>class-or-interface</i> ...<br>
0:  *<p>
0:  * This program gets the size coefficients for each class in the <i>class-or-interface</i> list,
0:  * and for each class that implements an interface in the list. If there is an interface in the list
0:  * this program crawls through the classes hierarcy, starting at points specified by the prefix
0:  * properties, looking for classes that implement the interfaces.
0:  *<p>
0:  * If the <i>class-or-interface</i> list is empty then this program searches for implementations
0:  * of org.apache.derby.iapi.types.DataValueDescriptor, and at least one prefix property
0:  * must be specified
0:  *<p>
0:  * The catalog is written as a java source file
0:  * into <i>out-file</i>, by default
0:  * <i>work-space</i>/java/org.apache.derby.iapi.services.cache.ClassSizeCatalog.java.
0:  *<p>
0:  * <i>work-space</i> is the directory containing the java and classes directories. $WS in the
0:  * standard development environment. This property is required.
0:  *<p>
0:  * <i>class-dir</i> is the directory containing the compiled classes. By default it is <i>work-space</i>/classes.
0:  *<p>
0:  * <i>package-prefix</i> is the first part of a package name. e.g. "com.ibm.db2j.impl". At least
0:  * one prefix property must be specified if there is an interface in the list.
0:  *<p>
0:  * For example:<br>
0:  * <pre>
0:  * <code>
0:  * java -DWS=$WS \
0:  *      -Dprefix.1=org.apache.derby.iapi.types \
0:  *      org.apache.derby.iapi.services.cache.ClassSizeCrawler \
0:  *        org.apache.derby.iapi.types.DataValueDescriptor \
0:  *        java.math.BigDecimal \
0:  *        org.apache.derby.impl.services.cache.Generic.CachedItem
0:  *</code>
0:  *</pre>
0:  */
0: public class ClassSizeCrawler
0: {
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0:     public static void main( String[] arg)
0:     {
0:         String[] classAndInterfaceList = {"org.apache.derby.iapi.types.DataValueDescriptor"};
0:         if(arg.length > 0)
0:             classAndInterfaceList = arg;
0:         Class[] interfaceList = new Class[classAndInterfaceList.length];
0:         int interfaceCount = 0;
0:         Class[] classList = new Class[classAndInterfaceList.length];
0:         int classCount = 0;
0: 
0:         Class classSizeClass = ClassSize.class; // Make sure that the garbage collector does not unload it
0:         ClassSize.setDummyCatalog();
0:         /* Most of the classes we will catalog invoke ClassSize.estimateBaseFromCatalog in
0:          * their static initializer. This dummy the catalog out so that this will not generate
0:          * errors. We will not actually use the classes, just examine their fields.
0:          */
0: 
0:         for( int i = 0; i < classAndInterfaceList.length; i++)
0:         {
0:             Class cls = null;
0:             try
0:             {
0:                 cls = Class.forName( classAndInterfaceList[i]);
0:             }
0:             catch( ClassNotFoundException cnfe)
0:             {
0:                 System.err.println( "*** Could not find class " + classAndInterfaceList[i]);
0:                 System.exit(1);
0:             }
0:             if( cls.isInterface())
0:                 interfaceList[ interfaceCount++] = cls;
0:             else
0:                 classList[ classCount++] = cls;
0:         }
0: 
0:         String WS = System.getProperty( "WS");
0:         if( WS == null)
0:         {
0:             System.err.println( "*** WS is not set.");
0:             System.exit(1);
0:         }
0: 
0:         StringBuffer baseDir = new StringBuffer( System.getProperty( "classDir", ""));
0:         if( baseDir.length() == 0)
0:         {
0:             baseDir.append( WS);
0:             baseDir.append( '/');
0:             baseDir.append( "classes");
0:         }
0:         int baseDirLength = baseDir.length();
0: 
0:         StringBuffer packagePrefix = new StringBuffer( );
0: 
0:         Hashtable classSizes = new Hashtable();
0: 
0:         ClassSizeCrawler crawler = new ClassSizeCrawler(interfaceList, interfaceCount, classSizes);
0: 
0:         if( interfaceCount > 0)
0:         {
0:             boolean gotPrefix = false;
0:             // Crawl through the class hierarchies for classes implementing the interfaces
0:             for( Enumeration e = System.getProperties().propertyNames();
0:                  e.hasMoreElements();)
0:             {
0:                 String propertyName = (String) e.nextElement();
0:                 if( propertyName.equals( "prefix") || propertyName.startsWith( "prefix."))
0:                 {
0:                     gotPrefix = true;
0:                     packagePrefix.setLength( 0);
0:                     packagePrefix.append( System.getProperty( propertyName));
0:                     baseDir.setLength( baseDirLength);
0:                     if( packagePrefix.length() > 0)
0:                     {
0:                         baseDir.append( '/');
0:                         for( int offset = 0; offset < packagePrefix.length(); offset++)
0:                         {
0:                             char c = packagePrefix.charAt( offset);
0:                             if( c == '.')
0:                                 baseDir.append( '/');
0:                             else
0:                                 baseDir.append( c);
0:                         }
0:                     }
0:                     crawler.crawl( new File( baseDir.toString()), packagePrefix);
0:                 }
0:             }
0:             if( ! gotPrefix)
0:             {
0:                 System.err.println( "*** Could not search the class hierarchy because no starting");
0:                 System.err.println( "    prefixes where specified.");
0:                 System.exit(1);
0:             }
0:         }
0:         for( int i = 0; i < classCount; i++)
0:             crawler.addClass( classList[i]);
0: 
0:         baseDir.setLength( baseDirLength);
0:         String outputFileName =
0:           System.getProperty( "out", WS + "/java/org.apache.derby.iapi.services.cache.ClassSizeCatalog.java");
0:         try
0:         {
0:             Calendar cal = Calendar.getInstance();
0:             cal.setTime( new Date());
0:             int year = cal.get( Calendar.YEAR);
0:             PrintWriter out = new PrintWriter( new FileWriter( outputFileName));
0:             out.print( "/* IBM Confidential\n" +
0:                        " *\n" +
0:                        " * Product ID: 5697-F53\n" +
0:                        " *\n" +
0:                        " * (C) Copyright IBM Corp. " + year + "\n" +
0:                        " *\n" +
0:                        " * The source code for this program is not published or otherwise divested\n" +
0:                        " * of its trade secrets, irrespective of what has been deposited with the\n" +
0:                        " * U.S. Copyright Office.\n" +
0:                        " */\n");
0:             out.print( "package org.apache.derby.iapi.services.cache;\n" +
0:                        "import java.util.Hashtable;\n" +
0:                        "class ClassSizeCatalog extends java.util.Hashtable\n" +
0:                        "{\n" +
0:                        "    public static final String copyrightNotice = \"(c) Copyright IBM Corp. 2003. All Rights Reserved.\";\n" +
0:                        "    ClassSizeCatalog()\n" +
0:                        "    {\n");
0:             for( Enumeration e = classSizes.keys();
0:                  e.hasMoreElements();)
0:             {
0:                 String className = (String) e.nextElement();
0:                 int[] coeff = (int[]) classSizes.get( className);
0:                 out.print( "        put( \"" + className + "\", new int[]{" + coeff[0] + "," + coeff[1] + "});\n");
0:             }
0:             out.print("    }\n" +
0:                       "}\n");
0:             out.flush();
0:             out.close();
0:         }
0:         catch( IOException ioe)
0:         {
0:             System.err.println( "*** Cannot write to " + outputFileName);
0:             System.err.println( "   " + ioe.getMessage());
0:             System.exit(1);
0:         }
0:     } // end of main
0: 
0:     private Class[] interfaceList; // Search for classes that implement these interfaces
0:     private int interfaceCount;
0:     private Hashtable classSizes;
0:     private boolean verbose = false;
0: 
0:     private ClassSizeCrawler( Class[] interfaceList,
0:                               int interfaceCount,
0:                               Hashtable classSizes)
0:     {
0:         this.interfaceList = interfaceList;
0:         this.classSizes = classSizes;
0:         this.interfaceCount = interfaceCount;
0:         verbose = new Boolean( System.getProperty( "verbose", "false")).booleanValue();
0:     }
0: 
0:     private void crawl( File curDir, StringBuffer className)
0:     {
0:         if( verbose)
0:             System.out.println( "Searching directory " + curDir.getPath());
0: 
0:         try
0:         {
0:             if( ! curDir.isDirectory())
0:             {
0:                 System.err.println( "*** " + curDir.getPath() + " is not a directory.");
0:                 System.exit(1);
0:             }
0:         }
0:         catch( SecurityException se)
0:         {
0:             System.err.println( "Cannot access " + curDir.getPath());
0:             System.exit(1);
0:         }
0:         String[] filenames = curDir.list( );
0:         if( className.length() != 0)
0:             className.append( ".");
0: 
0:         int classNameLength = className.length();
0:         for( int fileIdx = 0; fileIdx < filenames.length; fileIdx++)
0:         {
0:             if( filenames[fileIdx].endsWith( ".class"))
0:             {
0:                 // Strip off the ".class" suffix
0:                 String s = filenames[fileIdx].substring( 0, filenames[fileIdx].length() - 6);
0:                 className.append( s);
0:                 Class targetClass = null;
0:                 String targetClassName = className.toString();
0:                 try
0:                 {
0:                     targetClass = Class.forName( targetClassName);
0:                     if( !targetClass.isInterface())
0:                     {
0:                         for( int interfaceIdx = 0; interfaceIdx < interfaceCount; interfaceIdx++)
0:                         {
0:                             if( interfaceList[interfaceIdx].isAssignableFrom( targetClass))
0:                                 addClass( targetClass);
0:                         }
0:                     }
0:                 }
0:                 catch( ClassNotFoundException cnfe)
0:                 {
0:                     System.err.println( "Could not find class " + targetClassName);
0:                     System.exit(1);
0:                 }
0:                 catch( Throwable t){}
0:                 className.setLength( classNameLength);
0:             }
0:             else
0:             {
0:                 File nextDir = new File( curDir, filenames[fileIdx]);
0:                 if( nextDir.isDirectory())
0:                 {
0:                     className.append( filenames[fileIdx]);
0:                     crawl( nextDir, className);
0:                     className.setLength( classNameLength);
0:                 }
0:             }
0:         }
0:     } // end of crawl
0: 
0:     private void addClass( Class targetClass)
0:     {
0:         int[] coefficients = ClassSize.getSizeCoefficients( targetClass);
0:         if( verbose)
0:             System.out.println( targetClass.getName() + " " + coefficients[0] + ", " + coefficients[1]);
0:         classSizes.put( targetClass.getName(), coefficients);
0:     } // end of addClass
0: } // end of ClassSizeCrawler
============================================================================