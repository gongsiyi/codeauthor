1:0438c35: /*
1:0438c35: 
1:0438c35: Derby - Class org.apache.derbyTesting.functionTests.util
1:0438c35: 
1:15651f5: Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5: contributor license agreements.  See the NOTICE file distributed with
1:15651f5: this work for additional information regarding copyright ownership.
1:15651f5: The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5: (the "License"); you may not use this file except in compliance with
1:15651f5: the License.  You may obtain a copy of the License at
1:0438c35: 
1:0438c35:    http://www.apache.org/licenses/LICENSE-2.0
1:0438c35: 
1:0438c35: Unless required by applicable law or agreed to in writing, software
1:0438c35: distributed under the License is distributed on an "AS IS" BASIS,
1:0438c35: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0438c35: See the License for the specific language governing permissions and
1:0438c35: limitations under the License.
1:0438c35: 
1:0438c35: */
1:0438c35: 
1:0438c35: /**
1:0438c35:  * <p>
1:0438c35:  * This class factors out utility methods (including assertion machinery)
1:1d22c17:  * for re-use by Derby JUnit tests. JUnit tests should extend this class.
1:0438c35:  * </p>
1:0438c35:  *
1:0438c35:  */
1:0438c35: 
1:0438c35: package org.apache.derbyTesting.functionTests.util;
1:0438c35: 
1:4087714: import java.io.*;
1:90731d5: import java.math.*;
1:4087714: import java.sql.*;
1:90731d5: import java.util.*;
1:4087714: 
1:0438c35: import junit.framework.*;
1:0438c35: 
1:0438c35: public	class	DerbyJUnitTest	extends	TestCase
1:0438c35: {
1:0438c35: 	/////////////////////////////////////////////////////////////
1:0438c35: 	//
1:0438c35: 	//	CONSTANTS
1:0438c35: 	//
1:0438c35: 	/////////////////////////////////////////////////////////////
1:0438c35: 
1:4087714: 	/** If you set this startup property to true, you will get chatty output. */
1:4087714: 	public	static	final			String	DEBUG_FLAG = "drb.tests.debug";
1:4087714: 	
1:4087714: 	public	static	final			int		SUCCESS_EXIT = 0;
1:4087714: 	public	static	final			int		FAILURE_EXIT = 1;
1:4087714: 
1:90731d5: 	public	static	final	String	DEFAULT_USER_NAME = "APP";
1:90731d5: 	public	static	final	String	DEFAULT_PASSWORD = "APP";
1:90731d5: 	public	static	final	String	DEFAULT_DATABASE_NAME = "wombat";
1:0438c35: 
1:90731d5: 	// because java.sql.Types.BOOLEAN doesn't exist in jdbc 2.0
1:90731d5: 	protected	static	final			int		JDBC_BOOLEAN = 16;
1:90731d5: 	
1:0438c35: 	//
1:90731d5: 	// For dropping schema objects
1:90731d5: 	//
1:90731d5: 	private	static	final	String	TABLE = "table";
1:90731d5: 	private	static	final	String	FUNCTION = "function";
1:90731d5: 	private	static	final	String	PROCEDURE = "procedure";
1:506f4c8: 	private	static	final	String	TYPE = "type";
1:90731d5: 	
1:90731d5: 	//
1:90731d5: 	// These are properties for the Derby connection URL.
1:90731d5: 	//
1:90731d5: 	private	static	final			String	CREATE_PROPERTY = "create=true";
1:90731d5: 
1:90731d5: 	//
1:38b2847: 	// Indexes into the array of client-specific strings. E.g.,
1:90731d5: 	// DERBY_CLIENT, and EMBEDDED_CLIENT.
1:90731d5: 	//
1:90731d5: 	public	static	final			int		DATABASE_URL = 0;
1:90731d5: 	public	static	final			int		DRIVER_NAME = DATABASE_URL + 1;
1:90731d5: 	public	static	final			int		FRAMEWORK_NAME = DRIVER_NAME + 1;
1:90731d5: 
1:90731d5: 	// indexed by DATABASE_URL and DRIVER_NAME
1:90731d5: 	private	static	final	String[]	DERBY_CLIENT =
1:90731d5: 	{
1:90731d5: 		"jdbc:derby://localhost:1527/",
1:90731d5: 		"org.apache.derby.jdbc.ClientDriver",
1:90731d5: 		"DerbyNetClient"
2:90731d5: 	};
1:90731d5: 	private	static	final	String[]	EMBEDDED_CLIENT =
1:90731d5: 	{
1:90731d5: 		"jdbc:derby:",
1:90731d5: 		"org.apache.derby.jdbc.EmbeddedDriver",
1:90731d5: 		"embedded"
1:90731d5: 	};
1:90731d5: 
1:90731d5: 	public	static	final	String[][]	LEGAL_CLIENTS =
1:90731d5: 	{
1:90731d5: 		DERBY_CLIENT,
1:90731d5: 		EMBEDDED_CLIENT
1:90731d5: 	};
1:90731d5: 	
1:0438c35: 	/////////////////////////////////////////////////////////////
1:90731d5: 	//
1:0438c35: 	//	STATE
1:0438c35: 	//
1:0438c35: 	/////////////////////////////////////////////////////////////
1:0438c35: 
1:4087714: 	private	static	boolean		_debug;					// if true, we print chatty diagnostics
1:4087714: 	
1:4087714: 	private	static	PrintStream	_outputStream = System.out;	// where to print debug output
1:4087714: 
1:90731d5: 	private	static	String		_databaseName;			// sandbox for tests
1:90731d5: 	private	static	String[]	_defaultClientSettings;	// one of the clients in
1:90731d5: 														// LEGAL_CLIENTS
1:90731d5: 
1:0438c35: 	/////////////////////////////////////////////////////////////
1:0438c35: 	//
1:0438c35: 	//	CONSTRUCTOR
1:0438c35: 	//
1:0438c35: 	/////////////////////////////////////////////////////////////
1:0438c35: 	
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Vacuous constructor for JUnit machinery.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:0438c35: 	public	DerbyJUnitTest() {}
1:0438c35: 
1:0438c35: 	/////////////////////////////////////////////////////////////
1:0438c35: 	//
1:4087714: 	//	PUBLIC BEHAVIOR
1:4087714: 	//
1:4087714: 	/////////////////////////////////////////////////////////////
1:4087714: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:90731d5: 	 * Return true if we're using the embedded driver.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	boolean	usingEmbeddedClient() { return ( _defaultClientSettings == EMBEDDED_CLIENT ); }
1:90731d5: 
1:4087714: 	/**
1:4087714: 	 * <p>
1:90731d5: 	 * Return true if we're using the derby client
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	boolean	usingDerbyClient() { return ( _defaultClientSettings == DERBY_CLIENT ); }
1:90731d5: 
1:4087714: 	/**
1:4087714: 	 * <p>
1:90731d5: 	 * Get the client we're using.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	static	String[]	getClientSettings() { return _defaultClientSettings; }
1:90731d5: 
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:90731d5: 	 * Set the client we're going to use.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	static	void		setClient( String[] client ) { _defaultClientSettings = client; }
1:90731d5: 
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:90731d5: 	 * Set the database name.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	static	void	setDatabaseName( String databaseName ) { _databaseName = databaseName; }
1:90731d5: 	
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:90731d5: 	 * Force the debugging state. Useful for debugging under the test harness.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	static	void	setDebug( boolean value ) { _debug = value; }
1:90731d5: 
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:4087714: 	 * Look for the system property which tells us whether to run
1:4087714: 	 * chattily.
1:4087714: 	 * </p>
1:4087714: 	 */
1:4087714: 	public	static	boolean	parseDebug()
1:4087714: 	{
1:4087714: 		_debug = Boolean.getBoolean( DEBUG_FLAG );
1:4087714: 		
1:4087714: 		return true;
1:4087714: 	}
1:4087714: 		
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:4087714: 	 * Debug code to print chatty informational messages.
1:4087714: 	 * </p>
1:4087714: 	 */
1:4087714: 	public	static	void	println( String text )
1:4087714: 	{
1:1d22c17: 		if ( _debug ) { alarm( text ); }
1:1d22c17: 	}
1:1d22c17: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Print a message regardless of whether we are running in debug mode.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:1d22c17: 	public	static	void	alarm( String text )
1:1d22c17: 	{
1:1d22c17: 		_outputStream.println( text );
1:1d22c17: 		_outputStream.flush();
1:4087714: 	}
1:4087714: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:4087714: 	 * Print out a stack trace.
1:4087714: 	 * </p>
1:4087714: 	 */
1:4087714: 	public	static	void	printStackTrace( Throwable t )
1:4087714: 	{
1:4087714: 		while ( t != null )
1:4087714: 		{
1:4087714: 			t.printStackTrace( _outputStream );
1:4087714: 
1:4087714: 			if ( t instanceof SQLException )	{ t = ((SQLException) t).getNextException(); }
1:4087714: 			else { break; }
1:4087714: 		}
1:4087714: 	}
1:4087714: 
1:4087714: 	/////////////////////////////////////////////////////////////
1:4087714: 	//
1:90731d5: 	//	CONNECTION MANAGEMENT
15:90731d5: 	//
1:90731d5: 	/////////////////////////////////////////////////////////////
1:4087714: 
1:4087714: 	/**
1:4087714: 	 * <p>
1:1d22c17: 	 * Load a client driver, given its particulars.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	boolean	faultInDriver( String[] clientSettings )
1:4087714: 	{
1:90731d5: 		String	currentClientName = clientSettings[ DRIVER_NAME ];
1:90731d5: 		
1:90731d5: 		try {
1:90731d5: 			Class.forName( currentClientName );
22:90731d5: 
1:90731d5: 			return true;
1:4087714: 		}
1:90731d5: 		catch (Exception e)
1:4087714: 		{
1:90731d5: 			println( "Could not find " + currentClientName );
1:90731d5: 			return false;
1:4087714: 		}
8:90731d5: 	}
1:90731d5: 
1:4087714: 	/**
1:4087714: 	 * <p>
1:1d22c17: 	 * Get a connection to a database, using the default client.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	Connection	getConnection()
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		return getConnection( _defaultClientSettings, _databaseName, new Properties() );
1:90731d5: 	}
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Get a connection to a database, using the specified client.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	Connection	getConnection
1:90731d5: 	(
1:90731d5: 	    String[]	clientSettings,
1:90731d5: 		String		databaseName,
1:90731d5: 		Properties	properties
1:90731d5: 	)
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		faultInDriver( clientSettings );
1:90731d5: 
1:90731d5: 		properties.put( "user", DEFAULT_USER_NAME );
1:90731d5: 		properties.put( "password", DEFAULT_PASSWORD );
1:90731d5: 		properties.put( "retreiveMessagesFromServerOnGetMessage", "true" );
1:90731d5: 
1:90731d5: 		Connection		conn = DriverManager.getConnection
1:90731d5: 			( makeDatabaseURL( clientSettings, databaseName ), properties );
1:90731d5: 
1:90731d5: 		println( "Connection is a " + conn.getClass().getName() );
1:90731d5: 		
1:90731d5: 		return conn;
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Cobble together a connection URL.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	private	static	String	makeDatabaseURL( String[] clientSettings, String databaseName )
1:90731d5: 	{
1:90731d5: 		return clientSettings[ DATABASE_URL ] + databaseName;
1:90731d5: 	}
1:90731d5: 
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:90731d5: 	 * Create an empty database.
1:4087714: 	 * </p>
1:4087714: 	 */
1:90731d5: 	protected	void	createDB( String databaseName )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		String[]	clientSettings = getClientSettings();
1:90731d5: 		String		dbURL = makeDatabaseURL( clientSettings, databaseName );
1:90731d5: 
1:90731d5: 		dbURL = dbURL + ';' + CREATE_PROPERTY;
1:90731d5: 
1:90731d5: 		Properties	properties = new Properties();
1:90731d5: 
1:90731d5: 		properties.put( "user", DEFAULT_USER_NAME );
1:90731d5: 		properties.put( "password", DEFAULT_PASSWORD );
1:90731d5: 
1:90731d5: 		faultInDriver( clientSettings );
1:90731d5: 
1:90731d5: 		Connection		conn = DriverManager.getConnection( dbURL, properties );
1:90731d5: 
1:90731d5: 		conn.close();
1:90731d5: 	}
1:90731d5: 
1:90731d5: 	///////////////
1:90731d5: 	//
1:90731d5: 	//	SQL MINIONS
1:90731d5: 	//
1:90731d5: 	///////////////
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Execute DDL statement.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	executeDDL( Connection conn, String text )
1:90731d5: 		throws SQLException
1:90731d5: 	{
1:90731d5: 		PreparedStatement	ps = null;
1:90731d5: 
1:90731d5: 		try {
1:90731d5: 			ps = prepare( conn, text );
1:90731d5: 
1:90731d5: 			ps.execute();
1:90731d5: 		}
1:90731d5: 		finally { close( ps ); }
1:90731d5: 	}
1:90731d5: 	
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Execute a SQL statement, given by the text argument. This thin
1:1d22c17: 	 * wrapper around the JDBC machinery logs the statement text when
1:1d22c17: 	 * running in debug mode.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	execute( Connection conn, String text )
1:90731d5: 		throws SQLException
1:90731d5: 	{
1:90731d5: 		PreparedStatement	ps = prepare( conn, text );
1:90731d5: 
1:90731d5: 		ps.execute();
1:90731d5: 		close( ps );
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Prepare a SQL statement, given by the text argument. This thin
1:1d22c17: 	 * wrapper around the JDBC machinery logs the statement text when
1:1d22c17: 	 * running in debug mode.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	PreparedStatement	prepare( Connection conn, String text )
1:90731d5: 		throws SQLException
9:90731d5: 	{
1:90731d5: 		println( "Preparing: " + text );
1:90731d5: 
1:90731d5: 		return conn.prepareStatement( text );
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Prepare a SQL call statement, given by the text argument. This thin
1:1d22c17: 	 * wrapper around the JDBC machinery logs the statement text when
1:1d22c17: 	 * running in debug mode.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	CallableStatement	prepareCall( Connection conn, String text )
1:90731d5: 		throws SQLException
1:90731d5: 	{
1:90731d5: 		println( "Preparing procedure call: '" + text + "'" );
1:90731d5: 
1:90731d5: 		CallableStatement	cs = conn.prepareCall( text );
1:90731d5: 
1:90731d5: 		return cs;
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Scour out all the rows from a table.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	truncateTable( Connection conn, String name )
1:90731d5: 		throws SQLException
1:90731d5: 	{
1:90731d5: 		PreparedStatement	ps = prepare( conn, "delete from " + name );
1:90731d5: 
1:90731d5: 		ps.execute();
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Drop a table regardless of whether it exists. If the table does not
1:1d22c17: 	 * exist, don't log an error unless
1:1d22c17: 	 * running in debug mode. This method is to be used for reinitializing
1:1d22c17: 	 * a schema in case a previous test run failed to clean up after itself.
1:1d22c17: 	 * Do not use this method if you need to verify that the table really exists.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	dropTable( Connection conn, String name )
1:90731d5: 	{
1:506f4c8: 		dropSchemaObject( conn, TABLE, name, false );
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Drop a function regardless of whether it exists. If the function does not
1:1d22c17: 	 * exist, don't log an error unless
1:1d22c17: 	 * running in debug mode. This method is to be used for reinitializing
1:1d22c17: 	 * a schema in case a previous test run failed to clean up after itself.
1:1d22c17: 	 * Do not use this method if you need to verify that the function really exists.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	dropFunction( Connection conn, String name )
1:90731d5: 	{
1:506f4c8: 		dropSchemaObject( conn, FUNCTION, name, false );
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Drop a procedure regardless of whether it exists. If the procedure does
1:1d22c17: 	 * not exist, don't log an error unless
1:1d22c17: 	 * running in debug mode. This method is to be used for reinitializing
1:1d22c17: 	 * a schema in case a previous test run failed to clean up after itself.
1:1d22c17: 	 * Do not use this method if you need to verify that the procedure really exists.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	dropProcedure( Connection conn, String name )
1:90731d5: 	{
1:506f4c8: 		dropSchemaObject( conn, PROCEDURE, name, false );
1:506f4c8: 	}
1:506f4c8: 
1:506f4c8: 	/**
1:506f4c8: 	 * <p>
1:506f4c8: 	 * Drop a UDT regardless of whether it exists. If the UDT does
1:506f4c8: 	 * not exist, don't log an error unless
1:506f4c8: 	 * running in debug mode. This method is to be used for reinitializing
1:506f4c8: 	 * a schema in case a previous test run failed to clean up after itself.
1:506f4c8: 	 * Do not use this method if you need to verify that the UDT really exists.
1:506f4c8: 	 * </p>
1:506f4c8: 	 */
1:506f4c8: 	protected	static	void	dropUDT( Connection conn, String name )
1:506f4c8: 	{
1:506f4c8: 		dropSchemaObject( conn, TYPE, name, true );
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Drop a schema object regardless of whether it exists. If the object does
1:1d22c17: 	 * not exist, don't log an error unless
1:1d22c17: 	 * running in debug mode. This method is to be used for reinitializing
1:1d22c17: 	 * a schema in case a previous test run failed to clean up after itself.
1:1d22c17: 	 * Do not use this method if you need to verify that the object really exists.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:506f4c8: 	protected	static	void	dropSchemaObject( Connection conn, String genus, String objectName, boolean restrict )
1:90731d5: 	{
1:90731d5: 		PreparedStatement	ps = null;
1:90731d5: 		
1:90731d5: 		try {
1:506f4c8:             String text = "drop " + genus + " " + objectName;
1:506f4c8:             if ( restrict ) { text = text + " restrict"; }
1:506f4c8: 			ps = prepare( conn, text );
1:90731d5: 
1:90731d5: 			ps.execute();
1:90731d5: 		}
1:1d22c17: 		catch (SQLException e)
1:1d22c17: 		{
1:1d22c17: 			if ( _debug ) { printStackTrace( e ); }
1:1d22c17: 		}
1:90731d5: 
1:90731d5: 		close( ps );
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Close a ResultSet. This method factors out the check for whether
1:1d22c17: 	 * the ResultSet was created in the first place. This tidies up the
1:1d22c17: 	 * caller's cleanup logic. If an error occurs, print it. Because this
1:1d22c17: 	 * method swallows the exception after printing it, do not call this
1:1d22c17: 	 * method if you want your test to halt on error.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	close( ResultSet rs )
1:90731d5: 	{
1:90731d5: 		try {
1:90731d5: 			if ( rs != null ) { rs.close(); }
1:90731d5: 		}
1:1d22c17: 		catch (SQLException e) { printStackTrace( e ); }
1:90731d5: 	}	
1:1d22c17: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Close a Statement. This method factors out the check for whether
1:1d22c17: 	 * the Statement was created in the first place. This tidies up the
1:1d22c17: 	 * caller's cleanup logic. If an error occurs, print it. Because this
1:1d22c17: 	 * method swallows the exception after printing it, do not call this
1:1d22c17: 	 * method if you want your test to halt on error.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	close( Statement statement )
1:90731d5: 	{
1:90731d5: 		try {
1:90731d5: 			if ( statement != null ) { statement.close(); }
1:90731d5: 		}
1:1d22c17: 		catch (SQLException e) { printStackTrace( e ); }
1:90731d5: 	}
1:1d22c17: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Close a Connection. This method factors out the check for whether
1:1d22c17: 	 * the Connection was created in the first place. This tidies up the
1:1d22c17: 	 * caller's cleanup logic. If an error occurs, print it. Because this
1:1d22c17: 	 * method swallows the exception after printing it, do not call this
1:1d22c17: 	 * method if you want your test to halt on error.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	static	void	close( Connection conn )
1:90731d5: 	{
1:90731d5: 		try {
1:90731d5: 			if ( conn != null ) { conn.close(); }
1:90731d5: 		}
1:1d22c17: 		catch (SQLException e) { printStackTrace( e ); }
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Read a column from a ResultSet given its column name and expected jdbc
1:1d22c17: 	 * type. This method is useful if you are want to verify the getXXX() logic
1:1d22c17: 	 * most naturally fitting the declared SQL type.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	Object	getColumn( ResultSet rs, String columnName, int jdbcType )
4:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		Object		retval = null;
1:90731d5: 
1:90731d5: 		switch( jdbcType )
1:90731d5: 		{
1:90731d5: 		    case JDBC_BOOLEAN:
1:39b3237: 				retval = rs.getBoolean( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BIGINT:
1:39b3237: 				retval = rs.getLong( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BLOB:
1:90731d5: 				retval = rs.getBlob( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.CHAR:
1:90731d5: 		    case Types.LONGVARCHAR:
1:90731d5: 		    case Types.VARCHAR:
1:90731d5: 				retval = rs.getString( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BINARY:
1:90731d5: 		    case Types.LONGVARBINARY:
1:90731d5: 		    case Types.VARBINARY:
1:90731d5: 				retval = rs.getBytes( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.CLOB:
1:90731d5: 				retval = rs.getClob( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DATE:
1:90731d5: 				retval = rs.getDate( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DECIMAL:
1:90731d5: 		    case Types.NUMERIC:
1:90731d5: 				retval = rs.getBigDecimal( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DOUBLE:
1:39b3237: 				retval = rs.getDouble( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.REAL:
1:39b3237: 				retval = rs.getFloat( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.INTEGER:
1:39b3237: 				retval = rs.getInt( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.SMALLINT:
1:39b3237: 				retval = rs.getShort( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.TIME:
1:90731d5: 				retval = rs.getTime( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.TIMESTAMP:
1:90731d5: 				retval = rs.getTimestamp( columnName );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    default:
1:90731d5: 				fail( "Unknown jdbc type " + jdbcType + " used to retrieve column: " + columnName );
1:90731d5: 				break;
1:90731d5: 		}
1:90731d5: 
1:90731d5: 		if ( rs.wasNull() ) { retval = null; }
1:90731d5: 
1:90731d5: 		return retval;
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Read a column from a ResultSet given its column position
1:1d22c17: 	 * and an expected Java type. This method is useful when
1:1d22c17: 	 * comparing ResultSets against expected values.
1:1d22c17: 	 * </p>
1:1d22c17: 	 *
1:1d22c17: 	 * @param	rs		The ResultSet to read.
1:1d22c17: 	 * @param	param	The column number (1-based)
1:1d22c17: 	 * @param	value	An object whose type is what we expect the column to be.
1:1d22c17: 	 */
1:90731d5: 	protected	Object	getColumn( ResultSet rs, int param, Object value )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		Object		retval;
1:90731d5: 		
1:90731d5: 		if ( value == null )
1:90731d5: 		{
1:90731d5: 			retval = rs.getObject( param );
1:90731d5: 		}
1:39b3237: 		else if ( value instanceof Boolean ) { retval = rs.getBoolean( param ); }
1:39b3237: 		else if ( value instanceof Byte ) { retval = rs.getByte( param ); }
1:39b3237: 		else if ( value instanceof Short ) { retval = rs.getShort( param ); }
1:39b3237: 		else if ( value instanceof Integer ) { retval = rs.getInt( param ); }
1:39b3237: 		else if ( value instanceof Long ) { retval = rs.getLong( param ); }
1:39b3237: 		else if ( value instanceof Float ) { retval = rs.getFloat( param ); }
1:39b3237: 		else if ( value instanceof Double ) { retval = rs.getDouble( param ); }
1:90731d5: 		else if ( value instanceof String ) { retval = rs.getString( param ); }
1:90731d5: 		else if ( value instanceof BigDecimal ) { retval = rs.getBigDecimal( param ); }
1:90731d5: 		else { retval = rs.getObject( param ); }
1:90731d5: 
1:90731d5: 		if ( rs.wasNull() ) { retval = null; }
1:90731d5: 
1:90731d5: 		return retval;
1:90731d5: 	}
1:90731d5: 	
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Read an output argument from a CallableStatement given its 1-based
1:1d22c17: 	 * argument position and expected jdbc type. This is useful for
1:1d22c17: 	 * exercising the getXXX() methods most natural to a declared SQL type.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	Object	getOutArg( CallableStatement cs, int arg, int jdbcType )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		Object		retval = null;
1:90731d5: 
1:90731d5: 		switch( jdbcType )
1:90731d5: 		{
1:90731d5: 		    case JDBC_BOOLEAN:
1:39b3237: 				retval = cs.getBoolean( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BIGINT:
1:39b3237: 				retval = cs.getLong( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BLOB:
1:90731d5: 				retval = cs.getBlob( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.CHAR:
1:90731d5: 		    case Types.LONGVARCHAR:
1:90731d5: 		    case Types.VARCHAR:
1:90731d5: 				retval = cs.getString( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BINARY:
1:90731d5: 		    case Types.LONGVARBINARY:
1:90731d5: 		    case Types.VARBINARY:
1:90731d5: 				retval = cs.getBytes( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.CLOB:
1:90731d5: 				retval = cs.getClob( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DATE:
1:90731d5: 				retval = cs.getDate( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DECIMAL:
1:90731d5: 		    case Types.NUMERIC:
1:90731d5: 				retval = cs.getBigDecimal( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DOUBLE:
1:39b3237: 				retval = cs.getDouble( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.REAL:
1:39b3237: 				retval = cs.getFloat( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.INTEGER:
1:39b3237: 				retval = cs.getInt( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.SMALLINT:
1:39b3237: 				retval = cs.getShort( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.TIME:
1:90731d5: 				retval = cs.getTime( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.TIMESTAMP:
1:90731d5: 				retval = cs.getTimestamp( arg );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    default:
1:90731d5: 				fail( "Unknown jdbc type " + jdbcType + " used to retrieve column: " + arg );
1:90731d5: 				break;
1:90731d5: 		}
1:90731d5: 
1:90731d5: 		if ( cs.wasNull() ) { retval = null; }
1:90731d5: 
1:90731d5: 		return retval;
1:90731d5: 	}
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Stuff a PreparedStatement parameter given its 1-based parameter position
1:1d22c17: 	 * and expected jdbc type. This method is useful for testing the setXXX()
1:1d22c17: 	 * methods most natural for a declared SQL type.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	void	setParameter( PreparedStatement ps, int param, int jdbcType, Object value )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		if ( value == null )
1:90731d5: 		{
1:90731d5: 			ps.setNull( param, jdbcType );
1:90731d5: 
1:90731d5: 			return;
1:90731d5: 		}
1:90731d5: 
1:90731d5: 		switch( jdbcType )
1:90731d5: 		{
1:90731d5: 		    case JDBC_BOOLEAN:
1:90731d5: 				ps.setBoolean( param, ((Boolean) value ).booleanValue() );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BIGINT:
1:90731d5: 				ps.setLong( param, ((Long) value ).longValue() );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BLOB:
1:90731d5: 				ps.setBlob( param, ((Blob) value ) );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.CHAR:
1:90731d5: 		    case Types.LONGVARCHAR:
1:90731d5: 		    case Types.VARCHAR:
1:90731d5: 				ps.setString( param, ((String) value ) );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.BINARY:
1:90731d5: 		    case Types.LONGVARBINARY:
1:90731d5: 		    case Types.VARBINARY:
1:90731d5: 				ps.setBytes( param, (byte[]) value );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.CLOB:
1:90731d5: 				ps.setClob( param, ((Clob) value ) );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DATE:
1:90731d5: 				ps.setDate( param, ((java.sql.Date) value ) );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DECIMAL:
1:90731d5: 		    case Types.NUMERIC:
1:90731d5: 				ps.setBigDecimal( param, ((BigDecimal) value ) );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.DOUBLE:
1:90731d5: 				ps.setDouble( param, ((Double) value ).doubleValue() );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.REAL:
1:90731d5: 				ps.setFloat( param, ((Float) value ).floatValue() );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.INTEGER:
1:90731d5: 				ps.setInt( param, ((Integer) value ).intValue() );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.SMALLINT:
1:90731d5: 				ps.setShort( param, ((Short) value ).shortValue() );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.TIME:
1:90731d5: 				ps.setTime( param, (Time) value );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    case Types.TIMESTAMP:
1:90731d5: 				ps.setTimestamp( param, (Timestamp) value );
1:90731d5: 				break;
1:90731d5: 				
1:90731d5: 		    default:
1:90731d5: 				fail( "Unknown jdbc type: " + jdbcType );
1:90731d5: 				break;
1:90731d5: 		}
1:90731d5: 
1:90731d5: 	}
1:90731d5: 	
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:1d22c17: 	 * Stuff a PreparedStatement parameter given its 1-based parameter position.
1:1d22c17: 	 * The appropriate setXXX() method is determined by the Java type of the
1:1d22c17: 	 * value being stuffed. This method is useful for testing setXXX() methods
1:1d22c17: 	 * other than the most natural fit for the declared SQL type.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:1d22c17: 	protected	void	setParameter( PreparedStatement ps, int param, Object value )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		if ( value == null )
1:90731d5: 		{
1:90731d5: 			ps.setObject( param, null );
1:90731d5: 
2:90731d5: 			return;
1:90731d5: 		}
1:90731d5: 
1:90731d5: 		if ( value instanceof Boolean ) {  ps.setBoolean( param, ((Boolean) value).booleanValue() ); }
1:90731d5: 		else if ( value instanceof Byte ) { ps.setByte( param, ((Byte) value).byteValue() ); }
1:90731d5: 		else if ( value instanceof Short ) { ps.setShort( param, ((Short) value).shortValue() ); }
1:90731d5: 		else if ( value instanceof Integer ) { ps.setInt( param, ((Integer) value).intValue() ); }
1:90731d5: 		else if ( value instanceof Long ) { ps.setLong( param, ((Long) value).longValue() ); }
1:90731d5: 		else if ( value instanceof Float ) { ps.setFloat( param, ((Float) value).floatValue() ); }
1:90731d5: 		else if ( value instanceof Double ) { ps.setDouble( param, ((Double) value).doubleValue() ); }
1:90731d5: 		else if ( value instanceof String ) { ps.setString( param, ((String) value) ); }
1:90731d5: 		else { ps.setObject( param, value ); }
1:90731d5: 	}
1:90731d5: 	
1:90731d5: 
1:90731d5: 	////////////////////
1:90731d5: 	//
1:90731d5: 	//	QUERY GENERATION
1:90731d5: 	//
1:90731d5: 	////////////////////
1:90731d5: 
1:1d22c17: 	/**
1:1d22c17: 	 * <p>
1:1d22c17: 	 * Single quote a string. This is a helper routine for use in generating
1:1d22c17: 	 * SQL text.
1:1d22c17: 	 * </p>
1:1d22c17: 	 */
1:90731d5: 	protected	String	singleQuote( String text )
1:90731d5: 	{
1:90731d5: 		return "'" + text + "'";
1:90731d5: 	}
1:90731d5: 
1:90731d5: 	/////////////////////////////////////////////////////////////
1:90731d5: 	//
1:0438c35: 	//	EXTRA ASSERTIONS
1:0438c35: 	//
1:0438c35: 	/////////////////////////////////////////////////////////////
1:0438c35: 
1:0438c35: 	/**
1:0438c35: 	 * <p>
1:90731d5: 	 * Assert the values of a whole row.
1:0438c35: 	 * </p>
1:0438c35: 	 */
1:90731d5: 	public	void	assertRow
1:90731d5: 		( ResultSet rs, Object[] expectedRow )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		int		count = expectedRow.length;
1:90731d5: 
1:90731d5: 		for ( int i = 0; i < count; i++ )
1:90731d5: 		{
1:90731d5: 			int			columnNumber = i + 1;
1:90731d5: 			Object		expected = expectedRow[ i ];
1:90731d5: 			Object		actual = getColumn( rs, columnNumber, expected );
1:90731d5: 
1:90731d5: 			compareObjects( "Column number " + columnNumber, expected, actual );
1:90731d5: 		}
1:90731d5: 	}
1:90731d5: 
1:90731d5: 
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:90731d5: 	 * Assert a scalar result from a query.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	void	assertScalar
1:90731d5: 		( Connection conn, String queryText, Object expectedResult )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		PreparedStatement	ps = prepare( conn, queryText );
1:90731d5: 		ResultSet			rs = ps.executeQuery();
1:90731d5: 
1:90731d5: 		rs.next();
1:90731d5: 
1:90731d5: 		assertColumnEquals( queryText, rs, 1, expectedResult );
1:90731d5: 
1:90731d5: 		close( rs );
1:90731d5: 		close( ps );
1:90731d5: 	}
1:90731d5: 
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:1d22c17: 	 * Assert the values in a ResultSet for a given column across all rows.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	void	assertColumnEquals
1:90731d5: 		( ResultSet rs, int columnNumber, Object[] expectedValues )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		int		count = expectedValues.length;
1:90731d5: 
2:90731d5: 		for ( int i = 0; i < count; i++ )
1:90731d5: 		{
1:90731d5: 			rs.next();
1:90731d5: 			assertColumnEquals( Integer.toString( i ), rs, columnNumber, expectedValues[ i ] );
1:90731d5: 		}
1:90731d5: 	}
1:90731d5: 
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:90731d5: 	 * Assert a column's value.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:90731d5: 	public	void	assertColumnEquals
1:90731d5: 		( String message, ResultSet rs, int columnNumber, Object expectedValue )
1:90731d5: 		throws Exception
1:90731d5: 	{
1:90731d5: 		Object	actualValue = getColumn( rs, columnNumber, expectedValue );
1:90731d5: 
1:90731d5: 		compareObjects( message, expectedValue, actualValue );
1:90731d5: 	}
1:90731d5: 
1:90731d5: 	/**
1:90731d5: 	 * <p>
1:1d22c17: 	 * Assert two objects are equal, allowing nulls to be equal.
1:90731d5: 	 * </p>
1:90731d5: 	 */
1:0438c35: 	public	void	compareObjects( String message, Object left, Object right )
1:0438c35: 		throws Exception
1:0438c35: 	{
1:90731d5: 		message = message + "\n\t expected = " + left + "\n\t actual = " + right;
1:0438c35: 		
1:0438c35: 		if ( left == null )
1:0438c35: 		{
1:0438c35: 			assertNull( message, right );
1:0438c35: 		}
1:0438c35: 		else
1:0438c35: 		{
1:90731d5: 			assertNotNull( message, right );
1:0438c35: 
1:0438c35: 			if ( left instanceof byte[] ) { compareBytes( message, left, right ); }
1:0438c35: 			else if ( left instanceof java.util.Date ) { compareDates( message, left, right ); }
1:0438c35: 			else { assertTrue( message, left.equals( right ) ); }
1:0438c35: 		}
1:0438c35: 	}
1:0438c35: 
1:0438c35: 	/**
1:0438c35: 	 * <p>
1:1d22c17: 	 * Assert two byte arrays are equal, allowing nulls to be equal.
1:0438c35: 	 * </p>
1:0438c35: 	 */
1:0438c35: 	public	void	compareBytes( String message, Object left, Object right )
1:0438c35: 		throws Exception
1:0438c35: 	{
1:0438c35: 		if ( left == null )	{ assertNull( message, right ); }
1:0438c35: 		else { assertNotNull( right ); }
1:0438c35: 
1:0438c35: 		if ( !(left instanceof byte[] ) ) { fail( message ); }
1:0438c35: 		if ( !(right instanceof byte[] ) ) { fail( message ); }
1:0438c35: 
1:0438c35: 		byte[]	leftBytes = (byte[]) left;
1:0438c35: 		byte[]	rightBytes = (byte[]) right;
1:0438c35: 		int		count = leftBytes.length;
1:0438c35: 
1:0438c35: 		assertEquals( message, count, rightBytes.length );
1:0438c35: 		
1:0438c35: 		for ( int i = 0; i < count; i++ )
1:0438c35: 		{
1:0438c35: 			assertEquals( message + "[ " + i + " ]", leftBytes[ i ], rightBytes[ i ] );
1:0438c35: 		}
1:0438c35: 	}
1:1d22c17: 
1:0438c35: 	/**
1:0438c35: 	 * <p>
1:1d22c17: 	 * Assert two Dates are equal, allowing nulls to be equal.
1:0438c35: 	 * </p>
1:0438c35: 	 */
1:0438c35: 	public	void	compareDates( String message, Object left, Object right )
1:0438c35: 		throws Exception
1:0438c35: 	{
1:0438c35: 		if ( left == null )	{ assertNull( message, right ); }
1:0438c35: 		else { assertNotNull( right ); }
1:0438c35: 
1:0438c35: 		if ( !(left instanceof java.util.Date ) ) { fail( message ); }
1:0438c35: 		if ( !(right instanceof java.util.Date ) ) { fail( message ); }
1:0438c35: 
1:0438c35: 		assertEquals( message, left.toString(), right.toString() );
1:0438c35: 	}
1:0438c35: 	
1:0438c35: }
1:0438c35: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1: 				retval = rs.getBoolean( columnName );
1: 				retval = rs.getLong( columnName );
/////////////////////////////////////////////////////////////////////////
1: 				retval = rs.getDouble( columnName );
1: 				retval = rs.getFloat( columnName );
1: 				retval = rs.getInt( columnName );
1: 				retval = rs.getShort( columnName );
/////////////////////////////////////////////////////////////////////////
1: 		else if ( value instanceof Boolean ) { retval = rs.getBoolean( param ); }
1: 		else if ( value instanceof Byte ) { retval = rs.getByte( param ); }
1: 		else if ( value instanceof Short ) { retval = rs.getShort( param ); }
1: 		else if ( value instanceof Integer ) { retval = rs.getInt( param ); }
1: 		else if ( value instanceof Long ) { retval = rs.getLong( param ); }
1: 		else if ( value instanceof Float ) { retval = rs.getFloat( param ); }
1: 		else if ( value instanceof Double ) { retval = rs.getDouble( param ); }
/////////////////////////////////////////////////////////////////////////
1: 				retval = cs.getBoolean( arg );
1: 				retval = cs.getLong( arg );
/////////////////////////////////////////////////////////////////////////
1: 				retval = cs.getDouble( arg );
1: 				retval = cs.getFloat( arg );
1: 				retval = cs.getInt( arg );
1: 				retval = cs.getShort( arg );
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
1: 	private	static	final	String	TYPE = "type";
/////////////////////////////////////////////////////////////////////////
1: 		dropSchemaObject( conn, TABLE, name, false );
/////////////////////////////////////////////////////////////////////////
1: 		dropSchemaObject( conn, FUNCTION, name, false );
/////////////////////////////////////////////////////////////////////////
1: 		dropSchemaObject( conn, PROCEDURE, name, false );
1: 	}
1: 
1: 	/**
1: 	 * <p>
1: 	 * Drop a UDT regardless of whether it exists. If the UDT does
1: 	 * not exist, don't log an error unless
1: 	 * running in debug mode. This method is to be used for reinitializing
1: 	 * a schema in case a previous test run failed to clean up after itself.
1: 	 * Do not use this method if you need to verify that the UDT really exists.
1: 	 * </p>
1: 	 */
1: 	protected	static	void	dropUDT( Connection conn, String name )
1: 	{
1: 		dropSchemaObject( conn, TYPE, name, true );
/////////////////////////////////////////////////////////////////////////
1: 	protected	static	void	dropSchemaObject( Connection conn, String genus, String objectName, boolean restrict )
1:             String text = "drop " + genus + " " + objectName;
1:             if ( restrict ) { text = text + " restrict"; }
1: 			ps = prepare( conn, text );
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:38b2847
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	// Indexes into the array of client-specific strings. E.g.,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:1d22c17
/////////////////////////////////////////////////////////////////////////
1:  * for re-use by Derby JUnit tests. JUnit tests should extend this class.
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Vacuous constructor for JUnit machinery.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 		if ( _debug ) { alarm( text ); }
1: 	}
1: 
1: 	/**
1: 	 * <p>
1: 	 * Print a message regardless of whether we are running in debug mode.
1: 	 * </p>
1: 	 */
1: 	public	static	void	alarm( String text )
1: 	{
1: 		_outputStream.println( text );
1: 		_outputStream.flush();
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Load a client driver, given its particulars.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Get a connection to a database, using the default client.
1: 	 * </p>
1: 	 */
1: 	/**
1: 	 * <p>
1: 	 * Get a connection to a database, using the specified client.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Cobble together a connection URL.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Execute DDL statement.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Execute a SQL statement, given by the text argument. This thin
1: 	 * wrapper around the JDBC machinery logs the statement text when
1: 	 * running in debug mode.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Prepare a SQL statement, given by the text argument. This thin
1: 	 * wrapper around the JDBC machinery logs the statement text when
1: 	 * running in debug mode.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Prepare a SQL call statement, given by the text argument. This thin
1: 	 * wrapper around the JDBC machinery logs the statement text when
1: 	 * running in debug mode.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Scour out all the rows from a table.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Drop a table regardless of whether it exists. If the table does not
1: 	 * exist, don't log an error unless
1: 	 * running in debug mode. This method is to be used for reinitializing
1: 	 * a schema in case a previous test run failed to clean up after itself.
1: 	 * Do not use this method if you need to verify that the table really exists.
1: 	 * </p>
1: 	 */
1: 	/**
1: 	 * <p>
1: 	 * Drop a function regardless of whether it exists. If the function does not
1: 	 * exist, don't log an error unless
1: 	 * running in debug mode. This method is to be used for reinitializing
1: 	 * a schema in case a previous test run failed to clean up after itself.
1: 	 * Do not use this method if you need to verify that the function really exists.
1: 	 * </p>
1: 	 */
1: 	/**
1: 	 * <p>
1: 	 * Drop a procedure regardless of whether it exists. If the procedure does
1: 	 * not exist, don't log an error unless
1: 	 * running in debug mode. This method is to be used for reinitializing
1: 	 * a schema in case a previous test run failed to clean up after itself.
1: 	 * Do not use this method if you need to verify that the procedure really exists.
1: 	 * </p>
1: 	 */
1: 	/**
1: 	 * <p>
1: 	 * Drop a schema object regardless of whether it exists. If the object does
1: 	 * not exist, don't log an error unless
1: 	 * running in debug mode. This method is to be used for reinitializing
1: 	 * a schema in case a previous test run failed to clean up after itself.
1: 	 * Do not use this method if you need to verify that the object really exists.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 		catch (SQLException e)
1: 		{
1: 			if ( _debug ) { printStackTrace( e ); }
1: 		}
1: 	/**
1: 	 * <p>
1: 	 * Close a ResultSet. This method factors out the check for whether
1: 	 * the ResultSet was created in the first place. This tidies up the
1: 	 * caller's cleanup logic. If an error occurs, print it. Because this
1: 	 * method swallows the exception after printing it, do not call this
1: 	 * method if you want your test to halt on error.
1: 	 * </p>
1: 	 */
1: 		catch (SQLException e) { printStackTrace( e ); }
1: 
1: 	/**
1: 	 * <p>
1: 	 * Close a Statement. This method factors out the check for whether
1: 	 * the Statement was created in the first place. This tidies up the
1: 	 * caller's cleanup logic. If an error occurs, print it. Because this
1: 	 * method swallows the exception after printing it, do not call this
1: 	 * method if you want your test to halt on error.
1: 	 * </p>
1: 	 */
1: 		catch (SQLException e) { printStackTrace( e ); }
1: 
1: 	/**
1: 	 * <p>
1: 	 * Close a Connection. This method factors out the check for whether
1: 	 * the Connection was created in the first place. This tidies up the
1: 	 * caller's cleanup logic. If an error occurs, print it. Because this
1: 	 * method swallows the exception after printing it, do not call this
1: 	 * method if you want your test to halt on error.
1: 	 * </p>
1: 	 */
1: 		catch (SQLException e) { printStackTrace( e ); }
1: 	/**
1: 	 * <p>
1: 	 * Read a column from a ResultSet given its column name and expected jdbc
1: 	 * type. This method is useful if you are want to verify the getXXX() logic
1: 	 * most naturally fitting the declared SQL type.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Read a column from a ResultSet given its column position
1: 	 * and an expected Java type. This method is useful when
1: 	 * comparing ResultSets against expected values.
1: 	 * </p>
1: 	 *
1: 	 * @param	rs		The ResultSet to read.
1: 	 * @param	param	The column number (1-based)
1: 	 * @param	value	An object whose type is what we expect the column to be.
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Read an output argument from a CallableStatement given its 1-based
1: 	 * argument position and expected jdbc type. This is useful for
1: 	 * exercising the getXXX() methods most natural to a declared SQL type.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Stuff a PreparedStatement parameter given its 1-based parameter position
1: 	 * and expected jdbc type. This method is useful for testing the setXXX()
1: 	 * methods most natural for a declared SQL type.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Stuff a PreparedStatement parameter given its 1-based parameter position.
1: 	 * The appropriate setXXX() method is determined by the Java type of the
1: 	 * value being stuffed. This method is useful for testing setXXX() methods
1: 	 * other than the most natural fit for the declared SQL type.
1: 	 * </p>
1: 	 */
1: 	protected	void	setParameter( PreparedStatement ps, int param, Object value )
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * <p>
1: 	 * Single quote a string. This is a helper routine for use in generating
1: 	 * SQL text.
1: 	 * </p>
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	 * Assert the values in a ResultSet for a given column across all rows.
/////////////////////////////////////////////////////////////////////////
1: 	 * Assert two objects are equal, allowing nulls to be equal.
/////////////////////////////////////////////////////////////////////////
1: 	 * Assert two byte arrays are equal, allowing nulls to be equal.
/////////////////////////////////////////////////////////////////////////
1: 
1: 	 * Assert two Dates are equal, allowing nulls to be equal.
commit:4087714
/////////////////////////////////////////////////////////////////////////
1: import java.io.*;
1: import java.sql.*;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/** If you set this startup property to true, you will get chatty output. */
1: 	public	static	final			String	DEBUG_FLAG = "drb.tests.debug";
1: 	
1: 	public	static	final			int		SUCCESS_EXIT = 0;
1: 	public	static	final			int		FAILURE_EXIT = 1;
1: 
1: 	private	static	boolean		_debug;					// if true, we print chatty diagnostics
1: 	
1: 	private	static	PrintStream	_outputStream = System.out;	// where to print debug output
1: 
/////////////////////////////////////////////////////////////////////////
1: 	//	PUBLIC BEHAVIOR
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * <p>
1: 	 * Look for the system property which tells us whether to run
1: 	 * chattily.
1: 	 * </p>
1: 	 */
1: 	public	static	boolean	parseDebug()
1: 	{
1: 		_debug = Boolean.getBoolean( DEBUG_FLAG );
1: 
1: 		return true;
1: 	}
1: 		
1: 	/**
1: 	 * <p>
1: 	 * Debug code to print chatty informational messages.
1: 	 * </p>
1: 	 */
1: 	public	static	void	println( String text )
1: 	{
0: 		if ( _debug )
1: 		{
0: 			_outputStream.println( text );
0: 			_outputStream.flush();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * <p>
1: 	 * Print out a stack trace.
1: 	 * </p>
1: 	 */
1: 	public	static	void	printStackTrace( Throwable t )
1: 	{
1: 		while ( t != null )
1: 		{
1: 			t.printStackTrace( _outputStream );
1: 
1: 			if ( t instanceof SQLException )	{ t = ((SQLException) t).getNextException(); }
1: 			else { break; }
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * <p>
0: 	 * Return a meaningful exit status so that calling scripts can take
0: 	 * evasive action.
1: 	 * </p>
1: 	 */
0: 	public	void	exit( int exitStatus )
1: 	{
0: 		Runtime.getRuntime().exit( exitStatus );
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//
commit:0438c35
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.util
1: 
0: Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0: Licensed under the Apache License, Version 2.0 (the "License");
0: you may not use this file except in compliance with the License.
0: You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: /**
1:  * <p>
1:  * This class factors out utility methods (including assertion machinery)
0:  * for re-use by Derby JUnit tests.
1:  * </p>
1:  *
0:  * @author Rick
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.util;
1: 
1: import junit.framework.*;
1: 
1: public	class	DerbyJUnitTest	extends	TestCase
1: {
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTANTS
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	STATE
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTRUCTOR
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 	
1: 	public	DerbyJUnitTest() {}
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	EXTRA ASSERTIONS
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * <p>
0: 	 * Compare two objects, allowing nulls to be equal.
1: 	 * </p>
1: 	 */
1: 	public	void	compareObjects( String message, Object left, Object right )
1: 		throws Exception
1: 	{
1: 		if ( left == null )
1: 		{
1: 			assertNull( message, right );
1: 		}
1: 		else
1: 		{
0: 			assertNotNull( right );
1: 
1: 			if ( left instanceof byte[] ) { compareBytes( message, left, right ); }
1: 			else if ( left instanceof java.util.Date ) { compareDates( message, left, right ); }
1: 			else { assertTrue( message, left.equals( right ) ); }
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * <p>
0: 	 * Compare two byte arrays, allowing nulls to be equal.
1: 	 * </p>
1: 	 */
1: 	public	void	compareBytes( String message, Object left, Object right )
1: 		throws Exception
1: 	{
1: 		if ( left == null )	{ assertNull( message, right ); }
1: 		else { assertNotNull( right ); }
1: 
1: 		if ( !(left instanceof byte[] ) ) { fail( message ); }
1: 		if ( !(right instanceof byte[] ) ) { fail( message ); }
1: 
1: 		byte[]	leftBytes = (byte[]) left;
1: 		byte[]	rightBytes = (byte[]) right;
1: 		int		count = leftBytes.length;
1: 
1: 		assertEquals( message, count, rightBytes.length );
1: 		
1: 		for ( int i = 0; i < count; i++ )
1: 		{
1: 			assertEquals( message + "[ " + i + " ]", leftBytes[ i ], rightBytes[ i ] );
1: 		}
1: 	}
1: 	
1: 	/**
1: 	 * <p>
0: 	 * Compare two Dates, allowing nulls to be equal.
1: 	 * </p>
1: 	 */
1: 	public	void	compareDates( String message, Object left, Object right )
1: 		throws Exception
1: 	{
1: 		if ( left == null )	{ assertNull( message, right ); }
1: 		else { assertNotNull( right ); }
1: 
1: 		if ( !(left instanceof java.util.Date ) ) { fail( message ); }
1: 		if ( !(right instanceof java.util.Date ) ) { fail( message ); }
1: 
1: 		assertEquals( message, left.toString(), right.toString() );
1: 	}
1: 	
1: }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:90731d5
/////////////////////////////////////////////////////////////////////////
1: import java.math.*;
1: import java.util.*;
0: import org.apache.derby.tools.ij;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	public	static	final	String	DEFAULT_USER_NAME = "APP";
1: 	public	static	final	String	DEFAULT_PASSWORD = "APP";
1: 	public	static	final	String	DEFAULT_DATABASE_NAME = "wombat";
1: 
1: 	// because java.sql.Types.BOOLEAN doesn't exist in jdbc 2.0
1: 	protected	static	final			int		JDBC_BOOLEAN = 16;
1: 	
1: 	//
1: 	// For dropping schema objects
1: 	//
1: 	private	static	final	String	TABLE = "table";
1: 	private	static	final	String	FUNCTION = "function";
1: 	private	static	final	String	PROCEDURE = "procedure";
1: 	
1: 	//
1: 	// These are properties for the Derby connection URL.
1: 	//
0: 	private	static	final			String	SERVER_URL = "jdbc:derby://localhost:1527/";
1: 	private	static	final			String	CREATE_PROPERTY = "create=true";
1: 
1: 	//
0: 	// Indexes into the array of client-specific strings. E.g., DB2JCC_CLIENT,
1: 	// DERBY_CLIENT, and EMBEDDED_CLIENT.
1: 	//
1: 	public	static	final			int		DATABASE_URL = 0;
1: 	public	static	final			int		DRIVER_NAME = DATABASE_URL + 1;
1: 	public	static	final			int		FRAMEWORK_NAME = DRIVER_NAME + 1;
1: 
1: 	// indexed by DATABASE_URL and DRIVER_NAME
0: 	private	static	final	String[]	DB2JCC_CLIENT =
1: 	{
0: 		"jdbc:derby:net://localhost:1527/",
0: 		"com.ibm.db2.jcc.DB2Driver",
0: 		"DerbyNet"
1: 	};
1: 	private	static	final	String[]	DERBY_CLIENT =
1: 	{
1: 		"jdbc:derby://localhost:1527/",
1: 		"org.apache.derby.jdbc.ClientDriver",
1: 		"DerbyNetClient"
1: 	};
1: 	private	static	final	String[]	EMBEDDED_CLIENT =
1: 	{
1: 		"jdbc:derby:",
1: 		"org.apache.derby.jdbc.EmbeddedDriver",
1: 		"embedded"
1: 	};
1: 
1: 	public	static	final	String[][]	LEGAL_CLIENTS =
1: 	{
0: 		DB2JCC_CLIENT,
1: 		DERBY_CLIENT,
1: 		EMBEDDED_CLIENT
1: 	};
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	private	static	String		_databaseName;			// sandbox for tests
1: 	private	static	String[]	_defaultClientSettings;	// one of the clients in
1: 														// LEGAL_CLIENTS
0: 	private	static	boolean		_initializedForTestHarness;
1: 
/////////////////////////////////////////////////////////////////////////
0: 	 * Run under the old harness.
1: 	 * </p>
1: 	 */
0: 	public	static	void	runUnderOldHarness( String[] args, Test suite )
1: 		throws Exception
1: 	{
0: 		int			exitStatus = FAILURE_EXIT;
1: 
0: 		initializeForOldHarness( args );
1: 
0: 		TestResult	result = junit.textui.TestRunner.run( suite );
1: 			
0: 		exitStatus = result.errorCount() + result.failureCount();
1: 
0: 		Runtime.getRuntime().exit( exitStatus );
1: 	}
1: 
1: 	/**
1: 	 * <p>
0: 	 * Initialize a test suite to run under the old test harness.
1: 	 * </p>
1: 	 */
0: 	public	static	void	initializeForOldHarness( String[] args )
1: 		throws Exception
1: 	{
0: 		if ( _initializedForTestHarness ) { return; }
1: 		
0: 		parseDebug();
0: 		setDatabaseName( DEFAULT_DATABASE_NAME );
0: 		findClientFromProperties();
1: 		
0: 		// create database
0: 		ij.getPropertyArg( args );
0: 		Connection conn = ij.startJBMS();
1: 
0: 		_initializedForTestHarness = true;
1: 	}
1: 
1: 	/**
1: 	 * <p>
1: 	 * Return true if we're using the embedded driver.
1: 	 * </p>
1: 	 */
1: 	public	boolean	usingEmbeddedClient() { return ( _defaultClientSettings == EMBEDDED_CLIENT ); }
1: 
1: 	/**
1: 	 * <p>
1: 	 * Return true if we're using the derby client
1: 	 * </p>
1: 	 */
1: 	public	boolean	usingDerbyClient() { return ( _defaultClientSettings == DERBY_CLIENT ); }
1: 
1: 	/**
1: 	 * <p>
0: 	 * Return true if we're using the db2 client
1: 	 * </p>
1: 	 */
0: 	public	boolean	usingDB2Client() { return ( _defaultClientSettings == DB2JCC_CLIENT ); }
1: 
1: 	/**
1: 	 * <p>
1: 	 * Get the client we're using.
1: 	 * </p>
1: 	 */
1: 	public	static	String[]	getClientSettings() { return _defaultClientSettings; }
1: 
1: 	/**
1: 	 * <p>
1: 	 * Set the client we're going to use.
1: 	 * </p>
1: 	 */
1: 	public	static	void		setClient( String[] client ) { _defaultClientSettings = client; }
1: 
1: 	/**
1: 	 * <p>
1: 	 * Set the database name.
1: 	 * </p>
1: 	 */
1: 	public	static	void	setDatabaseName( String databaseName ) { _databaseName = databaseName; }
1: 	
1: 	/**
1: 	 * <p>
1: 	 * Force the debugging state. Useful for debugging under the test harness.
1: 	 * </p>
1: 	 */
1: 	public	static	void	setDebug( boolean value ) { _debug = value; }
1: 
1: 	/**
1: 	 * <p>
/////////////////////////////////////////////////////////////////////////
1: 		
/////////////////////////////////////////////////////////////////////////
0: 	 * Determine the client to use based on system properties.
1: 	 * </p>
1: 	 */
0: 	public	static	void	findClientFromProperties()
1: 		throws Exception
1: 	{
0: 		Properties		systemProps = System.getProperties();
0: 		String			frameworkName = systemProps.getProperty
0: 			( "framework", EMBEDDED_CLIENT[ FRAMEWORK_NAME ] );
0: 		int				count = LEGAL_CLIENTS.length;
1: 
1: 		for ( int i = 0; i < count; i++ )
1: 		{
0: 			String[]	candidate = LEGAL_CLIENTS[ i ];
1: 
0: 			if ( candidate[ FRAMEWORK_NAME ].equals( frameworkName ) )
1: 			{
0: 				_defaultClientSettings = candidate;
1: 				return;
1: 			}
1: 		}
1: 
0: 		throw new Exception( "Unrecognized framework: " + frameworkName );
1: 	}
1: 
1: 	/**
1: 	 * <p>
/////////////////////////////////////////////////////////////////////////
1: 	//	CONNECTION MANAGEMENT
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	protected	static	boolean	faultInDriver( String[] clientSettings )
1: 	{
1: 		String	currentClientName = clientSettings[ DRIVER_NAME ];
1: 		
1: 		try {
1: 			Class.forName( currentClientName );
1: 
1: 			return true;
1: 		}
1: 		catch (Exception e)
1: 		{
1: 			println( "Could not find " + currentClientName );
1: 			return false;
1: 		}
1: 	}
1: 
0: 	// Get a connection to the server.
1: 	protected	static	Connection	getConnection()
1: 		throws Exception
1: 	{
1: 		return getConnection( _defaultClientSettings, _databaseName, new Properties() );
1: 	}
1: 	protected	static	Connection	getConnection
1: 	(
1: 	    String[]	clientSettings,
1: 		String		databaseName,
1: 		Properties	properties
1: 	)
1: 		throws Exception
1: 	{
1: 		faultInDriver( clientSettings );
1: 
1: 		properties.put( "user", DEFAULT_USER_NAME );
1: 		properties.put( "password", DEFAULT_PASSWORD );
1: 		properties.put( "retreiveMessagesFromServerOnGetMessage", "true" );
1: 
1: 		Connection		conn = DriverManager.getConnection
1: 			( makeDatabaseURL( clientSettings, databaseName ), properties );
1: 
1: 		println( "Connection is a " + conn.getClass().getName() );
1: 		
1: 		return conn;
1: 	}
1: 
0: 	// Build the connection URL.
1: 	private	static	String	makeDatabaseURL( String[] clientSettings, String databaseName )
1: 	{
1: 		return clientSettings[ DATABASE_URL ] + databaseName;
1: 	}
1: 
0: 	/**
0: 	 * <p>
1: 	 * Create an empty database.
0: 	 * </p>
0: 	 */
1: 	protected	void	createDB( String databaseName )
1: 		throws Exception
1: 	{
1: 		String[]	clientSettings = getClientSettings();
1: 		String		dbURL = makeDatabaseURL( clientSettings, databaseName );
1: 
1: 		dbURL = dbURL + ';' + CREATE_PROPERTY;
1: 
1: 		Properties	properties = new Properties();
1: 
1: 		properties.put( "user", DEFAULT_USER_NAME );
1: 		properties.put( "password", DEFAULT_PASSWORD );
1: 
1: 		faultInDriver( clientSettings );
1: 
1: 		Connection		conn = DriverManager.getConnection( dbURL, properties );
1: 
1: 		conn.close();
1: 	}
1: 
1: 	///////////////
1: 	//
1: 	//	SQL MINIONS
1: 	//
1: 	///////////////
1: 
1: 	protected	static	void	executeDDL( Connection conn, String text )
1: 		throws SQLException
1: 	{
1: 		PreparedStatement	ps = null;
1: 
1: 		try {
1: 			ps = prepare( conn, text );
1: 
1: 			ps.execute();
1: 		}
1: 		finally { close( ps ); }
1: 	}
1: 	
1: 	//
0: 	// Thin wrapper around statement execution to support debugging.
1: 	//
1: 	protected	static	void	execute( Connection conn, String text )
1: 		throws SQLException
1: 	{
1: 		PreparedStatement	ps = prepare( conn, text );
1: 
1: 		ps.execute();
1: 		close( ps );
1: 	}
1: 
1: 	//
0: 	// Thin wrapper around jdbc layer to support debugging.
1: 	//
1: 	protected	static	PreparedStatement	prepare( Connection conn, String text )
1: 		throws SQLException
1: 	{
1: 		println( "Preparing: " + text );
1: 
1: 		return conn.prepareStatement( text );
1: 	}
1: 
1: 	//
0: 	// Thin wrapper around jdbc layer to support debugging.
1: 	//
1: 	protected	static	CallableStatement	prepareCall( Connection conn, String text )
1: 		throws SQLException
1: 	{
1: 		println( "Preparing procedure call: '" + text + "'" );
1: 
1: 		CallableStatement	cs = conn.prepareCall( text );
1: 
1: 		return cs;
1: 	}
1: 
1: 	protected	static	void	truncateTable( Connection conn, String name )
1: 		throws SQLException
1: 	{
1: 		PreparedStatement	ps = prepare( conn, "delete from " + name );
1: 
1: 		ps.execute();
1: 	}
1: 
1: 	protected	static	void	dropTable( Connection conn, String name )
1: 	{
0: 		dropSchemaObject( conn, TABLE, name );
1: 	}
1: 
1: 	protected	static	void	dropFunction( Connection conn, String name )
1: 	{
0: 		dropSchemaObject( conn, FUNCTION, name );
1: 	}
1: 
1: 	protected	static	void	dropProcedure( Connection conn, String name )
1: 	{
0: 		dropSchemaObject( conn, PROCEDURE, name );
1: 	}
1: 
0: 	protected	static	void	dropSchemaObject( Connection conn, String genus, String objectName )
1: 	{
1: 		PreparedStatement	ps = null;
1: 		
1: 		try {
0: 			ps = prepare( conn, "drop " + genus + " " + objectName );
1: 
1: 			ps.execute();
1: 		}
0: 		catch (SQLException e) {}
1: 
1: 		close( ps );
1: 	}
1: 
1: 	//
0: 	// Swallow uninteresting exceptions when disposing of jdbc objects.
1: 	//
1: 	protected	static	void	close( ResultSet rs )
1: 	{
1: 		try {
1: 			if ( rs != null ) { rs.close(); }
1: 		}
0: 		catch (SQLException e) {}
1: 	}	
1: 	protected	static	void	close( Statement statement )
1: 	{
1: 		try {
1: 			if ( statement != null ) { statement.close(); }
1: 		}
0: 		catch (SQLException e) {}
1: 	}
1: 	protected	static	void	close( Connection conn )
1: 	{
1: 		try {
1: 			if ( conn != null ) { conn.close(); }
1: 		}
0: 		catch (SQLException e) {}
1: 	}
1: 
0: 	// read a column from a result set
1: 	protected	Object	getColumn( ResultSet rs, String columnName, int jdbcType )
1: 		throws Exception
1: 	{
1: 		Object		retval = null;
1: 
1: 		switch( jdbcType )
1: 		{
1: 		    case JDBC_BOOLEAN:
0: 				retval = new Boolean( rs.getBoolean( columnName ) );
1: 				break;
1: 				
1: 		    case Types.BIGINT:
0: 				retval = new Long( rs.getLong( columnName ) );
1: 				break;
1: 				
1: 		    case Types.BLOB:
1: 				retval = rs.getBlob( columnName );
1: 				break;
1: 				
1: 		    case Types.CHAR:
1: 		    case Types.LONGVARCHAR:
1: 		    case Types.VARCHAR:
1: 				retval = rs.getString( columnName );
1: 				break;
1: 				
1: 		    case Types.BINARY:
1: 		    case Types.LONGVARBINARY:
1: 		    case Types.VARBINARY:
1: 				retval = rs.getBytes( columnName );
1: 				break;
1: 				
1: 		    case Types.CLOB:
1: 				retval = rs.getClob( columnName );
1: 				break;
1: 				
1: 		    case Types.DATE:
1: 				retval = rs.getDate( columnName );
1: 				break;
1: 				
1: 		    case Types.DECIMAL:
1: 		    case Types.NUMERIC:
1: 				retval = rs.getBigDecimal( columnName );
1: 				break;
1: 				
1: 		    case Types.DOUBLE:
0: 				retval = new Double( rs.getDouble( columnName ) );
1: 				break;
1: 				
1: 		    case Types.REAL:
0: 				retval = new Float( rs.getFloat( columnName ) );
1: 				break;
1: 				
1: 		    case Types.INTEGER:
0: 				retval = new Integer( rs.getInt( columnName ) );
1: 				break;
1: 				
1: 		    case Types.SMALLINT:
0: 				retval = new Short( rs.getShort( columnName ) );
1: 				break;
1: 				
1: 		    case Types.TIME:
1: 				retval = rs.getTime( columnName );
1: 				break;
1: 				
1: 		    case Types.TIMESTAMP:
1: 				retval = rs.getTimestamp( columnName );
1: 				break;
1: 				
1: 		    default:
1: 				fail( "Unknown jdbc type " + jdbcType + " used to retrieve column: " + columnName );
1: 				break;
1: 		}
1: 
1: 		if ( rs.wasNull() ) { retval = null; }
1: 
1: 		return retval;
1: 	}
1: 
1: 	//
0: 	// Get a column based on an expected return value.
1: 	//
1: 	protected	Object	getColumn( ResultSet rs, int param, Object value )
1: 		throws Exception
1: 	{
1: 		Object		retval;
1: 		
1: 		if ( value == null )
1: 		{
1: 			retval = rs.getObject( param );
1: 		}
0: 		else if ( value instanceof Boolean ) { retval = new Boolean( rs.getBoolean( param ) ); }
0: 		else if ( value instanceof Byte ) { retval = new Byte( rs.getByte( param ) ); }
0: 		else if ( value instanceof Short ) { retval = new Short( rs.getShort( param ) ); }
0: 		else if ( value instanceof Integer ) { retval = new Integer( rs.getInt( param ) ); }
0: 		else if ( value instanceof Long ) { retval = new Long( rs.getLong( param ) ); }
0: 		else if ( value instanceof Float ) { retval = new Float( rs.getFloat( param ) ); }
0: 		else if ( value instanceof Double ) { retval = new Double( rs.getDouble( param ) ); }
1: 		else if ( value instanceof String ) { retval = rs.getString( param ); }
1: 		else if ( value instanceof BigDecimal ) { retval = rs.getBigDecimal( param ); }
1: 		else { retval = rs.getObject( param ); }
1: 
1: 		if ( rs.wasNull() ) { retval = null; }
1: 
1: 		return retval;
1: 	}
1: 
1: 
1: 	
0: 	// get an output argument from a call to a stored procedure
1: 	protected	Object	getOutArg( CallableStatement cs, int arg, int jdbcType )
1: 		throws Exception
1: 	{
1: 		Object		retval = null;
1: 
1: 		switch( jdbcType )
1: 		{
1: 		    case JDBC_BOOLEAN:
0: 				retval = new Boolean( cs.getBoolean( arg ) );
1: 				break;
1: 				
1: 		    case Types.BIGINT:
0: 				retval = new Long( cs.getLong( arg ) );
1: 				break;
1: 				
1: 		    case Types.BLOB:
1: 				retval = cs.getBlob( arg );
1: 				break;
1: 				
1: 		    case Types.CHAR:
1: 		    case Types.LONGVARCHAR:
1: 		    case Types.VARCHAR:
1: 				retval = cs.getString( arg );
1: 				break;
1: 				
1: 		    case Types.BINARY:
1: 		    case Types.LONGVARBINARY:
1: 		    case Types.VARBINARY:
1: 				retval = cs.getBytes( arg );
1: 				break;
1: 				
1: 		    case Types.CLOB:
1: 				retval = cs.getClob( arg );
1: 				break;
1: 				
1: 		    case Types.DATE:
1: 				retval = cs.getDate( arg );
1: 				break;
1: 				
1: 		    case Types.DECIMAL:
1: 		    case Types.NUMERIC:
1: 				retval = cs.getBigDecimal( arg );
1: 				break;
1: 				
1: 		    case Types.DOUBLE:
0: 				retval = new Double( cs.getDouble( arg ) );
1: 				break;
1: 				
1: 		    case Types.REAL:
0: 				retval = new Float( cs.getFloat( arg ) );
1: 				break;
1: 				
1: 		    case Types.INTEGER:
0: 				retval = new Integer( cs.getInt( arg ) );
1: 				break;
1: 				
1: 		    case Types.SMALLINT:
0: 				retval = new Short( cs.getShort( arg ) );
1: 				break;
1: 				
1: 		    case Types.TIME:
1: 				retval = cs.getTime( arg );
1: 				break;
1: 				
1: 		    case Types.TIMESTAMP:
1: 				retval = cs.getTimestamp( arg );
1: 				break;
1: 				
1: 		    default:
1: 				fail( "Unknown jdbc type " + jdbcType + " used to retrieve column: " + arg );
1: 				break;
1: 		}
1: 
1: 		if ( cs.wasNull() ) { retval = null; }
1: 
1: 		return retval;
1: 	}
1: 
1: 	//
0: 	// Logic for stuffing a data value into a column, given its type.
1: 	//
1: 	protected	void	setParameter( PreparedStatement ps, int param, int jdbcType, Object value )
1: 		throws Exception
1: 	{
1: 		if ( value == null )
1: 		{
1: 			ps.setNull( param, jdbcType );
1: 
1: 			return;
1: 		}
1: 
1: 		switch( jdbcType )
1: 		{
1: 		    case JDBC_BOOLEAN:
1: 				ps.setBoolean( param, ((Boolean) value ).booleanValue() );
1: 				break;
1: 				
1: 		    case Types.BIGINT:
1: 				ps.setLong( param, ((Long) value ).longValue() );
1: 				break;
1: 				
1: 		    case Types.BLOB:
1: 				ps.setBlob( param, ((Blob) value ) );
1: 				break;
1: 				
1: 		    case Types.CHAR:
1: 		    case Types.LONGVARCHAR:
1: 		    case Types.VARCHAR:
1: 				ps.setString( param, ((String) value ) );
1: 				break;
1: 				
1: 		    case Types.BINARY:
1: 		    case Types.LONGVARBINARY:
1: 		    case Types.VARBINARY:
1: 				ps.setBytes( param, (byte[]) value );
1: 				break;
1: 				
1: 		    case Types.CLOB:
1: 				ps.setClob( param, ((Clob) value ) );
1: 				break;
1: 				
1: 		    case Types.DATE:
1: 				ps.setDate( param, ((java.sql.Date) value ) );
1: 				break;
1: 				
1: 		    case Types.DECIMAL:
1: 		    case Types.NUMERIC:
1: 				ps.setBigDecimal( param, ((BigDecimal) value ) );
1: 				break;
1: 				
1: 		    case Types.DOUBLE:
1: 				ps.setDouble( param, ((Double) value ).doubleValue() );
1: 				break;
1: 				
1: 		    case Types.REAL:
1: 				ps.setFloat( param, ((Float) value ).floatValue() );
1: 				break;
1: 				
1: 		    case Types.INTEGER:
1: 				ps.setInt( param, ((Integer) value ).intValue() );
1: 				break;
1: 				
1: 		    case Types.SMALLINT:
1: 				ps.setShort( param, ((Short) value ).shortValue() );
1: 				break;
1: 				
1: 		    case Types.TIME:
1: 				ps.setTime( param, (Time) value );
1: 				break;
1: 				
1: 		    case Types.TIMESTAMP:
1: 				ps.setTimestamp( param, (Timestamp) value );
1: 				break;
1: 				
1: 		    default:
1: 				fail( "Unknown jdbc type: " + jdbcType );
1: 				break;
1: 		}
1: 
1: 	}
1: 	
1: 	//
0: 	// Logic for stuffing a data value into a column
1: 	//
0: 	protected	void	setParameter( PreparedStatement ps, int param,Object value )
1: 		throws Exception
1: 	{
1: 		if ( value == null )
1: 		{
1: 			ps.setObject( param, null );
1: 
1: 			return;
1: 		}
1: 
1: 		if ( value instanceof Boolean ) {  ps.setBoolean( param, ((Boolean) value).booleanValue() ); }
1: 		else if ( value instanceof Byte ) { ps.setByte( param, ((Byte) value).byteValue() ); }
1: 		else if ( value instanceof Short ) { ps.setShort( param, ((Short) value).shortValue() ); }
1: 		else if ( value instanceof Integer ) { ps.setInt( param, ((Integer) value).intValue() ); }
1: 		else if ( value instanceof Long ) { ps.setLong( param, ((Long) value).longValue() ); }
1: 		else if ( value instanceof Float ) { ps.setFloat( param, ((Float) value).floatValue() ); }
1: 		else if ( value instanceof Double ) { ps.setDouble( param, ((Double) value).doubleValue() ); }
1: 		else if ( value instanceof String ) { ps.setString( param, ((String) value) ); }
1: 		else { ps.setObject( param, value ); }
1: 	}
1: 	
1: 
1: 	////////////////////
1: 	//
1: 	//	QUERY GENERATION
1: 	//
1: 	////////////////////
1: 
1: 	protected	String	singleQuote( String text )
1: 	{
1: 		return "'" + text + "'";
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	 * Assert the values of a whole row.
0: 	 * </p>
0: 	 */
1: 	public	void	assertRow
1: 		( ResultSet rs, Object[] expectedRow )
1: 		throws Exception
1: 	{
1: 		int		count = expectedRow.length;
1: 
1: 		for ( int i = 0; i < count; i++ )
1: 		{
1: 			int			columnNumber = i + 1;
1: 			Object		expected = expectedRow[ i ];
1: 			Object		actual = getColumn( rs, columnNumber, expected );
1: 
1: 			compareObjects( "Column number " + columnNumber, expected, actual );
1: 		}
1: 	}
1: 
1: 
0: 	/**
0: 	 * <p>
1: 	 * Assert a scalar result from a query.
0: 	 * </p>
0: 	 */
1: 	public	void	assertScalar
1: 		( Connection conn, String queryText, Object expectedResult )
1: 		throws Exception
1: 	{
1: 		PreparedStatement	ps = prepare( conn, queryText );
1: 		ResultSet			rs = ps.executeQuery();
1: 
1: 		rs.next();
1: 
1: 		assertColumnEquals( queryText, rs, 1, expectedResult );
1: 
1: 		close( rs );
1: 		close( ps );
1: 	}
1: 
0: 	/**
0: 	 * <p>
0: 	 * Assert a the values in a ResultSet for a given column across all rows.
0: 	 * </p>
0: 	 */
1: 	public	void	assertColumnEquals
1: 		( ResultSet rs, int columnNumber, Object[] expectedValues )
1: 		throws Exception
1: 	{
1: 		int		count = expectedValues.length;
1: 
1: 		for ( int i = 0; i < count; i++ )
1: 		{
1: 			rs.next();
1: 			assertColumnEquals( Integer.toString( i ), rs, columnNumber, expectedValues[ i ] );
1: 		}
1: 	}
1: 
0: 	/**
0: 	 * <p>
1: 	 * Assert a column's value.
0: 	 * </p>
0: 	 */
1: 	public	void	assertColumnEquals
1: 		( String message, ResultSet rs, int columnNumber, Object expectedValue )
1: 		throws Exception
1: 	{
1: 		Object	actualValue = getColumn( rs, columnNumber, expectedValue );
1: 
1: 		compareObjects( message, expectedValue, actualValue );
1: 	}
1: 
0: 	/**
0: 	 * <p>
1: 		message = message + "\n\t expected = " + left + "\n\t actual = " + right;
1: 		
1: 			assertNotNull( message, right );
============================================================================