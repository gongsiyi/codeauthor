1:33776ff: /*
41:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.Decimal
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
9:33776ff: */
1:33776ff: package org.apache.derby.client.am;
1:33776ff: 
1:3419748: import java.math.BigDecimal;
1:69e3d06: import java.math.BigInteger;
1:5d2e2bd: import org.apache.derby.shared.common.reference.SQLState;
1:5d2e2bd: import org.apache.derby.shared.common.i18n.MessageUtil;
1:5d2e2bd: 
9:33776ff: /**
1:70f7692:  * Converters from fixed point decimal bytes to <code>java.math.BigDecimal</code>, <code>double</code>, or
1:70f7692:  * <code>long</code>.
1:33776ff:  */
1:70f7692: public class Decimal {
1:70f7692:     /**
1:70f7692:      * Packed Decimal representation
1:70f7692:      */
1:70f7692:     public final static int PACKED_DECIMAL = 0x30;
1:5d2e2bd:     
1:23ecfcf:     private static final MessageUtil msgutil = SqlException.getMessageUtil();
1:33776ff: 
1:70f7692:     //--------------------------private constants---------------------------------
1:33776ff: 
1:70f7692:     private static final int[][] tenRadixMagnitude = {
1:70f7692:         {0x3b9aca00}, // 10^9
1:70f7692:         {0x0de0b6b3, 0xa7640000}, // 10^18
1:70f7692:         {0x033b2e3c, 0x9fd0803c, 0xe8000000}, // 10^27
1:70f7692:     };
1:33776ff: 
1:70f7692:     //--------------------------constructors--------------------------------------
1:33776ff: 
1:70f7692:     // Hide the default constructor, this is a static class.
1:70f7692:     private Decimal() {
33:33776ff:     }
1:33776ff: 
1:70f7692:     //--------------------------private helper methods----------------------------
1:33776ff: 
1:70f7692:     /**
1:70f7692:      * Convert a range of packed nybbles (up to 9 digits without overflow) to an int. Note that for performance purpose,
1:70f7692:      * it does not do array-out-of-bound checking.
1:70f7692:      */
1:70f7692:     private static final int packedNybblesToInt(byte[] buffer,
4:70f7692:                                                 int offset,
1:70f7692:                                                 int startNybble,
1:70f7692:                                                 int numberOfNybbles) {
1:70f7692:         int value = 0;
1:33776ff: 
1:70f7692:         int i = startNybble / 2;
1:70f7692:         if ((startNybble % 2) != 0) {
1:70f7692:             // process low nybble of the first byte if necessary.
1:70f7692:             value += buffer[offset + i] & 0x0F;
1:70f7692:             i++;
1:33776ff:         }
1:33776ff: 
1:70f7692:         int endNybble = startNybble + numberOfNybbles - 1;
1:70f7692:         for (; i < (endNybble + 1) / 2; i++) {
1:70f7692:             value = value * 10 + ((buffer[offset + i] & 0xF0) >>> 4); // high nybble.
1:70f7692:             value = value * 10 + (buffer[offset + i] & 0x0F);        // low nybble.
1:70f7692:         }
1:33776ff: 
1:70f7692:         if ((endNybble % 2) == 0) {
2:70f7692:             // process high nybble of the last byte if necessary.
1:70f7692:             value = value * 10 + ((buffer[offset + i] & 0xF0) >>> 4);
1:70f7692:         }
1:33776ff: 
1:70f7692:         return value;
1:70f7692:     }
1:33776ff: 
1:70f7692:     /**
1:70f7692:      * Convert a range of packed nybbles (up to 18 digits without overflow) to a long. Note that for performance
1:70f7692:      * purpose, it does not do array-out-of-bound checking.
1:70f7692:      */
1:70f7692:     private static final long packedNybblesToLong(byte[] buffer,
1:70f7692:                                                   int offset,
1:70f7692:                                                   int startNybble,
1:70f7692:                                                   int numberOfNybbles) {
1:70f7692:         long value = 0;
1:70f7692: 
1:70f7692:         int i = startNybble / 2;
1:70f7692:         if ((startNybble % 2) != 0) {
1:70f7692:             // process low nybble of the first byte if necessary.
1:70f7692:             value += buffer[offset + i] & 0x0F;
1:70f7692:             i++;
1:70f7692:         }
1:70f7692: 
1:70f7692:         int endNybble = startNybble + numberOfNybbles - 1;
1:70f7692:         for (; i < (endNybble + 1) / 2; i++) {
1:70f7692:             value = value * 10 + ((buffer[offset + i] & 0xF0) >>> 4); // high nybble.
1:70f7692:             value = value * 10 + (buffer[offset + i] & 0x0F);        // low nybble.
1:70f7692:         }
1:33776ff: 
1:70f7692:         if ((endNybble % 2) == 0) {
1:70f7692:             // process high nybble of the last byte if necessary.
1:70f7692:             value = value * 10 + ((buffer[offset + i] & 0xF0) >>> 4);
1:33776ff:         }
1:33776ff: 
1:70f7692:         return value;
1:33776ff:     }
1:33776ff: 
1:70f7692:     /**
1:70f7692:      * Compute the int array of magnitude from input value segments.
1:70f7692:      */
1:70f7692:     private static final int[] computeMagnitude(int[] input) {
1:70f7692:         int length = input.length;
1:70f7692:         int[] mag = new int[length];
1:33776ff: 
1:70f7692:         mag[length - 1] = input[length - 1];
1:70f7692:         for (int i = 0; i < length - 1; i++) {
1:70f7692:             int carry = 0;
1:70f7692:             int j = tenRadixMagnitude[i].length - 1;
1:70f7692:             int k = length - 1;
1:70f7692:             for (; j >= 0; j--, k--) {
1:70f7692:                 long product = (input[length - 2 - i] & 0xFFFFFFFFL) * (tenRadixMagnitude[i][j] & 0xFFFFFFFFL)
1:70f7692:                         + (mag[k] & 0xFFFFFFFFL) // add previous value
1:70f7692:                         + (carry & 0xFFFFFFFFL); // add carry
1:70f7692:                 carry = (int) (product >>> 32);
1:70f7692:                 mag[k] = (int) (product & 0xFFFFFFFFL);
1:70f7692:             }
1:70f7692:             mag[k] = (int) carry;
1:70f7692:         }
1:70f7692:         return mag;
1:33776ff:     }
1:33776ff: 
1:70f7692:     //--------------entry points for runtime representation-----------------------
1:33776ff: 
1:70f7692:     /**
1:70f7692:      * Build a <code>java.math.BigDecimal</code> from a fixed point decimal byte representation.
1:70f7692:      *
1:70f7692:      * @throws IllegalArgumentException if the specified representation is not recognized.
1:70f7692:      */
1:0326967:     static BigDecimal getBigDecimal(
1:69e3d06:             byte[] buffer,
1:69e3d06:             int offset,
1:69e3d06:             int precision,
1:a0b8943:             int scale) {
1:69e3d06: 
1:70f7692:         // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
1:70f7692:         int length = precision / 2 + 1;
1:69e3d06: 
1:70f7692:         // check for sign.
1:70f7692:         int signum;
1:70f7692:         if ((buffer[offset + length - 1] & 0x0F) == 0x0D) {
1:70f7692:             signum = -1;
1:70f7692:         } else {
1:70f7692:             signum = 1;
1:70f7692:         }
1:33776ff: 
1:4020781:         if (precision <= 18) {
1:70f7692:             // can be handled by long without overflow.
1:70f7692:             long value = packedNybblesToLong(buffer, offset, 0, length * 2 - 1);
1:4020781:             if (signum < 0) {
1:4020781:                 value = -value;
1:4020781:             }
1:4020781:             return BigDecimal.valueOf(value, scale);
1:70f7692:         } else if (precision <= 27) {
1:70f7692:             // get the value of last 9 digits (5 bytes).
1:70f7692:             int lo = packedNybblesToInt(buffer, offset, (length - 5) * 2, 9);
1:70f7692:             // get the value of another 9 digits (5 bytes).
1:70f7692:             int me = packedNybblesToInt(buffer, offset, (length - 10) * 2 + 1, 9);
1:70f7692:             // get the value of the rest digits.
1:70f7692:             int hi = packedNybblesToInt(buffer, offset, 0, (length - 10) * 2 + 1);
1:33776ff: 
1:70f7692:             // compute the int array of magnitude.
1:70f7692:             int[] value = computeMagnitude(new int[]{hi, me, lo});
1:33776ff: 
3:70f7692:             // convert value to a byte array of magnitude.
1:70f7692:             byte[] magnitude = new byte[12];
1:70f7692:             magnitude[0] = (byte) (value[0] >>> 24);
1:70f7692:             magnitude[1] = (byte) (value[0] >>> 16);
1:70f7692:             magnitude[2] = (byte) (value[0] >>> 8);
1:70f7692:             magnitude[3] = (byte) (value[0]);
1:70f7692:             magnitude[4] = (byte) (value[1] >>> 24);
1:70f7692:             magnitude[5] = (byte) (value[1] >>> 16);
1:70f7692:             magnitude[6] = (byte) (value[1] >>> 8);
1:70f7692:             magnitude[7] = (byte) (value[1]);
1:70f7692:             magnitude[8] = (byte) (value[2] >>> 24);
1:70f7692:             magnitude[9] = (byte) (value[2] >>> 16);
1:70f7692:             magnitude[10] = (byte) (value[2] >>> 8);
1:70f7692:             magnitude[11] = (byte) (value[2]);
1:33776ff: 
1:69e3d06:             return new BigDecimal(new BigInteger(signum, magnitude), scale);
1:70f7692:         } else if (precision <= 31) {
1:70f7692:             // get the value of last 9 digits (5 bytes).
1:70f7692:             int lo = packedNybblesToInt(buffer, offset, (length - 5) * 2, 9);
1:70f7692:             // get the value of another 9 digits (5 bytes).
1:70f7692:             int meLo = packedNybblesToInt(buffer, offset, (length - 10) * 2 + 1, 9);
1:70f7692:             // get the value of another 9 digits (5 bytes).
1:70f7692:             int meHi = packedNybblesToInt(buffer, offset, (length - 14) * 2, 9);
1:70f7692:             // get the value of the rest digits.
1:70f7692:             int hi = packedNybblesToInt(buffer, offset, 0, (length - 14) * 2);
1:33776ff: 
1:70f7692:             // compute the int array of magnitude.
1:70f7692:             int[] value = computeMagnitude(new int[]{hi, meHi, meLo, lo});
1:70f7692: 
1:70f7692:             // convert value to a byte array of magnitude.
1:70f7692:             byte[] magnitude = new byte[16];
1:70f7692:             magnitude[0] = (byte) (value[0] >>> 24);
1:70f7692:             magnitude[1] = (byte) (value[0] >>> 16);
1:70f7692:             magnitude[2] = (byte) (value[0] >>> 8);
1:70f7692:             magnitude[3] = (byte) (value[0]);
1:70f7692:             magnitude[4] = (byte) (value[1] >>> 24);
1:70f7692:             magnitude[5] = (byte) (value[1] >>> 16);
1:70f7692:             magnitude[6] = (byte) (value[1] >>> 8);
1:70f7692:             magnitude[7] = (byte) (value[1]);
1:70f7692:             magnitude[8] = (byte) (value[2] >>> 24);
1:70f7692:             magnitude[9] = (byte) (value[2] >>> 16);
1:70f7692:             magnitude[10] = (byte) (value[2] >>> 8);
1:70f7692:             magnitude[11] = (byte) (value[2]);
1:70f7692:             magnitude[12] = (byte) (value[3] >>> 24);
1:70f7692:             magnitude[13] = (byte) (value[3] >>> 16);
1:70f7692:             magnitude[14] = (byte) (value[3] >>> 8);
1:70f7692:             magnitude[15] = (byte) (value[3]);
1:70f7692: 
1:69e3d06:             return new BigDecimal(new BigInteger(signum, magnitude), scale);
1:70f7692:         } else {
1:70f7692:             // throw an exception here if nibbles is greater than 31
1:69e3d06:             throw new IllegalArgumentException(
1:5d2e2bd:                 msgutil.getTextMessage(SQLState.DECIMAL_TOO_MANY_DIGITS));
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     /**
1:70f7692:      * Build a Java <code>double</code> from a fixed point decimal byte representation.
1:70f7692:      *
1:70f7692:      * @throws IllegalArgumentException if the specified representation is not recognized.
1:70f7692:      */
1:0326967:     static double getDouble(
1:69e3d06:             byte[] buffer,
1:69e3d06:             int offset,
1:69e3d06:             int precision,
1:a0b8943:             int scale) {
1:70f7692: 
1:70f7692:         // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
1:70f7692:         int length = precision / 2 + 1;
1:70f7692: 
1:70f7692:         // check for sign.
1:70f7692:         int signum;
1:70f7692:         if ((buffer[offset + length - 1] & 0x0F) == 0x0D) {
1:70f7692:             signum = -1;
1:70f7692:         } else {
1:70f7692:             signum = 1;
1:70f7692:         }
1:33776ff: 
2:70f7692:         if (precision <= 9) {
2:70f7692:             // can be handled by int without overflow.
2:70f7692:             int value = packedNybblesToInt(buffer, offset, 0, length * 2 - 1);
1:70f7692: 
1:70f7692:             return signum * value / Math.pow(10, scale);
2:70f7692:         } else if (precision <= 18) {
1:70f7692:             // can be handled by long without overflow.
1:70f7692:             long value = packedNybblesToLong(buffer, offset, 0, length * 2 - 1);
1:70f7692: 
1:70f7692:             return signum * value / Math.pow(10, scale);
1:70f7692:         } else if (precision <= 27) {
1:70f7692:             // get the value of last 9 digits (5 bytes).
1:70f7692:             int lo = packedNybblesToInt(buffer, offset, (length - 5) * 2, 9);
1:70f7692:             // get the value of another 9 digits (5 bytes).
1:70f7692:             int me = packedNybblesToInt(buffer, offset, (length - 10) * 2 + 1, 9);
1:70f7692:             // get the value of the rest digits.
1:70f7692:             int hi = packedNybblesToInt(buffer, offset, 0, (length - 10) * 2 + 1);
1:70f7692: 
1:70f7692:             return signum * (lo / Math.pow(10, scale) +
1:70f7692:                     me * Math.pow(10, 9 - scale) +
1:70f7692:                     hi * Math.pow(10, 18 - scale));
1:70f7692:         } else if (precision <= 31) {
1:70f7692:             // get the value of last 9 digits (5 bytes).
1:70f7692:             int lo = packedNybblesToInt(buffer, offset, (length - 5) * 2, 9);
1:70f7692:             // get the value of another 9 digits (5 bytes).
1:70f7692:             int meLo = packedNybblesToInt(buffer, offset, (length - 10) * 2 + 1, 9);
1:70f7692:             // get the value of another 9 digits (5 bytes).
1:70f7692:             int meHi = packedNybblesToInt(buffer, offset, (length - 14) * 2, 9);
1:70f7692:             // get the value of the rest digits.
1:70f7692:             int hi = packedNybblesToInt(buffer, offset, 0, (length - 14) * 2);
1:70f7692: 
1:70f7692:             return signum * (lo / Math.pow(10, scale) +
1:70f7692:                     meLo * Math.pow(10, 9 - scale) +
1:70f7692:                     meHi * Math.pow(10, 18 - scale) +
1:70f7692:                     hi * Math.pow(10, 27 - scale));
1:70f7692:         } else {
1:70f7692:             // throw an exception here if nibbles is greater than 31
1:69e3d06:             throw new IllegalArgumentException(
1:5d2e2bd:                 msgutil.getTextMessage(SQLState.DECIMAL_TOO_MANY_DIGITS));
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     /**
1:70f7692:      * Build a Java <code>long</code> from a fixed point decimal byte representation.
1:70f7692:      *
1:70f7692:      * @throws IllegalArgumentException if the specified representation is not recognized.
1:3419748:      * @throws ArithmeticException if value is too large for a long
1:70f7692:      */
1:0326967:     static long getLong(
1:69e3d06:             byte[] buffer,
1:69e3d06:             int offset,
1:69e3d06:             int precision,
1:a0b8943:             int scale) {
1:69e3d06: 
1:70f7692:         if (precision > 31) {
1:70f7692:             // throw an exception here if nibbles is greater than 31
1:69e3d06:             throw new IllegalArgumentException(
1:5d2e2bd:                 msgutil.getTextMessage(SQLState.DECIMAL_TOO_MANY_DIGITS));
1:70f7692:         }
1:70f7692: 
1:70f7692:         // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
1:70f7692:         int length = precision / 2 + 1;
1:70f7692: 
1:70f7692:         // check for sign.
1:70f7692:         int signum;
1:70f7692:         if ((buffer[offset + length - 1] & 0x0F) == 0x0D) {
1:70f7692:             signum = -1;
1:70f7692:         } else {
1:70f7692:             signum = 1;
1:70f7692:         }
1:33776ff: 
1:3419748:         if (precision - scale <= 18) {
1:3419748:             // Can be handled by long without overflow.
1:3419748:             // Compute the integer part only.
1:3419748:             int leftOfDecimalPoint = length * 2 - 1 - scale;
1:3419748:             return signum * packedNybblesToLong(buffer, offset, 0,
1:3419748:                                                 leftOfDecimalPoint);
1:3419748:         } else {
1:3419748:             // Strip off fraction part by converting via BigInteger
1:3419748:             // lest longValueExact will throw ArithmeticException
1:3419748:             BigDecimal tmp = new BigDecimal(
1:3419748:                 getBigDecimal(buffer, offset, precision, scale).toBigInteger());
1:3419748:             // throws ArithmeticException if overflow:
1:3419748:             return tmp.longValueExact();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     //--------------entry points for runtime representation-----------------------
1:33776ff: 
1:70f7692:     /**
1:70f7692:      * Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
1:70f7692:      */
1:70f7692:     public static final int bigDecimalToPackedDecimalBytes(byte[] buffer,
1:70f7692:                                                            int offset,
1:69e3d06:                                                            BigDecimal b,
1:70f7692:                                                            int declaredPrecision,
1:70f7692:                                                            int declaredScale)
1:5d2e2bd:             throws SqlException {
1:70f7692:         // packed decimal may only be up to 31 digits.
1:70f7692:         if (declaredPrecision > 31) {
1:5d2e2bd:             throw new SqlException(null,
1:e65b4db:                 new ClientMessageId(SQLState.DECIMAL_TOO_MANY_DIGITS));
1:70f7692:         }
1:70f7692: 
1:70f7692:         // get absolute unscaled value of the BigDecimal as a String.
1:70f7692:         String unscaledStr = b.unscaledValue().abs().toString();
1:70f7692: 
1:70f7692:         // get precision of the BigDecimal.
1:70f7692:         int bigPrecision = unscaledStr.length();
1:70f7692: 
1:70f7692:         if (bigPrecision > 31) {
1:5d2e2bd:             throw new SqlException(null,
1:e65b4db:                 new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
1:e1a79c3:                 new SqlCode(-405), "packed decimal");
1:70f7692:         }
1:70f7692: 
1:70f7692:         int bigScale = b.scale();
1:70f7692:         int bigWholeIntegerLength = bigPrecision - bigScale;
1:70f7692:         if ((bigWholeIntegerLength > 0) && (!unscaledStr.equals("0"))) {
1:70f7692:             // if whole integer part exists, check if overflow.
1:70f7692:             int declaredWholeIntegerLength = declaredPrecision - declaredScale;
1:70f7692:             if (bigWholeIntegerLength > declaredWholeIntegerLength) {
1:5d2e2bd:                 throw new SqlException(null,
1:e65b4db:                     new ClientMessageId(SQLState.NUMERIC_OVERFLOW),
1:e1a79c3:                     new SqlCode(-413), b.toString(), "packed decimal");
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // convert the unscaled value to a packed decimal bytes.
1:70f7692: 
1:70f7692:         // get unicode '0' value.
1:70f7692:         int zeroBase = '0';
1:70f7692: 
1:70f7692:         // start index in target packed decimal.
1:70f7692:         int packedIndex = declaredPrecision - 1;
1:70f7692: 
1:70f7692:         // start index in source big decimal.
1:70f7692:         int bigIndex;
1:70f7692: 
1:70f7692:         if (bigScale >= declaredScale) {
1:70f7692:             // If target scale is less than source scale,
1:70f7692:             // discard excessive fraction.
1:70f7692: 
1:70f7692:             // set start index in source big decimal to ignore excessive fraction.
1:70f7692:             bigIndex = bigPrecision - 1 - (bigScale - declaredScale);
1:70f7692: 
1:70f7692:             if (bigIndex < 0) {
1:70f7692:                 // all digits are discarded, so only process the sign nybble.
1:70f7692:                 buffer[offset + (packedIndex + 1) / 2] =
1:70f7692:                         (byte) ((b.signum() >= 0) ? 12 : 13); // sign nybble
1:70f7692:             } else {
1:70f7692:                 // process the last nybble together with the sign nybble.
1:70f7692:                 buffer[offset + (packedIndex + 1) / 2] =
1:70f7692:                         (byte) (((unscaledStr.charAt(bigIndex) - zeroBase) << 4) + // last nybble
1:70f7692:                         ((b.signum() >= 0) ? 12 : 13)); // sign nybble
1:70f7692:             }
1:70f7692:             packedIndex -= 2;
1:70f7692:             bigIndex -= 2;
1:70f7692:         } else {
1:70f7692:             // If target scale is greater than source scale,
1:70f7692:             // pad the fraction with zero.
1:70f7692: 
1:70f7692:             // set start index in source big decimal to pad fraction with zero.
1:70f7692:             bigIndex = declaredScale - bigScale - 1;
1:70f7692: 
1:70f7692:             // process the sign nybble.
1:70f7692:             buffer[offset + (packedIndex + 1) / 2] =
1:70f7692:                     (byte) ((b.signum() >= 0) ? 12 : 13); // sign nybble
1:70f7692: 
1:70f7692:             for (packedIndex -= 2, bigIndex -= 2; bigIndex >= 0; packedIndex -= 2, bigIndex -= 2) {
1:70f7692:                 buffer[offset + (packedIndex + 1) / 2] = (byte) 0;
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (bigIndex == -1) {
1:70f7692:                 buffer[offset + (packedIndex + 1) / 2] =
1:70f7692:                         (byte) ((unscaledStr.charAt(bigPrecision - 1) - zeroBase) << 4); // high nybble
1:70f7692: 
1:70f7692:                 packedIndex -= 2;
1:70f7692:                 bigIndex = bigPrecision - 3;
1:70f7692:             } else {
1:70f7692:                 bigIndex = bigPrecision - 2;
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // process the rest.
1:70f7692:         for (; bigIndex >= 0; packedIndex -= 2, bigIndex -= 2) {
1:70f7692:             buffer[offset + (packedIndex + 1) / 2] =
1:70f7692:                     (byte) (((unscaledStr.charAt(bigIndex) - zeroBase) << 4) + // high nybble
1:70f7692:                     (unscaledStr.charAt(bigIndex + 1) - zeroBase)); // low nybble
1:70f7692:         }
1:70f7692: 
1:70f7692:         // process the first nybble when there is one left.
1:70f7692:         if (bigIndex == -1) {
1:70f7692:             buffer[offset + (packedIndex + 1) / 2] =
1:70f7692:                     (byte) (unscaledStr.charAt(0) - zeroBase);
1:70f7692: 
1:70f7692:             packedIndex -= 2;
1:70f7692:         }
1:70f7692: 
1:70f7692:         // pad zero in front of the big decimal if necessary.
1:70f7692:         for (; packedIndex >= -1; packedIndex -= 2) {
1:70f7692:             buffer[offset + (packedIndex + 1) / 2] = (byte) 0;
1:70f7692:         }
1:70f7692: 
1:70f7692:         return declaredPrecision / 2 + 1;
1:70f7692:     }
1:33776ff: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e1a79c3
/////////////////////////////////////////////////////////////////////////
1:                 new SqlCode(-405), "packed decimal");
/////////////////////////////////////////////////////////////////////////
1:                     new SqlCode(-413), b.toString(), "packed decimal");
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             int scale) {
/////////////////////////////////////////////////////////////////////////
1:             int scale) {
/////////////////////////////////////////////////////////////////////////
1:             int scale) {
commit:4020781
/////////////////////////////////////////////////////////////////////////
1:         if (precision <= 18) {
1:             if (signum < 0) {
1:                 value = -value;
1:             }
1:             return BigDecimal.valueOf(value, scale);
commit:23ecfcf
/////////////////////////////////////////////////////////////////////////
1:     private static final MessageUtil msgutil = SqlException.getMessageUtil();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     static BigDecimal getBigDecimal(
/////////////////////////////////////////////////////////////////////////
1:     static double getDouble(
/////////////////////////////////////////////////////////////////////////
1:     static long getLong(
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
0: import java.io.UnsupportedEncodingException;
1: import java.math.BigInteger;
/////////////////////////////////////////////////////////////////////////
0:     public static final BigDecimal getBigDecimal(
1:             byte[] buffer,
1:             int offset,
1:             int precision,
0:             int scale) throws UnsupportedEncodingException {
1: 
/////////////////////////////////////////////////////////////////////////
1:             return new BigDecimal(new BigInteger(signum, magnitude), scale);
/////////////////////////////////////////////////////////////////////////
1:             return new BigDecimal(new BigInteger(signum, magnitude), scale);
1:             throw new IllegalArgumentException(
/////////////////////////////////////////////////////////////////////////
0:     public static final double getDouble(
1:             byte[] buffer,
1:             int offset,
1:             int precision,
0:             int scale) throws UnsupportedEncodingException {
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalArgumentException(
/////////////////////////////////////////////////////////////////////////
0:     public static final long getLong(
1:             byte[] buffer,
1:             int offset,
1:             int precision,
0:             int scale) throws UnsupportedEncodingException {
1: 
1:             throw new IllegalArgumentException(
/////////////////////////////////////////////////////////////////////////
1:                                                            BigDecimal b,
commit:3419748
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1:      * @throws ArithmeticException if value is too large for a long
/////////////////////////////////////////////////////////////////////////
1:         if (precision - scale <= 18) {
1:             // Can be handled by long without overflow.
1:             // Compute the integer part only.
1:             int leftOfDecimalPoint = length * 2 - 1 - scale;
1:             return signum * packedNybblesToLong(buffer, offset, 0,
1:                                                 leftOfDecimalPoint);
1:         } else {
1:             // Strip off fraction part by converting via BigInteger
1:             // lest longValueExact will throw ArithmeticException
1:             BigDecimal tmp = new BigDecimal(
1:                 getBigDecimal(buffer, offset, precision, scale).toBigInteger());
1:             // throws ArithmeticException if overflow:
1:             return tmp.longValueExact();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f271471
/////////////////////////////////////////////////////////////////////////
0:     private static MessageUtil msgutil = SqlException.getMessageUtil();
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.DECIMAL_TOO_MANY_DIGITS));
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.NUMERIC_OVERFLOW),
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
1: import org.apache.derby.shared.common.i18n.MessageUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1:     
0:     private static MessageUtil msgutil = new MessageUtil(
0:         SqlException.CLIENT_MESSAGE_RESOURCE_NAME);
/////////////////////////////////////////////////////////////////////////
0:             throw new java.lang.IllegalArgumentException(
1:                 msgutil.getTextMessage(SQLState.DECIMAL_TOO_MANY_DIGITS));
/////////////////////////////////////////////////////////////////////////
0:             throw new java.lang.IllegalArgumentException(
1:                 msgutil.getTextMessage(SQLState.DECIMAL_TOO_MANY_DIGITS));
/////////////////////////////////////////////////////////////////////////
0:             throw new java.lang.IllegalArgumentException(
1:                 msgutil.getTextMessage(SQLState.DECIMAL_TOO_MANY_DIGITS));
/////////////////////////////////////////////////////////////////////////
1:             throws SqlException {
1:             throw new SqlException(null,
0:                 new MessageId(SQLState.DECIMAL_TOO_MANY_DIGITS));
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(null,
0:                 new MessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
0:                 "packed decimal", new SqlCode(-405));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(null,
0:                     new MessageId(SQLState.NUMERIC_OVERFLOW),
0:                     b.toString(), "packed decimal", new SqlCode(-413));
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1:  * Converters from fixed point decimal bytes to <code>java.math.BigDecimal</code>, <code>double</code>, or
1:  * <code>long</code>.
1: public class Decimal {
1:     /**
1:      * Packed Decimal representation
1:      */
1:     public final static int PACKED_DECIMAL = 0x30;
1:     //--------------------------private constants---------------------------------
1:     private static final int[][] tenRadixMagnitude = {
1:         {0x3b9aca00}, // 10^9
1:         {0x0de0b6b3, 0xa7640000}, // 10^18
1:         {0x033b2e3c, 0x9fd0803c, 0xe8000000}, // 10^27
1:     };
1:     //--------------------------constructors--------------------------------------
1:     // Hide the default constructor, this is a static class.
1:     private Decimal() {
1:     //--------------------------private helper methods----------------------------
1:     /**
1:      * Convert a range of packed nybbles (up to 9 digits without overflow) to an int. Note that for performance purpose,
1:      * it does not do array-out-of-bound checking.
1:      */
1:     private static final int packedNybblesToInt(byte[] buffer,
1:                                                 int offset,
1:                                                 int startNybble,
1:                                                 int numberOfNybbles) {
1:         int value = 0;
1:         int i = startNybble / 2;
1:         if ((startNybble % 2) != 0) {
1:             // process low nybble of the first byte if necessary.
1:             value += buffer[offset + i] & 0x0F;
1:             i++;
1:         int endNybble = startNybble + numberOfNybbles - 1;
1:         for (; i < (endNybble + 1) / 2; i++) {
1:             value = value * 10 + ((buffer[offset + i] & 0xF0) >>> 4); // high nybble.
1:             value = value * 10 + (buffer[offset + i] & 0x0F);        // low nybble.
1:         }
1:         if ((endNybble % 2) == 0) {
1:             // process high nybble of the last byte if necessary.
1:             value = value * 10 + ((buffer[offset + i] & 0xF0) >>> 4);
1:         }
1:         return value;
1:     /**
1:      * Convert a range of packed nybbles (up to 18 digits without overflow) to a long. Note that for performance
1:      * purpose, it does not do array-out-of-bound checking.
1:      */
1:     private static final long packedNybblesToLong(byte[] buffer,
1:                                                   int offset,
1:                                                   int startNybble,
1:                                                   int numberOfNybbles) {
1:         long value = 0;
1:         int i = startNybble / 2;
1:         if ((startNybble % 2) != 0) {
1:             // process low nybble of the first byte if necessary.
1:             value += buffer[offset + i] & 0x0F;
1:             i++;
1:         }
1:         int endNybble = startNybble + numberOfNybbles - 1;
1:         for (; i < (endNybble + 1) / 2; i++) {
1:             value = value * 10 + ((buffer[offset + i] & 0xF0) >>> 4); // high nybble.
1:             value = value * 10 + (buffer[offset + i] & 0x0F);        // low nybble.
1:         }
1: 
1:         if ((endNybble % 2) == 0) {
1:             // process high nybble of the last byte if necessary.
1:             value = value * 10 + ((buffer[offset + i] & 0xF0) >>> 4);
1:         }
1: 
1:         return value;
1:     /**
1:      * Compute the int array of magnitude from input value segments.
1:      */
1:     private static final int[] computeMagnitude(int[] input) {
1:         int length = input.length;
1:         int[] mag = new int[length];
1:         mag[length - 1] = input[length - 1];
1:         for (int i = 0; i < length - 1; i++) {
1:             int carry = 0;
1:             int j = tenRadixMagnitude[i].length - 1;
1:             int k = length - 1;
1:             for (; j >= 0; j--, k--) {
1:                 long product = (input[length - 2 - i] & 0xFFFFFFFFL) * (tenRadixMagnitude[i][j] & 0xFFFFFFFFL)
1:                         + (mag[k] & 0xFFFFFFFFL) // add previous value
1:                         + (carry & 0xFFFFFFFFL); // add carry
1:                 carry = (int) (product >>> 32);
1:                 mag[k] = (int) (product & 0xFFFFFFFFL);
1:             }
1:             mag[k] = (int) carry;
1:         }
1:         return mag;
1:     //--------------entry points for runtime representation-----------------------
1:     /**
1:      * Build a <code>java.math.BigDecimal</code> from a fixed point decimal byte representation.
1:      *
1:      * @throws IllegalArgumentException if the specified representation is not recognized.
1:      */
0:     public static final java.math.BigDecimal getBigDecimal(byte[] buffer,
1:                                                            int offset,
0:                                                            int precision,
0:                                                            int scale) throws java.io.UnsupportedEncodingException {
1:         // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
1:         int length = precision / 2 + 1;
1:         // check for sign.
1:         int signum;
1:         if ((buffer[offset + length - 1] & 0x0F) == 0x0D) {
1:             signum = -1;
1:         } else {
1:             signum = 1;
1:         }
1:         if (precision <= 9) {
1:             // can be handled by int without overflow.
1:             int value = packedNybblesToInt(buffer, offset, 0, length * 2 - 1);
1:             // convert value to a byte array of magnitude.
0:             byte[] magnitude = new byte[4];
0:             magnitude[0] = (byte) (value >>> 24);
0:             magnitude[1] = (byte) (value >>> 16);
0:             magnitude[2] = (byte) (value >>> 8);
0:             magnitude[3] = (byte) (value);
0:             return new java.math.BigDecimal(new java.math.BigInteger(signum, magnitude), scale);
1:         } else if (precision <= 18) {
1:             // can be handled by long without overflow.
1:             long value = packedNybblesToLong(buffer, offset, 0, length * 2 - 1);
1:             // convert value to a byte array of magnitude.
0:             byte[] magnitude = new byte[8];
0:             magnitude[0] = (byte) (value >>> 56);
0:             magnitude[1] = (byte) (value >>> 48);
0:             magnitude[2] = (byte) (value >>> 40);
0:             magnitude[3] = (byte) (value >>> 32);
0:             magnitude[4] = (byte) (value >>> 24);
0:             magnitude[5] = (byte) (value >>> 16);
0:             magnitude[6] = (byte) (value >>> 8);
0:             magnitude[7] = (byte) (value);
0:             return new java.math.BigDecimal(new java.math.BigInteger(signum, magnitude), scale);
1:         } else if (precision <= 27) {
1:             // get the value of last 9 digits (5 bytes).
1:             int lo = packedNybblesToInt(buffer, offset, (length - 5) * 2, 9);
1:             // get the value of another 9 digits (5 bytes).
1:             int me = packedNybblesToInt(buffer, offset, (length - 10) * 2 + 1, 9);
1:             // get the value of the rest digits.
1:             int hi = packedNybblesToInt(buffer, offset, 0, (length - 10) * 2 + 1);
1:             // compute the int array of magnitude.
1:             int[] value = computeMagnitude(new int[]{hi, me, lo});
1:             // convert value to a byte array of magnitude.
1:             byte[] magnitude = new byte[12];
1:             magnitude[0] = (byte) (value[0] >>> 24);
1:             magnitude[1] = (byte) (value[0] >>> 16);
1:             magnitude[2] = (byte) (value[0] >>> 8);
1:             magnitude[3] = (byte) (value[0]);
1:             magnitude[4] = (byte) (value[1] >>> 24);
1:             magnitude[5] = (byte) (value[1] >>> 16);
1:             magnitude[6] = (byte) (value[1] >>> 8);
1:             magnitude[7] = (byte) (value[1]);
1:             magnitude[8] = (byte) (value[2] >>> 24);
1:             magnitude[9] = (byte) (value[2] >>> 16);
1:             magnitude[10] = (byte) (value[2] >>> 8);
1:             magnitude[11] = (byte) (value[2]);
0:             return new java.math.BigDecimal(new java.math.BigInteger(signum, magnitude), scale);
1:         } else if (precision <= 31) {
1:             // get the value of last 9 digits (5 bytes).
1:             int lo = packedNybblesToInt(buffer, offset, (length - 5) * 2, 9);
1:             // get the value of another 9 digits (5 bytes).
1:             int meLo = packedNybblesToInt(buffer, offset, (length - 10) * 2 + 1, 9);
1:             // get the value of another 9 digits (5 bytes).
1:             int meHi = packedNybblesToInt(buffer, offset, (length - 14) * 2, 9);
1:             // get the value of the rest digits.
1:             int hi = packedNybblesToInt(buffer, offset, 0, (length - 14) * 2);
1:             // compute the int array of magnitude.
1:             int[] value = computeMagnitude(new int[]{hi, meHi, meLo, lo});
1: 
1:             // convert value to a byte array of magnitude.
1:             byte[] magnitude = new byte[16];
1:             magnitude[0] = (byte) (value[0] >>> 24);
1:             magnitude[1] = (byte) (value[0] >>> 16);
1:             magnitude[2] = (byte) (value[0] >>> 8);
1:             magnitude[3] = (byte) (value[0]);
1:             magnitude[4] = (byte) (value[1] >>> 24);
1:             magnitude[5] = (byte) (value[1] >>> 16);
1:             magnitude[6] = (byte) (value[1] >>> 8);
1:             magnitude[7] = (byte) (value[1]);
1:             magnitude[8] = (byte) (value[2] >>> 24);
1:             magnitude[9] = (byte) (value[2] >>> 16);
1:             magnitude[10] = (byte) (value[2] >>> 8);
1:             magnitude[11] = (byte) (value[2]);
1:             magnitude[12] = (byte) (value[3] >>> 24);
1:             magnitude[13] = (byte) (value[3] >>> 16);
1:             magnitude[14] = (byte) (value[3] >>> 8);
1:             magnitude[15] = (byte) (value[3]);
1: 
0:             return new java.math.BigDecimal(new java.math.BigInteger(signum, magnitude), scale);
1:         } else {
1:             // throw an exception here if nibbles is greater than 31
0:             throw new java.lang.IllegalArgumentException("Decimal may only be up to 31 digits!");
1:         }
1:     /**
1:      * Build a Java <code>double</code> from a fixed point decimal byte representation.
1:      *
1:      * @throws IllegalArgumentException if the specified representation is not recognized.
1:      */
0:     public static final double getDouble(byte[] buffer,
1:                                          int offset,
0:                                          int precision,
0:                                          int scale) throws java.io.UnsupportedEncodingException {
1:         // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
1:         int length = precision / 2 + 1;
1: 
1:         // check for sign.
1:         int signum;
1:         if ((buffer[offset + length - 1] & 0x0F) == 0x0D) {
1:             signum = -1;
1:         } else {
1:             signum = 1;
1:         }
1: 
1:         if (precision <= 9) {
1:             // can be handled by int without overflow.
1:             int value = packedNybblesToInt(buffer, offset, 0, length * 2 - 1);
1: 
1:             return signum * value / Math.pow(10, scale);
1:         } else if (precision <= 18) {
1:             // can be handled by long without overflow.
1:             long value = packedNybblesToLong(buffer, offset, 0, length * 2 - 1);
1: 
1:             return signum * value / Math.pow(10, scale);
1:         } else if (precision <= 27) {
1:             // get the value of last 9 digits (5 bytes).
1:             int lo = packedNybblesToInt(buffer, offset, (length - 5) * 2, 9);
1:             // get the value of another 9 digits (5 bytes).
1:             int me = packedNybblesToInt(buffer, offset, (length - 10) * 2 + 1, 9);
1:             // get the value of the rest digits.
1:             int hi = packedNybblesToInt(buffer, offset, 0, (length - 10) * 2 + 1);
1: 
1:             return signum * (lo / Math.pow(10, scale) +
1:                     me * Math.pow(10, 9 - scale) +
1:                     hi * Math.pow(10, 18 - scale));
1:         } else if (precision <= 31) {
1:             // get the value of last 9 digits (5 bytes).
1:             int lo = packedNybblesToInt(buffer, offset, (length - 5) * 2, 9);
1:             // get the value of another 9 digits (5 bytes).
1:             int meLo = packedNybblesToInt(buffer, offset, (length - 10) * 2 + 1, 9);
1:             // get the value of another 9 digits (5 bytes).
1:             int meHi = packedNybblesToInt(buffer, offset, (length - 14) * 2, 9);
1:             // get the value of the rest digits.
1:             int hi = packedNybblesToInt(buffer, offset, 0, (length - 14) * 2);
1: 
1:             return signum * (lo / Math.pow(10, scale) +
1:                     meLo * Math.pow(10, 9 - scale) +
1:                     meHi * Math.pow(10, 18 - scale) +
1:                     hi * Math.pow(10, 27 - scale));
1:         } else {
1:             // throw an exception here if nibbles is greater than 31
0:             throw new java.lang.IllegalArgumentException("Decimal may only be up to 31 digits!");
1:         }
1:     /**
1:      * Build a Java <code>long</code> from a fixed point decimal byte representation.
1:      *
1:      * @throws IllegalArgumentException if the specified representation is not recognized.
1:      */
0:     public static final long getLong(byte[] buffer,
1:                                      int offset,
0:                                      int precision,
0:                                      int scale) throws java.io.UnsupportedEncodingException {
1:         if (precision > 31) {
1:             // throw an exception here if nibbles is greater than 31
0:             throw new java.lang.IllegalArgumentException("Decimal may only be up to 31 digits!");
1:         }
1:         // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
1:         int length = precision / 2 + 1;
1: 
1:         // check for sign.
1:         int signum;
1:         if ((buffer[offset + length - 1] & 0x0F) == 0x0D) {
1:             signum = -1;
1:         } else {
1:             signum = 1;
1:         }
1: 
0:         // compute the integer part only.
0:         int leftOfDecimalPoint = length * 2 - 1 - scale;
0:         long integer = 0;
0:         if (leftOfDecimalPoint > 0) {
0:             int i = 0;
0:             for (; i < leftOfDecimalPoint / 2; i++) {
0:                 integer = integer * 10 + signum * ((buffer[offset + i] & 0xF0) >>> 4); // high nybble.
0:                 integer = integer * 10 + signum * (buffer[offset + i] & 0x0F);        // low nybble.
1:             }
0:             if ((leftOfDecimalPoint % 2) == 1) {
1:                 // process high nybble of the last byte if necessary.
0:                 integer = integer * 10 + signum * ((buffer[offset + i] & 0xF0) >>> 4);
1:             }
1:         }
1: 
0:         return integer;
1:     //--------------entry points for runtime representation-----------------------
1:     /**
1:      * Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
1:      */
1:     public static final int bigDecimalToPackedDecimalBytes(byte[] buffer,
1:                                                            int offset,
0:                                                            java.math.BigDecimal b,
1:                                                            int declaredPrecision,
1:                                                            int declaredScale)
0:             throws ConversionException {
1:         // packed decimal may only be up to 31 digits.
1:         if (declaredPrecision > 31) {
0:             throw new ConversionException("Packed decimal may only be up to 31 digits!");
1:         }
1: 
1:         // get absolute unscaled value of the BigDecimal as a String.
1:         String unscaledStr = b.unscaledValue().abs().toString();
1: 
1:         // get precision of the BigDecimal.
1:         int bigPrecision = unscaledStr.length();
1: 
1:         if (bigPrecision > 31) {
0:             throw new ConversionException("The numeric literal \"" +
0:                     b.toString() +
0:                     "\" is not valid because its value is out of range.",
0:                     "42820",
0:                     -405);
1:         }
1: 
1:         int bigScale = b.scale();
1:         int bigWholeIntegerLength = bigPrecision - bigScale;
1:         if ((bigWholeIntegerLength > 0) && (!unscaledStr.equals("0"))) {
1:             // if whole integer part exists, check if overflow.
1:             int declaredWholeIntegerLength = declaredPrecision - declaredScale;
1:             if (bigWholeIntegerLength > declaredWholeIntegerLength) {
0:                 throw new ConversionException("Overflow occurred during numeric data type conversion of \"" +
0:                         b.toString() +
0:                         "\".",
0:                         "22003",
0:                         -413);
1:             }
1:         }
1: 
1:         // convert the unscaled value to a packed decimal bytes.
1: 
1:         // get unicode '0' value.
1:         int zeroBase = '0';
1: 
1:         // start index in target packed decimal.
1:         int packedIndex = declaredPrecision - 1;
1: 
1:         // start index in source big decimal.
1:         int bigIndex;
1: 
1:         if (bigScale >= declaredScale) {
1:             // If target scale is less than source scale,
1:             // discard excessive fraction.
1: 
1:             // set start index in source big decimal to ignore excessive fraction.
1:             bigIndex = bigPrecision - 1 - (bigScale - declaredScale);
1: 
1:             if (bigIndex < 0) {
1:                 // all digits are discarded, so only process the sign nybble.
1:                 buffer[offset + (packedIndex + 1) / 2] =
1:                         (byte) ((b.signum() >= 0) ? 12 : 13); // sign nybble
1:             } else {
1:                 // process the last nybble together with the sign nybble.
1:                 buffer[offset + (packedIndex + 1) / 2] =
1:                         (byte) (((unscaledStr.charAt(bigIndex) - zeroBase) << 4) + // last nybble
1:                         ((b.signum() >= 0) ? 12 : 13)); // sign nybble
1:             }
1:             packedIndex -= 2;
1:             bigIndex -= 2;
1:         } else {
1:             // If target scale is greater than source scale,
1:             // pad the fraction with zero.
1: 
1:             // set start index in source big decimal to pad fraction with zero.
1:             bigIndex = declaredScale - bigScale - 1;
1: 
1:             // process the sign nybble.
1:             buffer[offset + (packedIndex + 1) / 2] =
1:                     (byte) ((b.signum() >= 0) ? 12 : 13); // sign nybble
1: 
1:             for (packedIndex -= 2, bigIndex -= 2; bigIndex >= 0; packedIndex -= 2, bigIndex -= 2) {
1:                 buffer[offset + (packedIndex + 1) / 2] = (byte) 0;
1:             }
1: 
1:             if (bigIndex == -1) {
1:                 buffer[offset + (packedIndex + 1) / 2] =
1:                         (byte) ((unscaledStr.charAt(bigPrecision - 1) - zeroBase) << 4); // high nybble
1: 
1:                 packedIndex -= 2;
1:                 bigIndex = bigPrecision - 3;
1:             } else {
1:                 bigIndex = bigPrecision - 2;
1:             }
1:         }
1: 
1:         // process the rest.
1:         for (; bigIndex >= 0; packedIndex -= 2, bigIndex -= 2) {
1:             buffer[offset + (packedIndex + 1) / 2] =
1:                     (byte) (((unscaledStr.charAt(bigIndex) - zeroBase) << 4) + // high nybble
1:                     (unscaledStr.charAt(bigIndex + 1) - zeroBase)); // low nybble
1:         }
1: 
1:         // process the first nybble when there is one left.
1:         if (bigIndex == -1) {
1:             buffer[offset + (packedIndex + 1) / 2] =
1:                     (byte) (unscaledStr.charAt(0) - zeroBase);
1: 
1:             packedIndex -= 2;
1:         }
1: 
1:         // pad zero in front of the big decimal if necessary.
1:         for (; packedIndex >= -1; packedIndex -= 2) {
1:             buffer[offset + (packedIndex + 1) / 2] = (byte) 0;
1:         }
1: 
1:         return declaredPrecision / 2 + 1;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.Decimal
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: package org.apache.derby.client.am;
1: 
1: /**
0:  * Converters from fixed point decimal bytes to <code>java.math.BigDecimal</code>,
0:  * <code>double</code>, or <code>long</code>.
1:  */
0: public class Decimal
0: {
1:   /**
0:    * Packed Decimal representation
1:    */
0:   public final static int PACKED_DECIMAL = 0x30;
1: 
0:   //--------------------------private constants---------------------------------
1: 
0:   private static final int[][] tenRadixMagnitude = {
0:     { 0x3b9aca00 }, // 10^9
0:     { 0x0de0b6b3, 0xa7640000 }, // 10^18
0:     { 0x033b2e3c, 0x9fd0803c, 0xe8000000 }, // 10^27
0:   };
1: 
0:   //--------------------------constructors--------------------------------------
1: 
0:   // Hide the default constructor, this is a static class.
0:   private Decimal() {}
1: 
0:   //--------------------------private helper methods----------------------------
1: 
1:   /**
0:    * Convert a range of packed nybbles (up to 9 digits without overflow) to an int.
0:    * Note that for performance purpose, it does not do array-out-of-bound checking.
1:   */
0:   private static final int packedNybblesToInt (byte[] buffer,
0:                                          int offset,
0:                                          int startNybble,
0:                                          int numberOfNybbles)
0:   {
0:     int value = 0;
1: 
0:     int i = startNybble / 2;
0:     if ((startNybble % 2) != 0) {
0:       // process low nybble of the first byte if necessary.
0:       value += buffer[offset+i] & 0x0F;
0:       i++;
1:     }
1: 
0:     int endNybble = startNybble + numberOfNybbles -1;
0:     for (; i<(endNybble+1)/2; i++) {
0:       value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
0:       value = value*10 +  (buffer[offset+i] & 0x0F);        // low nybble.
1:     }
1: 
0:     if ((endNybble % 2) == 0) {
0:       // process high nybble of the last byte if necessary.
0:       value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4);
1:     }
1: 
0:     return value;
1:   }
1: 
1:   /**
0:    * Convert a range of packed nybbles (up to 18 digits without overflow) to a long.
0:    * Note that for performance purpose, it does not do array-out-of-bound checking.
1:   */
0:   private static final long packedNybblesToLong (byte[] buffer,
0:                                            int offset,
0:                                            int startNybble,
0:                                            int numberOfNybbles)
0:   {
0:     long value = 0;
1: 
0:     int i = startNybble / 2;
0:     if ((startNybble % 2) != 0) {
0:       // process low nybble of the first byte if necessary.
0:       value += buffer[offset+i] & 0x0F;
0:       i++;
1:     }
1: 
0:     int endNybble = startNybble + numberOfNybbles -1;
0:     for (; i<(endNybble+1)/2; i++) {
0:       value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
0:       value = value*10 +  (buffer[offset+i] & 0x0F);        // low nybble.
1:     }
1: 
0:     if ((endNybble % 2) == 0) {
0:       // process high nybble of the last byte if necessary.
0:       value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4);
1:     }
1: 
0:     return value;
1:   }
1: 
1:   /**
0:    * Compute the int array of magnitude from input value segments.
1:    */
0:   private static final int[] computeMagnitude(int[] input)
0:   {
0:       int length = input.length;
0:       int[] mag = new int[length];
1: 
0:       mag[length-1] = input[length-1];
0:       for (int i=0; i<length-1; i++) {
0:         int carry = 0;
0:         int j = tenRadixMagnitude[i].length-1;
0:         int k = length-1;
0:         for (; j>=0; j--, k--) {
0:           long product = (input[length-2-i] & 0xFFFFFFFFL) * (tenRadixMagnitude[i][j] & 0xFFFFFFFFL)
0:                        + (mag[k] & 0xFFFFFFFFL) // add previous value
0:                        + (carry & 0xFFFFFFFFL); // add carry
0:           carry  = (int) (product >>> 32);
0:           mag[k] = (int) (product & 0xFFFFFFFFL);
1:         }
0:         mag[k] = (int) carry;
1:       }
0:       return mag;
1:   }
1: 
0:   //--------------entry points for runtime representation-----------------------
1: 
1:   /**
0:    * Build a <code>java.math.BigDecimal</code> from a fixed point decimal byte representation.
0:    *
0:    * @exception IllegalArgumentException if the specified representation is not recognized.
1:    */
0:   public static final java.math.BigDecimal getBigDecimal (byte[] buffer,
0:                                                     int offset,
0:                                                     int precision,
0:                                                     int scale
0:                                                     ) throws java.io.UnsupportedEncodingException
0:   {
0:     // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
0:     int length = precision / 2 + 1;
1: 
0:     // check for sign.
0:     int signum;
0:     if ((buffer[offset+length-1] & 0x0F) == 0x0D)
0:       signum = -1;
0:     else
0:       signum =  1;
1: 
0:     if (precision <= 9) {
0:       // can be handled by int without overflow.
0:       int value = packedNybblesToInt(buffer, offset, 0, length*2-1);
1: 
0:       // convert value to a byte array of magnitude.
0:       byte[] magnitude = new byte[4];
0:       magnitude[0] = (byte)(value >>> 24);
0:       magnitude[1] = (byte)(value >>> 16);
0:       magnitude[2] = (byte)(value >>> 8);
0:       magnitude[3] = (byte)(value);
1: 
0:       return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
1:     }
0:     else if (precision <= 18) {
0:       // can be handled by long without overflow.
0:       long value = packedNybblesToLong(buffer, offset, 0, length*2-1);
1: 
0:       // convert value to a byte array of magnitude.
0:       byte[] magnitude = new byte[8];
0:       magnitude[0] = (byte)(value >>> 56);
0:       magnitude[1] = (byte)(value >>> 48);
0:       magnitude[2] = (byte)(value >>> 40);
0:       magnitude[3] = (byte)(value >>> 32);
0:       magnitude[4] = (byte)(value >>> 24);
0:       magnitude[5] = (byte)(value >>> 16);
0:       magnitude[6] = (byte)(value >>>  8);
0:       magnitude[7] = (byte)(value);
1: 
0:       return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
1:     }
0:     else if (precision <= 27) {
0:       // get the value of last 9 digits (5 bytes).
0:       int lo = packedNybblesToInt(buffer, offset, (length-5)*2, 9);
0:       // get the value of another 9 digits (5 bytes).
0:       int me = packedNybblesToInt(buffer, offset, (length-10)*2+1, 9);
0:       // get the value of the rest digits.
0:       int hi = packedNybblesToInt(buffer, offset, 0, (length-10)*2+1);
1: 
0:       // compute the int array of magnitude.
0:       int[] value = computeMagnitude(new int[] {hi, me, lo});
1: 
0:       // convert value to a byte array of magnitude.
0:       byte[] magnitude = new byte[12];
0:       magnitude[0]  = (byte)(value[0] >>> 24);
0:       magnitude[1]  = (byte)(value[0] >>> 16);
0:       magnitude[2]  = (byte)(value[0] >>> 8);
0:       magnitude[3]  = (byte)(value[0]);
0:       magnitude[4]  = (byte)(value[1] >>> 24);
0:       magnitude[5]  = (byte)(value[1] >>> 16);
0:       magnitude[6]  = (byte)(value[1] >>> 8);
0:       magnitude[7]  = (byte)(value[1]);
0:       magnitude[8]  = (byte)(value[2] >>> 24);
0:       magnitude[9]  = (byte)(value[2] >>> 16);
0:       magnitude[10] = (byte)(value[2] >>> 8);
0:       magnitude[11] = (byte)(value[2]);
1: 
0:       return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
1:     }
0:     else if (precision <= 31) {
0:       // get the value of last 9 digits (5 bytes).
0:       int lo   = packedNybblesToInt(buffer, offset, (length-5)*2, 9);
0:       // get the value of another 9 digits (5 bytes).
0:       int meLo = packedNybblesToInt(buffer, offset, (length-10)*2+1, 9);
0:       // get the value of another 9 digits (5 bytes).
0:       int meHi = packedNybblesToInt(buffer, offset, (length-14)*2, 9);
0:       // get the value of the rest digits.
0:       int hi   = packedNybblesToInt(buffer, offset, 0, (length-14)*2);
1: 
0:       // compute the int array of magnitude.
0:       int[] value = computeMagnitude(new int[] {hi, meHi, meLo, lo});
1: 
0:       // convert value to a byte array of magnitude.
0:       byte[] magnitude = new byte[16];
0:       magnitude[0]  = (byte)(value[0] >>> 24);
0:       magnitude[1]  = (byte)(value[0] >>> 16);
0:       magnitude[2]  = (byte)(value[0] >>> 8);
0:       magnitude[3]  = (byte)(value[0]);
0:       magnitude[4]  = (byte)(value[1] >>> 24);
0:       magnitude[5]  = (byte)(value[1] >>> 16);
0:       magnitude[6]  = (byte)(value[1] >>> 8);
0:       magnitude[7]  = (byte)(value[1]);
0:       magnitude[8]  = (byte)(value[2] >>> 24);
0:       magnitude[9]  = (byte)(value[2] >>> 16);
0:       magnitude[10] = (byte)(value[2] >>> 8);
0:       magnitude[11] = (byte)(value[2]);
0:       magnitude[12] = (byte)(value[3] >>> 24);
0:       magnitude[13] = (byte)(value[3] >>> 16);
0:       magnitude[14] = (byte)(value[3] >>> 8);
0:       magnitude[15] = (byte)(value[3]);
1: 
0:       return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
1:     }
0:     else {
0:       // throw an exception here if nibbles is greater than 31
0:       throw new java.lang.IllegalArgumentException("Decimal may only be up to 31 digits!");
1:     }
1:   }
1: 
1:   /**
0:    * Build a Java <code>double</code> from a fixed point decimal byte representation.
0:    *
0:    * @exception IllegalArgumentException if the specified representation is not recognized.
1:    */
0:   public static final double getDouble (byte[] buffer,
0:                                   int offset,
0:                                   int precision,
0:                                   int scale
0:                                   ) throws java.io.UnsupportedEncodingException
0:   {
0:     // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
0:     int length = precision / 2 + 1;
1: 
0:     // check for sign.
0:     int signum;
0:     if ((buffer[offset+length-1] & 0x0F) == 0x0D)
0:       signum = -1;
0:     else
0:       signum =  1;
1: 
0:     if (precision <= 9) {
0:       // can be handled by int without overflow.
0:       int value = packedNybblesToInt(buffer, offset, 0, length*2-1);
1: 
0:       return signum * value / Math.pow(10, scale);
1:     }
0:     else if (precision <= 18) {
0:       // can be handled by long without overflow.
0:       long value = packedNybblesToLong(buffer, offset, 0, length*2-1);
1: 
0:       return signum * value / Math.pow(10, scale);
1:     }
0:     else if (precision <= 27) {
0:       // get the value of last 9 digits (5 bytes).
0:       int lo = packedNybblesToInt(buffer, offset, (length-5)*2, 9);
0:       // get the value of another 9 digits (5 bytes).
0:       int me = packedNybblesToInt(buffer, offset, (length-10)*2+1, 9);
0:       // get the value of the rest digits.
0:       int hi = packedNybblesToInt(buffer, offset, 0, (length-10)*2+1);
1: 
0:       return signum * (lo / Math.pow(10, scale) +
0:                        me * Math.pow(10, 9-scale) +
0:                        hi * Math.pow(10, 18-scale));
1:     }
0:     else if (precision <= 31) {
0:       // get the value of last 9 digits (5 bytes).
0:       int lo   = packedNybblesToInt(buffer, offset, (length-5)*2, 9);
0:       // get the value of another 9 digits (5 bytes).
0:       int meLo = packedNybblesToInt(buffer, offset, (length-10)*2+1, 9);
0:       // get the value of another 9 digits (5 bytes).
0:       int meHi = packedNybblesToInt(buffer, offset, (length-14)*2, 9);
0:       // get the value of the rest digits.
0:       int hi   = packedNybblesToInt(buffer, offset, 0, (length-14)*2);
1: 
0:       return signum * (lo   / Math.pow(10, scale) +
0:                        meLo * Math.pow(10, 9-scale) +
0:                        meHi * Math.pow(10, 18-scale) +
0:                        hi   * Math.pow(10, 27-scale));
1:     }
0:     else {
0:       // throw an exception here if nibbles is greater than 31
0:       throw new java.lang.IllegalArgumentException ("Decimal may only be up to 31 digits!");
1:     }
1:   }
1: 
1:   /**
0:    * Build a Java <code>long</code> from a fixed point decimal byte representation.
0:    *
0:    * @exception IllegalArgumentException if the specified representation is not recognized.
1:    */
0:   public static final long getLong (byte[] buffer,
0:                               int offset,
0:                               int precision,
0:                               int scale
0:                               ) throws java.io.UnsupportedEncodingException
0:   {
0:     if (precision > 31) {
0:       // throw an exception here if nibbles is greater than 31
0:       throw new java.lang.IllegalArgumentException ("Decimal may only be up to 31 digits!");
1:     }
1: 
0:     // The byte-length of a packed decimal with precision <code>p</code> is always <code>p/2 + 1</code>
0:     int length = precision / 2 + 1;
1: 
0:     // check for sign.
0:     int signum;
0:     if ((buffer[offset+length-1] & 0x0F) == 0x0D)
0:       signum = -1;
0:     else
0:       signum =  1;
1: 
0:     // compute the integer part only.
0:     int leftOfDecimalPoint = length*2-1-scale;
0:     long integer = 0;
0:     if (leftOfDecimalPoint > 0) {
0:       int i = 0;
0:       for (; i<leftOfDecimalPoint/2; i++) {
0:         integer = integer*10 + signum*((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
0:         integer = integer*10 + signum* (buffer[offset+i] & 0x0F);        // low nybble.
1:       }
0:       if ((leftOfDecimalPoint % 2) == 1) {
0:         // process high nybble of the last byte if necessary.
0:         integer = integer*10 + signum*((buffer[offset+i] & 0xF0) >>> 4);
1:       }
1:     }
1: 
0:     return integer;
1:   }
1: 
0:   //--------------entry points for runtime representation-----------------------
1: 
1:   /**
0:     Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
1:   */
0:   public static final int bigDecimalToPackedDecimalBytes (byte[] buffer,
0:                                                     int offset,
0:                                                     java.math.BigDecimal b,
0:                                                     int declaredPrecision,
0:                                                     int declaredScale)
0:                                                     throws ConversionException
0:   {
0:     // packed decimal may only be up to 31 digits.
0:     if (declaredPrecision > 31)  
0:       throw new ConversionException ("Packed decimal may only be up to 31 digits!");
1: 
0:     // get absolute unscaled value of the BigDecimal as a String.
0:     String unscaledStr = b.unscaledValue().abs().toString();
1: 
0:     // get precision of the BigDecimal.
0:     int bigPrecision = unscaledStr.length();
1: 
0:     if (bigPrecision > 31)
0:       throw new ConversionException ("The numeric literal \"" +
0:                              b.toString() +
0:                              "\" is not valid because its value is out of range.",
0:                              "42820",
0:                              -405);
1: 
0:     int bigScale = b.scale();
0:     int bigWholeIntegerLength = bigPrecision - bigScale;
0:     if ( (bigWholeIntegerLength > 0) && (!unscaledStr.equals ("0")) ) {
0:       // if whole integer part exists, check if overflow.
0:       int declaredWholeIntegerLength = declaredPrecision - declaredScale;
0:       if (bigWholeIntegerLength > declaredWholeIntegerLength)
0:         throw new ConversionException ("Overflow occurred during numeric data type conversion of \"" +
0:                                        b.toString() +
0:                                        "\".",
0:                                        "22003",
0:                                        -413);
1:     }
1: 
0:     // convert the unscaled value to a packed decimal bytes.
1: 
0:     // get unicode '0' value.
0:     int zeroBase = '0';
1: 
0:     // start index in target packed decimal.
0:     int packedIndex = declaredPrecision-1;
1: 
0:     // start index in source big decimal.
0:     int bigIndex;
1: 
0:     if (bigScale >= declaredScale) {
0:       // If target scale is less than source scale,
0:       // discard excessive fraction.
1: 
0:       // set start index in source big decimal to ignore excessive fraction.
0:       bigIndex = bigPrecision-1-(bigScale-declaredScale);
1: 
0:       if (bigIndex < 0) {
0:         // all digits are discarded, so only process the sign nybble.
0:         buffer[offset+(packedIndex+1)/2] =
0:           (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
1:       }
0:       else {
0:         // process the last nybble together with the sign nybble.
0:         buffer[offset+(packedIndex+1)/2] =
0:           (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // last nybble
0:                  ( (b.signum()>=0)?12:13 ) ); // sign nybble
1:       }
0:       packedIndex-=2;
0:       bigIndex-=2;
1:     }
0:     else {
0:       // If target scale is greater than source scale,
0:       // pad the fraction with zero.
1: 
0:       // set start index in source big decimal to pad fraction with zero.
0:       bigIndex = declaredScale-bigScale-1;
1: 
0:       // process the sign nybble.
0:       buffer[offset+(packedIndex+1)/2] =
0:         (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
1: 
0:       for (packedIndex-=2, bigIndex-=2; bigIndex>=0; packedIndex-=2, bigIndex-=2)
0:         buffer[offset+(packedIndex+1)/2] = (byte) 0;
1: 
0:       if (bigIndex == -1) {
0:         buffer[offset+(packedIndex+1)/2] =
0:           (byte) ( (unscaledStr.charAt(bigPrecision-1)-zeroBase) << 4 ); // high nybble
1: 
0:         packedIndex-=2;
0:         bigIndex = bigPrecision-3;
1:       }
0:       else {
0:         bigIndex = bigPrecision-2;
1:       }
1:     }
1: 
0:     // process the rest.
0:     for (; bigIndex>=0; packedIndex-=2, bigIndex-=2) {
0:       buffer[offset+(packedIndex+1)/2] =
0:         (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // high nybble
0:                ( unscaledStr.charAt(bigIndex+1)-zeroBase ) ); // low nybble
1:     }
1: 
0:     // process the first nybble when there is one left.
0:     if (bigIndex == -1) {
0:       buffer[offset+(packedIndex+1)/2] =
0:         (byte) (unscaledStr.charAt(0) - zeroBase);
1: 
0:       packedIndex-=2;
1:     }
1: 
0:     // pad zero in front of the big decimal if necessary.
0:     for (; packedIndex>=-1; packedIndex-=2)
0:       buffer[offset+(packedIndex+1)/2] = (byte) 0;
1: 
0:     return declaredPrecision/2 + 1;
1:   }
1: }
============================================================================