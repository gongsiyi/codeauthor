1:1c08813: /*
6:1c08813: 
1:1bac3f3:    Derby - Class org.apache.derby.impl.store.replication.slave.ReplicationLogScan
1:1c08813: 
1:1c08813:    Licensed to the Apache Software Foundation (ASF) under one or more
1:1c08813:    contributor license agreements.  See the NOTICE file distributed with
1:1c08813:    this work for additional information regarding copyright ownership.
1:1c08813:    The ASF licenses this file to you under the Apache License, Version 2.0
1:1c08813:    (the "License"); you may not use this file except in compliance with
1:1c08813:    the License.  You may obtain a copy of the License at
1:1c08813: 
1:1c08813:       http://www.apache.org/licenses/LICENSE-2.0
1:1c08813: 
1:1c08813:    Unless required by applicable law or agreed to in writing, software
1:1c08813:    distributed under the License is distributed on an "AS IS" BASIS,
1:1c08813:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1c08813:    See the License for the specific language governing permissions and
1:1c08813:    limitations under the License.
1:1c08813: 
6:1c08813:  */
1:1c08813: 
1:1bac3f3: package org.apache.derby.impl.store.replication.slave;
1:1c08813: 
1:1c08813: import org.apache.derby.iapi.error.StandardException;
1:1c08813: import org.apache.derby.iapi.reference.SQLState;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:1c08813: 
1:1c08813: import java.util.NoSuchElementException;
1:1c08813: 
6:1c08813: /**
2:1c08813:  * <p>
1:1c08813:  * Scan a chunk of log received from the master. The log chunk (byte[]
1:1c08813:  * logToScan) is assumed to always contain (an unknown) number of
1:1c08813:  * complete log records. If the last log record is incomplete,
1:1c08813:  * something is wrong. This will raise a StandardException, and will
1:1c08813:  * probably mean that replication has to be aborted. That decision is
1:1c08813:  * not made here, though.
2:1c08813:  * </p>
1:1c08813:  * <p>
1:1c08813:  * When a new chunk of log records is to be scanned, ReplicationLogScan
1:1c08813:  * is initialized by calling init(...). Every time next() is called
1:1c08813:  * after that, ReplicationLogScan reads a new log record from
1:1c08813:  * logToScan. If next() returns true, the next log record was
1:5235dfd:  * successfully read. The information in this last read log record
1:5235dfd:  * either indicates that a log file switch has taken place on the
1:5235dfd:  * master (isLogSwitch() = true) or it is a normal log record which
1:5235dfd:  * information can be retrieved by using the get-methods (if
1:5235dfd:  * isLogRecord() = true).
1:1c08813:  * </p>
1:1c08813:  * <p>
1:1c08813:  * Threads: The class does not provide thread synchronization since it
1:1c08813:  * is assumed that only one thread will be receiving and applying log
1:1c08813:  * per replicated database when in slave mode. Since a
1:1c08813:  * ReplicationLogScan object belongs to only one slave database, this
1:1c08813:  * means that only one thread will access the object.
1:1c08813:  * </p>
1:1c08813:  * <p>
1:1c08813:  * The format of the log chunk byte[] is defined in 
1:5235dfd:  * org.apache.derby.impl.store.raw.log.LogAccessFile
1:1c08813:  * </p>
1:5235dfd:  * @see org.apache.derby.impl.store.raw.log.LogAccessFile
1:1c08813:  */
1:1c08813: 
1:1c08813: class ReplicationLogScan {
1:1c08813: 
1:1c08813:     private byte[] logToScan;     // the chunk of log to scan
1:1c08813:     private int currentPosition;  // how long we have read in logToScan
1:1c08813: 
1:1c08813:     // Data for the latest log record read by next(). Use the
1:1c08813:     // get-methods to retrieve these
1:1c08813:     private long currentInstant;
1:1c08813:     private int currentDataOffset;
1:1c08813:     private byte[] currentData;
1:5235dfd: 
1:5235dfd:     /** hasInfo = true when the scan will return meaningful
1:5235dfd:      * information, either in the form of a log record (in which case
1:5235dfd:      * the above variables will be set), or when it has found a log
1:5235dfd:      * record indicating that a log file switch has taken place on the
1:5235dfd:      * master (isLogSwitch = true). hasInfo = false before next() is
1:5235dfd:      * called for the first time, after next() has reached the end of
1:5235dfd:      * logToScan and if an error occured when parsing logToScan (i.e.
1:5235dfd:      * when next() has thrown a StandardException)
1:5235dfd:      */
1:5235dfd:     private boolean hasInfo;
1:5235dfd: 
1:5235dfd:     /** true if the last read log record indicates a log switch, false
1:5235dfd:      * if it is a normal log record private boolean isLogSwitch;
1:5235dfd:      */
1:5235dfd:     private boolean isLogSwitch;
1:1c08813: 
1:1c08813:     protected ReplicationLogScan() { }
1:1c08813: 
1:1c08813:     /**
1:1c08813:      * Set all variables to default values, and makes logToScan the
1:1c08813:      * byte[] that will be scanned for log records.
1:1c08813:      * @param logToScan A chunk of log records received from the
1:1c08813:      * master
1:1c08813:      */
1:1c08813:     protected void init(byte[] logToScan) {
1:1c08813:         this.logToScan = logToScan;
1:1c08813: 
1:1c08813:         currentPosition = 0;
1:1c08813:         currentInstant = -1;
1:1c08813:         currentData = null;
1:5235dfd:         isLogSwitch = false;
1:5235dfd:         hasInfo = false;
11:1c08813:     }
1:1c08813: 
1:1c08813:     /**
1:1c08813:      * <p>
1:1c08813:      * Read the next log record in logToScan. The information in this
1:1c08813:      * log record can be read by using the getXXX methods.
1:1c08813:      * </p>
1:1c08813:      * <p>
1:1c08813:      * Side effects: <br>
1:1c08813:      * <br>
1:5235dfd:      * On a successful read (return true): either...<br>
1:5235dfd:      *<br>
1:5235dfd:      * ... the scan read a log record indicating that a log file
1:5235dfd:      * switch has taken place on the master, in which case
1:5235dfd:      * isLogFileSwitch() returns true. In this case, getXXX will not
1:5235dfd:      * contain valid data. Asserts handle calls to these methods when
1:5235dfd:      * in sane mode. currentPosition is updated to point to the byte
1:5235dfd:      * immediately following this log file switch log record.<br>
1:5235dfd:      *<br>
1:5235dfd:      * ... or the scan read a normal log record, in which case
1:5235dfd:      * isLogRecord() returns true. Also sets currentInstant and
1:5235dfd:      * currentData, and updates currentPosition to point to the byte
1:5235dfd:      * immediatly following the log record. In this case, getXXX will
1:5235dfd:      * return meaningful information about the log record.
1:1c08813:      * </p>
1:1c08813:      * <p>
1:1c08813:      * If there are no more log records in logToScan (returns false) or
1:1c08813:      * a problem occurs (throws StandardException): setting
1:5235dfd:      * hasInfo = false
1:1c08813:      * </p>
1:1c08813:      * @return true if a log record was successfully read, false if end
1:1c08813:      * of logToScan has been reached.
1:5235dfd:      * @throws StandardException if logToScan is found to be corrupted.
1:1c08813:      */
1:1c08813:     protected boolean next() throws StandardException {
1:1c08813: 
1:1c08813:         /* format of received log:
1:1c08813:          *
1:5235dfd:          * (int)    total_length (data[].length + optionaldata[].length)
1:1c08813:          * (long)   instant
1:5235dfd:          * (byte[]) data+optionaldata
1:5235dfd:          * (int)    total_length
1:1c08813:          */
1:1c08813: 
1:1c08813:         if (SanityManager.DEBUG){
1:1c08813:             SanityManager.ASSERT(logToScan.length >= currentPosition,
1:1c08813:                                  "Outside log byte[] boundary");
1:1c08813:         }
1:1c08813: 
1:1c08813:         if (currentPosition == logToScan.length) {
1:1c08813:             // Last log record of this logToScan has already been
1:1c08813:             // read, so we can simply return "false". Does not check
1:1c08813:             // for >= because ">" would probably mean the log is
1:1c08813:             // corrupt. If so, we want an exception to be thrown
1:1c08813:             // instead (will be thrown by readXXX below). It should
1:1c08813:             // not be possible for currentPosition to be greater than
1:1c08813:             // logToScan.length if not an exception was thrown by the
1:1c08813:             // previous next() call
1:5235dfd:             hasInfo = false;
1:5235dfd:             return hasInfo;
1:1c08813:         }
1:1c08813: 
1:1c08813:         try {
1:5235dfd:             int currentLength = retrieveInt();   // (int)  dataLength
1:1c08813: 
1:5235dfd:             if (currentLength == 0) { 
1:5235dfd:                 // int value 0 is written to log to mark EOF. A length
1:5235dfd:                 // of 0 therefore means that a log file switch has
1:5235dfd:                 // taken place on the master
1:5235dfd:                 isLogSwitch = true;
1:5235dfd:                 hasInfo = true;
1:5235dfd:             } else {
1:1c08813: 
1:5235dfd:                 currentInstant = retrieveLong(); // (long) instant
1:1c08813: 
1:5235dfd:                 // (byte[]) data
1:5235dfd:                 currentData = new byte[currentLength];
1:5235dfd:                 retrieveBytes(currentData, currentLength);
1:5235dfd: 
1:5235dfd:                 retrieveInt();                   // (int) trailing length
1:5235dfd: 
1:5235dfd:                 isLogSwitch = false;
1:5235dfd:                 hasInfo = true;
1:5235dfd:             }
1:1c08813:         } catch(StandardException se){
1:1c08813:             // Means that we have tried to read higher byte addresses
1:1c08813:             // than the size of logToScan. That should not happen as
1:5235dfd:             // long as logToScan is not corrupted. E.g., this could mean
1:5235dfd:             // that the data length was
1:1c08813:             // wrong. No matter what caused us to be outside the
1:1c08813:             // logToScan size, we will not be able to read more log
1:1c08813:             // from this logToScan, and should probably abort the
1:5235dfd:             // whole replication due to corrupted data. That decision is
1:1c08813:             // not made here, however.
1:5235dfd:             hasInfo = false;
1:1c08813:             throw se;
1:1c08813:         }
1:1c08813: 
1:5235dfd:         return hasInfo;
1:1c08813:     }
1:1c08813: 
1:1c08813:     /**
1:1c08813:      * @return The instant of the log record read by the last call to
1:5235dfd:      * next(). Only returns meaningful information if isLogRecord()
1:5235dfd:      * returns true.
6:1c08813:      * @throws NoSuchElementException if next() has not been called or
6:1c08813:      * if there are no more log records in this chunk of log. Should
6:1c08813:      * never be thrown unless ReplicationLogScan is used in a wrong
6:1c08813:      * way.
1:1c08813:      */
1:1c08813:     protected long getInstant() throws NoSuchElementException{
1:5235dfd:         if (!hasInfo) {
6:1c08813:             throw new NoSuchElementException();
1:1c08813:         }
1:5235dfd: 
1:5235dfd:         if (isLogSwitch) {
1:5235dfd:             if (SanityManager.DEBUG){
1:5235dfd:                 SanityManager.THROWASSERT("Log switch log records " +
1:5235dfd:                                           "have no instant");
1:5235dfd:             }
1:5235dfd:             return -1;
1:5235dfd:         }
1:5235dfd: 
1:5235dfd:         return currentInstant;
1:1c08813:     }
1:1c08813: 
1:1c08813:     /**
1:1c08813:      * @return The number of bytes in the byte[] returned by getData()
1:5235dfd:      * for the log record read by the last call to next(). Only
1:5235dfd:      * returns meaningful information if isLogRecord() returns true.
1:1c08813:      * @throws NoSuchElementException if next() has not been called or
1:1c08813:      * if there are no more log records in this chunk of log. Should
1:1c08813:      * never be thrown unless ReplicationLogScan is used in a wrong
1:1c08813:      * way.
1:1c08813:      */
1:1c08813:     protected int getDataLength() throws NoSuchElementException{
1:5235dfd:         if (!hasInfo) {
1:1c08813:             throw new NoSuchElementException();
1:1c08813:         }
1:5235dfd: 
1:5235dfd:         if (isLogSwitch) {
1:5235dfd:             if (SanityManager.DEBUG){
1:5235dfd:                 SanityManager.THROWASSERT("Log switch log records " +
1:5235dfd:                                           "have no length");
1:5235dfd:             }
1:5235dfd:             return -1;
1:5235dfd:         }
1:5235dfd: 
1:5235dfd:         return currentData.length;
1:1c08813:     }
1:1c08813: 
1:1c08813:     /**
1:5235dfd:      * Method to get the data byte[] read by the last call to next().
1:5235dfd:      * Note that this byte[] contains both byte[] data and byte[]
1:5235dfd:      * optional_data from LogAccessFile. To split this byte[] into
1:5235dfd:      * data and optional_data, we would need to create a Loggable
1:5235dfd:      * object from it because the log does not provide information on
1:5235dfd:      * where to split. There is no need to split since this byte[]
1:5235dfd:      * will only be written to the slave log anyway. If it was split,
1:5235dfd:      * LogAccessFile would simply merge them when writing to file.
1:5235dfd:      *
1:5235dfd:      * @return The byte[] containing data+optional_data of the log
1:5235dfd:      * record read by the last call to next(). Only returns meaningful
1:5235dfd:      * information if isLogRecord() returns true.
1:1c08813:      * @throws NoSuchElementException if next() has not been called or
1:1c08813:      * if there are no more log records in this chunk of log. Should
1:1c08813:      * never be thrown unless ReplicationLogScan is used in a wrong
1:1c08813:      * way.
1:1c08813:      */
1:1c08813:     protected byte[] getData() throws NoSuchElementException{
1:5235dfd:         if (!hasInfo) {
1:1c08813:             throw new NoSuchElementException();
1:1c08813:         }
1:5235dfd: 
1:5235dfd:         if (isLogSwitch) {
1:5235dfd:             if (SanityManager.DEBUG){
1:5235dfd:                 SanityManager.THROWASSERT("Log switch log records " +
1:5235dfd:                                           "have no data");
1:5235dfd:             }
1:5235dfd:             return null;
1:5235dfd:         }
1:5235dfd: 
1:5235dfd:         return currentData;
1:1c08813:     }
1:1c08813: 
1:1c08813:     /**
1:5235dfd:      * Used to determine whether or not the last call to next() was
1:5235dfd:      * successful.
1:1c08813:      * @return true if next() has been called and the end of the log
1:1c08813:      * chunk has not yet been reached. Returns the same answer as the
1:5235dfd:      * last call to next() did. Use isLogFileSwitch() and
1:5235dfd:      * isLogRecord() to find out if the current log record indicates a
1:5235dfd:      * log file switch or is a normal log record.
1:1c08813:      */
1:5235dfd:     protected boolean hasValidInformation() {
1:5235dfd:         return hasInfo;
1:5235dfd:     }
1:5235dfd: 
1:5235dfd:     /**
1:5235dfd:      * Used to determine whether the last call to next() read a log
1:5235dfd:      * record
1:5235dfd:      * @return true if the last call to next() found a normal log
1:5235dfd:      * record.
1:5235dfd:      * @throws NoSuchElementException if next() has not been called or
1:5235dfd:      * if there are no more log records in this chunk of log. Should
1:5235dfd:      * never be thrown unless ReplicationLogScan is used in a wrong
1:5235dfd:      * way.
1:5235dfd:      */
1:5235dfd:     protected boolean isLogRecord()  throws NoSuchElementException{
1:5235dfd:         if (!hasInfo) {
1:5235dfd:             throw new NoSuchElementException();
1:5235dfd:         }
1:5235dfd: 
1:5235dfd:         return !isLogSwitch;
1:5235dfd:     }
1:5235dfd: 
1:5235dfd:     /**
1:5235dfd:      * Used to determine whether the last call to next() found a log
1:5235dfd:      * file switch
1:5235dfd:      * @return true if the last call to next() found a log record
1:5235dfd:      * indicating a log file switch has taken place on the master.
1:5235dfd:      * @throws NoSuchElementException if next() has not been called or
1:5235dfd:      * if there are no more log records in this chunk of log. Should
1:5235dfd:      * never be thrown unless ReplicationLogScan is used in a wrong
1:5235dfd:      * way.
1:5235dfd:      */
1:5235dfd:     protected boolean isLogFileSwitch() throws NoSuchElementException{
1:5235dfd:         if (!hasInfo) {
1:5235dfd:             throw new NoSuchElementException();
1:5235dfd:         }
1:5235dfd: 
1:5235dfd:         return isLogSwitch;
1:1c08813:     }
1:1c08813: 
1:1c08813:     /*
1:1c08813:      * The retrieveXXX methods are used by next() to read a log record
1:1c08813:      * from byte[] logToScan. The methods should be changed to
1:1c08813:      * java.nio.ByteBuffer if it is later decided that replication
1:1c08813:      * does not have to support j2me.
1:1c08813:      */
1:1c08813: 
1:1c08813:     /**
1:1c08813:      * Copy length number of bytes from logToScan into readInto.
1:1c08813:      * Starts to copy from currentPosition. Also increments
1:1c08813:      * currentPosition by length.
1:1c08813:      * @param readInto The byte[] copied to
1:1c08813:      * @param length The number of bytes copied from logToScan to readInto
1:1c08813:      * @throws StandardException if there are less then length bytes
1:1c08813:      * left to read in logToScan, meaning that the chunk of log is
1:1c08813:      * corrupt.
1:1c08813:      */
1:1c08813:     private void retrieveBytes(byte[] readInto, int length)
1:1c08813:         throws StandardException{
1:1c08813: 
1:1c08813:         if (SanityManager.DEBUG){
1:1c08813:             SanityManager.ASSERT(logToScan.length >= currentPosition + length,
1:1c08813:                                  "Trying to read more bytes than there are " +
1:1c08813:                                  "in this logToScan");
1:1c08813:             SanityManager.ASSERT(readInto.length == length,
1:1c08813:                                  "readInto does not have a size of " + length +
1:1c08813:                                  ", but a size of " + readInto.length);
1:1c08813:         }
1:1c08813: 
1:1c08813:         try {
1:1c08813:             System.arraycopy(logToScan, currentPosition, readInto, 0, length);
1:1c08813:             currentPosition += length;
1:1c08813:         } catch (ArrayIndexOutOfBoundsException aioobe) {
1:1c08813:             throw StandardException.
1:1c08813:                 newException(SQLState.REPLICATION_LOG_CORRUPTED, aioobe);
1:1c08813:         }
1:1c08813:     }
1:1c08813: 
1:1c08813:     /**
1:1c08813:      * Read an int from logToScan. Also increments currentPosition by
1:1c08813:      * 4 (the number of bytes in an int).
1:1c08813:      * @return an int read from logToScan
1:1c08813:      * @throws StandardException if there are less then 4 bytes left
1:1c08813:      * to read in logToScan, meaning that the chunk of log is corrupt.
1:1c08813:      */
1:1c08813:     private int retrieveInt() throws StandardException{
1:1c08813:         if (SanityManager.DEBUG){
1:1c08813:             SanityManager.ASSERT(logToScan.length >= currentPosition + 4,
1:1c08813:                                  "Trying to read more bytes than there are " +
1:1c08813:                                  "in this logToScan");
1:1c08813:         }
1:1c08813:         try {
1:1c08813:             int i = ((logToScan[currentPosition++] << 24) 
1:1c08813:                      + ((logToScan[currentPosition++] & 0xff) << 16) 
1:1c08813:                      + ((logToScan[currentPosition++] & 0xff) << 8) 
1:1c08813:                      + (logToScan[currentPosition++] & 0xff));
1:1c08813:             return i;
1:1c08813:         } catch (ArrayIndexOutOfBoundsException aioobe) {
1:1c08813:             throw StandardException.
1:1c08813:                 newException(SQLState.REPLICATION_LOG_CORRUPTED, aioobe);
1:1c08813:         }
1:1c08813:     }
1:1c08813: 
1:1c08813:     /**
1:1c08813:      * Read a long from logToScan. Also increments currentPosition by
1:1c08813:      * 8 (the number of bytes in a long).
1:1c08813:      * @return a long read from logToScan
1:1c08813:      * @throws StandardException if there are less then 8 bytes left
1:1c08813:      * to read in logToScan, meaning that the chunk of log is corrupt.
1:1c08813:      */
1:1c08813:     private long retrieveLong() throws StandardException{
1:1c08813:         if (SanityManager.DEBUG){
1:1c08813:             SanityManager.ASSERT(logToScan.length >= currentPosition + 8,
1:1c08813:                                  "Trying to read more bytes than there are " +
1:1c08813:                                  "in this logToScan");
1:1c08813:         }
1:1c08813:         try {
1:1c08813:             long l = ((((long)logToScan[currentPosition++]) << 56) 
1:1c08813:                       + ((logToScan[currentPosition++] & 0xffL) << 48)
1:1c08813:                       + ((logToScan[currentPosition++] & 0xffL) << 40)
1:1c08813:                       + ((logToScan[currentPosition++] & 0xffL) << 32)
1:1c08813:                       + ((logToScan[currentPosition++] & 0xffL) << 24)
1:1c08813:                       + ((logToScan[currentPosition++] & 0xff) << 16)
1:1c08813:                       + ((logToScan[currentPosition++] & 0xff) << 8)
1:1c08813:                       + (logToScan[currentPosition++] & 0xff));
1:1c08813:             return l;
1:1c08813:         } catch (ArrayIndexOutOfBoundsException aioobe) {
1:1c08813:             throw StandardException.
1:1c08813:                 newException(SQLState.REPLICATION_LOG_CORRUPTED, aioobe);
1:1c08813:         }
1:1c08813:     }
1:1c08813: 
1:1c08813: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:1bac3f3
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.replication.slave.ReplicationLogScan
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.store.replication.slave;
commit:5235dfd
/////////////////////////////////////////////////////////////////////////
1:  * successfully read. The information in this last read log record
1:  * either indicates that a log file switch has taken place on the
1:  * master (isLogSwitch() = true) or it is a normal log record which
1:  * information can be retrieved by using the get-methods (if
1:  * isLogRecord() = true).
/////////////////////////////////////////////////////////////////////////
1:  * org.apache.derby.impl.store.raw.log.LogAccessFile
1:  * @see org.apache.derby.impl.store.raw.log.LogAccessFile
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** hasInfo = true when the scan will return meaningful
1:      * information, either in the form of a log record (in which case
1:      * the above variables will be set), or when it has found a log
1:      * record indicating that a log file switch has taken place on the
1:      * master (isLogSwitch = true). hasInfo = false before next() is
1:      * called for the first time, after next() has reached the end of
1:      * logToScan and if an error occured when parsing logToScan (i.e.
1:      * when next() has thrown a StandardException)
1:      */
1:     private boolean hasInfo;
1: 
1:     /** true if the last read log record indicates a log switch, false
1:      * if it is a normal log record private boolean isLogSwitch;
1:      */
1:     private boolean isLogSwitch;
/////////////////////////////////////////////////////////////////////////
1:         isLogSwitch = false;
1:         hasInfo = false;
/////////////////////////////////////////////////////////////////////////
1:      * On a successful read (return true): either...<br>
1:      *<br>
1:      * ... the scan read a log record indicating that a log file
1:      * switch has taken place on the master, in which case
1:      * isLogFileSwitch() returns true. In this case, getXXX will not
1:      * contain valid data. Asserts handle calls to these methods when
1:      * in sane mode. currentPosition is updated to point to the byte
1:      * immediately following this log file switch log record.<br>
1:      *<br>
1:      * ... or the scan read a normal log record, in which case
1:      * isLogRecord() returns true. Also sets currentInstant and
1:      * currentData, and updates currentPosition to point to the byte
1:      * immediatly following the log record. In this case, getXXX will
1:      * return meaningful information about the log record.
1:      * hasInfo = false
1:      * @throws StandardException if logToScan is found to be corrupted.
1:          * (int)    total_length (data[].length + optionaldata[].length)
1:          * (byte[]) data+optionaldata
1:          * (int)    total_length
/////////////////////////////////////////////////////////////////////////
1:             hasInfo = false;
1:             return hasInfo;
1:             int currentLength = retrieveInt();   // (int)  dataLength
1:             if (currentLength == 0) { 
1:                 // int value 0 is written to log to mark EOF. A length
1:                 // of 0 therefore means that a log file switch has
1:                 // taken place on the master
1:                 isLogSwitch = true;
1:                 hasInfo = true;
1:             } else {
1:                 currentInstant = retrieveLong(); // (long) instant
1:                 // (byte[]) data
1:                 currentData = new byte[currentLength];
1:                 retrieveBytes(currentData, currentLength);
1: 
1:                 retrieveInt();                   // (int) trailing length
1: 
1:                 isLogSwitch = false;
1:                 hasInfo = true;
1:             }
1:             // long as logToScan is not corrupted. E.g., this could mean
1:             // that the data length was
1:             // whole replication due to corrupted data. That decision is
1:             hasInfo = false;
1:         return hasInfo;
1:      * next(). Only returns meaningful information if isLogRecord()
1:      * returns true.
1:         if (!hasInfo) {
1: 
1:         if (isLogSwitch) {
1:             if (SanityManager.DEBUG){
1:                 SanityManager.THROWASSERT("Log switch log records " +
1:                                           "have no instant");
1:             }
1:             return -1;
1:         }
1: 
1:         return currentInstant;
1:      * for the log record read by the last call to next(). Only
1:      * returns meaningful information if isLogRecord() returns true.
1:         if (!hasInfo) {
1: 
1:         if (isLogSwitch) {
1:             if (SanityManager.DEBUG){
1:                 SanityManager.THROWASSERT("Log switch log records " +
1:                                           "have no length");
1:             }
1:             return -1;
1:         }
1: 
1:         return currentData.length;
1:      * Method to get the data byte[] read by the last call to next().
1:      * Note that this byte[] contains both byte[] data and byte[]
1:      * optional_data from LogAccessFile. To split this byte[] into
1:      * data and optional_data, we would need to create a Loggable
1:      * object from it because the log does not provide information on
1:      * where to split. There is no need to split since this byte[]
1:      * will only be written to the slave log anyway. If it was split,
1:      * LogAccessFile would simply merge them when writing to file.
1:      *
1:      * @return The byte[] containing data+optional_data of the log
1:      * record read by the last call to next(). Only returns meaningful
1:      * information if isLogRecord() returns true.
1:         if (!hasInfo) {
1: 
1:         if (isLogSwitch) {
1:             if (SanityManager.DEBUG){
1:                 SanityManager.THROWASSERT("Log switch log records " +
1:                                           "have no data");
1:             }
1:             return null;
1:         }
1: 
1:         return currentData;
1:      * Used to determine whether or not the last call to next() was
1:      * successful.
1:      * last call to next() did. Use isLogFileSwitch() and
1:      * isLogRecord() to find out if the current log record indicates a
1:      * log file switch or is a normal log record.
1:     protected boolean hasValidInformation() {
1:         return hasInfo;
1:     }
1: 
1:     /**
1:      * Used to determine whether the last call to next() read a log
1:      * record
1:      * @return true if the last call to next() found a normal log
1:      * record.
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
1:     protected boolean isLogRecord()  throws NoSuchElementException{
1:         if (!hasInfo) {
1:             throw new NoSuchElementException();
1:         }
1: 
1:         return !isLogSwitch;
1:     }
1: 
1:     /**
1:      * Used to determine whether the last call to next() found a log
1:      * file switch
1:      * @return true if the last call to next() found a log record
1:      * indicating a log file switch has taken place on the master.
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
1:     protected boolean isLogFileSwitch() throws NoSuchElementException{
1:         if (!hasInfo) {
1:             throw new NoSuchElementException();
1:         }
1: 
1:         return isLogSwitch;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1c08813
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derby.impl.services.replication.slave.ReplicationLogScan
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
0: package org.apache.derby.impl.services.replication.slave;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import java.util.NoSuchElementException;
1: 
1: /**
1:  * <p>
1:  * Scan a chunk of log received from the master. The log chunk (byte[]
1:  * logToScan) is assumed to always contain (an unknown) number of
1:  * complete log records. If the last log record is incomplete,
1:  * something is wrong. This will raise a StandardException, and will
1:  * probably mean that replication has to be aborted. That decision is
1:  * not made here, though.
1:  * </p>
1:  * <p>
1:  * When a new chunk of log records is to be scanned, ReplicationLogScan
1:  * is initialized by calling init(...). Every time next() is called
1:  * after that, ReplicationLogScan reads a new log record from
1:  * logToScan. If next() returns true, the next log record was
0:  * successfully read. The information in this last read log record can
0:  * be retrieved by using the get-methods.
1:  * </p>
1:  * <p>
1:  * Threads: The class does not provide thread synchronization since it
1:  * is assumed that only one thread will be receiving and applying log
1:  * per replicated database when in slave mode. Since a
1:  * ReplicationLogScan object belongs to only one slave database, this
1:  * means that only one thread will access the object.
1:  * </p>
1:  * <p>
1:  * The format of the log chunk byte[] is defined in 
0:  * org.apache.derby.impl.services.replication.buffer.LogBufferElement
1:  * </p>
1:  * <p>
0:  * @see
0:  * org.apache.derby.impl.services.replication.buffer.LogBufferElement
0:  * org.apache.derby.impl.services.replication.buffer.LogBufferElement
1:  * </p>
1:  */
1: 
1: class ReplicationLogScan {
1: 
1:     private byte[] logToScan;     // the chunk of log to scan
1:     private int currentPosition;  // how long we have read in logToScan
1: 
1:     // Data for the latest log record read by next(). Use the
1:     // get-methods to retrieve these
1:     private long currentInstant;
1:     private int currentDataOffset;
0:     private int currentOptDataOffset;
1:     private byte[] currentData;
0:     private byte[] currentOptData;
0:     // validLogRecord = true when the above variables contain
0:     // meaningful data. false before next() is called for the first
0:     // time and after next() has reached the end of logToScan
0:     private boolean validLogRecord;
1: 
1:     protected ReplicationLogScan() { }
1: 
1:     /**
1:      * Set all variables to default values, and makes logToScan the
1:      * byte[] that will be scanned for log records.
1:      * @param logToScan A chunk of log records received from the
1:      * master
1:      */
1:     protected void init(byte[] logToScan) {
1:         this.logToScan = logToScan;
1: 
1:         currentPosition = 0;
1:         currentInstant = -1;
0:         currentDataOffset = -1;
0:         currentOptDataOffset = -1;
1:         currentData = null;
0:         currentOptData = null;
0:         validLogRecord = false;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Read the next log record in logToScan. The information in this
1:      * log record can be read by using the getXXX methods.
1:      * </p>
1:      * <p>
1:      * Side effects: <br>
1:      * <br>
0:      * On a successful read (return true): setting currentInstant,
0:      * currentDataOffset, currentOptDataOffset, currentData,
0:      * currentOptData, validLogRecord = true. Also updates
0:      * currentPosition to point to the byte immediatly following the
0:      * log record.
1:      * </p>
1:      * <p>
1:      * If there are no more log records in logToScan (returns false) or
1:      * a problem occurs (throws StandardException): setting
0:      * validLogRecord = false
1:      * </p>
1:      * @return true if a log record was successfully read, false if end
1:      * of logToScan has been reached.
0:      * @throws StandardException if logToScan is found to be corrupt.
1:      */
1:     protected boolean next() throws StandardException {
1: 
1:         /* format of received log:
1:          *
1:          * (long)   instant
0:          * (int)    dataLength
0:          * (int)    dataOffset
0:          * (int)    optionalDataLength
0:          * (int)    optionalDataOffset
0:          * (byte[]) data
0:          * (byte[]) optionalData
1:          */
1: 
1:         if (SanityManager.DEBUG){
1:             SanityManager.ASSERT(logToScan.length >= currentPosition,
1:                                  "Outside log byte[] boundary");
1:         }
1: 
1:         if (currentPosition == logToScan.length) {
1:             // Last log record of this logToScan has already been
1:             // read, so we can simply return "false". Does not check
1:             // for >= because ">" would probably mean the log is
1:             // corrupt. If so, we want an exception to be thrown
1:             // instead (will be thrown by readXXX below). It should
1:             // not be possible for currentPosition to be greater than
1:             // logToScan.length if not an exception was thrown by the
1:             // previous next() call
0:             validLogRecord = false;
0:             return validLogRecord;
1:         }
1: 
1:         try {
0:             currentInstant = retrieveLong();       // (long) instant
0:             int currentDataLength = retrieveInt(); // (int)  dataLength
0:             currentDataOffset = retrieveInt();     // (int)  dataOffset
0:                                                    // (int)  optionalDataLength
0:             int currentOptDataLength = retrieveInt();
0:             currentOptDataOffset = retrieveInt();  // (int)  optionalDataOffset
1: 
0:             // (byte[]) data
0:             currentData = new byte[currentDataLength];
0:             retrieveBytes(currentData, currentDataLength);
1: 
0:             // (byte[]) optionalData
0:             currentOptData = new byte[currentOptDataLength];
0:             retrieveBytes(currentOptData, currentOptDataLength);
1: 
0:             validLogRecord = true;
1:         } catch(StandardException se){
1:             // Means that we have tried to read higher byte addresses
1:             // than the size of logToScan. That should not happen as
0:             // long as logToScan is not currupt. E.g., this could mean
0:             // that one of the data or optional data lengths were
1:             // wrong. No matter what caused us to be outside the
1:             // logToScan size, we will not be able to read more log
1:             // from this logToScan, and should probably abort the
0:             // whole replication due to corrupt data. That decision is
1:             // not made here, however.
0:             validLogRecord = false;
1:             throw se;
1:         }
1: 
0:         return validLogRecord;
1:     }
1: 
1:     /**
1:      * @return The instant of the log record read by the last call to
0:      * next().
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
1:     protected long getInstant() throws NoSuchElementException{
0:         if (validLogRecord) {
0:             return currentInstant;
0:         } else {
1:             throw new NoSuchElementException();
1:         }
1:     }
1: 
1:     /**
1:      * @return The number of bytes in the byte[] returned by getData()
0:      * for the log record read by the last call to next().
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
1:     protected int getDataLength() throws NoSuchElementException{
0:         if (validLogRecord) {
0:             return currentData.length;
0:         } else {
1:             throw new NoSuchElementException();
1:         }
1:     }
1: 
1:     /**
0:      * @return The offset in the byte[] returned by getData() for the
0:      * log record read by the last call to next().
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
0:     protected int getDataOffset() throws NoSuchElementException{
0:         if (validLogRecord) {
0:             return currentDataOffset;
0:         } else {
1:             throw new NoSuchElementException();
1:         }
1:     }
1: 
1:     /**
0:      * @return The number of bytes in the byte[] returned by
0:      * getOptData() for the log record read by the last call to next().
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
0:     protected int getOptDataLength() throws NoSuchElementException{
0:         if (validLogRecord) {
0:             return currentOptData.length;
0:         } else {
1:             throw new NoSuchElementException();
1:         }
1:     }
1: 
1:     /**
0:      * @return The offset in the byte[] returned by getOptData() for
0:      * the log record read by the last call to next().
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
0:     protected int getOptDataOffset() throws NoSuchElementException{
0:         if (validLogRecord) {
0:             return currentOptDataOffset;
0:         } else {
1:             throw new NoSuchElementException();
1:         }
1:     }
1: 
1:     /**
0:      * @return The data byte[] of the log record read by the last call
0:      * to next().
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
1:     protected byte[] getData() throws NoSuchElementException{
0:         if (validLogRecord) {
0:             return currentData;
0:         } else {
1:             throw new NoSuchElementException();
1:         }
1:     }
1: 
1:     /**
0:      * @return The optionalData byte[] of the log record read by the
0:      * last call to next().
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
0:     protected byte[] getOptData() throws NoSuchElementException{
0:         if (validLogRecord) {
0:             return currentOptData;
0:         } else {
1:             throw new NoSuchElementException();
1:         }
1:     }
1: 
1:     /**
0:      * @return Length of byte[] data + byte[] optionalData of the log
0:      * record read by the last call to next(). This is the same number
0:      * as is stored in the normal Derby transaction log as "lenght" in
0:      * the head and tail of each log record.
1:      * @throws NoSuchElementException if next() has not been called or
1:      * if there are no more log records in this chunk of log. Should
1:      * never be thrown unless ReplicationLogScan is used in a wrong
1:      * way.
1:      */
0:     protected int getTotalDataLength() throws NoSuchElementException{
0:         if (validLogRecord) {
0:             return currentData.length + currentOptData.length;
0:         } else {
1:             throw new NoSuchElementException();
1:         }
1:     }
1: 
1:     /**
1:      * @return true if next() has been called and the end of the log
1:      * chunk has not yet been reached. Returns the same answer as the
0:      * last call to next() did.
1:      */
0:     protected boolean hasValidLogRecord() {
0:         return validLogRecord;
1:     }
1: 
1:     /*
1:      * The retrieveXXX methods are used by next() to read a log record
1:      * from byte[] logToScan. The methods should be changed to
1:      * java.nio.ByteBuffer if it is later decided that replication
1:      * does not have to support j2me.
1:      */
1: 
1:     /**
1:      * Copy length number of bytes from logToScan into readInto.
1:      * Starts to copy from currentPosition. Also increments
1:      * currentPosition by length.
1:      * @param readInto The byte[] copied to
1:      * @param length The number of bytes copied from logToScan to readInto
1:      * @throws StandardException if there are less then length bytes
1:      * left to read in logToScan, meaning that the chunk of log is
1:      * corrupt.
1:      */
1:     private void retrieveBytes(byte[] readInto, int length)
1:         throws StandardException{
1: 
1:         if (SanityManager.DEBUG){
1:             SanityManager.ASSERT(logToScan.length >= currentPosition + length,
1:                                  "Trying to read more bytes than there are " +
1:                                  "in this logToScan");
1:             SanityManager.ASSERT(readInto.length == length,
1:                                  "readInto does not have a size of " + length +
1:                                  ", but a size of " + readInto.length);
1:         }
1: 
1:         try {
1:             System.arraycopy(logToScan, currentPosition, readInto, 0, length);
1:             currentPosition += length;
1:         } catch (ArrayIndexOutOfBoundsException aioobe) {
1:             throw StandardException.
1:                 newException(SQLState.REPLICATION_LOG_CORRUPTED, aioobe);
1:         }
1:     }
1: 
1:     /**
1:      * Read an int from logToScan. Also increments currentPosition by
1:      * 4 (the number of bytes in an int).
1:      * @return an int read from logToScan
1:      * @throws StandardException if there are less then 4 bytes left
1:      * to read in logToScan, meaning that the chunk of log is corrupt.
1:      */
1:     private int retrieveInt() throws StandardException{
1:         if (SanityManager.DEBUG){
1:             SanityManager.ASSERT(logToScan.length >= currentPosition + 4,
1:                                  "Trying to read more bytes than there are " +
1:                                  "in this logToScan");
1:         }
1:         try {
1:             int i = ((logToScan[currentPosition++] << 24) 
1:                      + ((logToScan[currentPosition++] & 0xff) << 16) 
1:                      + ((logToScan[currentPosition++] & 0xff) << 8) 
1:                      + (logToScan[currentPosition++] & 0xff));
1:             return i;
1:         } catch (ArrayIndexOutOfBoundsException aioobe) {
1:             throw StandardException.
1:                 newException(SQLState.REPLICATION_LOG_CORRUPTED, aioobe);
1:         }
1:     }
1: 
1:     /**
1:      * Read a long from logToScan. Also increments currentPosition by
1:      * 8 (the number of bytes in a long).
1:      * @return a long read from logToScan
1:      * @throws StandardException if there are less then 8 bytes left
1:      * to read in logToScan, meaning that the chunk of log is corrupt.
1:      */
1:     private long retrieveLong() throws StandardException{
1:         if (SanityManager.DEBUG){
1:             SanityManager.ASSERT(logToScan.length >= currentPosition + 8,
1:                                  "Trying to read more bytes than there are " +
1:                                  "in this logToScan");
1:         }
1:         try {
1:             long l = ((((long)logToScan[currentPosition++]) << 56) 
1:                       + ((logToScan[currentPosition++] & 0xffL) << 48)
1:                       + ((logToScan[currentPosition++] & 0xffL) << 40)
1:                       + ((logToScan[currentPosition++] & 0xffL) << 32)
1:                       + ((logToScan[currentPosition++] & 0xffL) << 24)
1:                       + ((logToScan[currentPosition++] & 0xff) << 16)
1:                       + ((logToScan[currentPosition++] & 0xff) << 8)
1:                       + (logToScan[currentPosition++] & 0xff));
1:             return l;
1:         } catch (ArrayIndexOutOfBoundsException aioobe) {
1:             throw StandardException.
1:                 newException(SQLState.REPLICATION_LOG_CORRUPTED, aioobe);
1:         }
1:     }
1: 
1: }
============================================================================