1:b73c2a3: /*
1:ccce12c:  *
1:b73c2a3:  * Derby - Class org.apache.derbyTesting.functionTests.util.XML
1:ccce12c:  *
1:b73c2a3:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b73c2a3:  * contributor license agreements.  See the NOTICE file distributed with
1:b73c2a3:  * this work for additional information regarding copyright ownership.
1:b73c2a3:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b73c2a3:  * (the "License"); you may not use this file except in compliance with
1:b73c2a3:  * the License.  You may obtain a copy of the License at
2:f7abbf4:  *
1:b73c2a3:  *    http://www.apache.org/licenses/LICENSE-2.0
1:f7abbf4:  *
1:b73c2a3:  * Unless required by applicable law or agreed to in writing, 
1:b73c2a3:  * software distributed under the License is distributed on an 
1:b73c2a3:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:b73c2a3:  * either express or implied. See the License for the specific 
1:b73c2a3:  * language governing permissions and limitations under the License.
1:f7abbf4:  */
1:b73c2a3: package org.apache.derbyTesting.junit;
25:b73c2a3: 
1:cd4ba4a: import java.io.IOException;
1:cd4ba4a: import java.io.InputStreamReader;
1:f7abbf4: 
1:b73c2a3: import java.lang.reflect.Method;
1:cd4ba4a: import java.security.PrivilegedActionException;
1:cd4ba4a: 
1:cd4ba4a: import java.sql.Connection;
1:cd4ba4a: import java.sql.PreparedStatement;
1:cd4ba4a: import java.sql.SQLException;
1:b73c2a3: 
1:b73c2a3: import junit.framework.Assert;
1:b73c2a3: 
3:b73c2a3: /**
5:ccce12c:  * <p>
1:b73c2a3:  * XML utility methods for the JUnit tests.
5:ccce12c:  * </p>
1:f7abbf4:  */
1:b73c2a3: public class XML {
1:cd4ba4a: 
1:b73c2a3:     /**
1:b73c2a3:      * Determine whether or not the classpath with which we're
1:b73c2a3:      * running has the JAXP API classes required for use of
1:b73c2a3:      * the Derby XML operators.
1:f7abbf4:      */
1:b73c2a3:     private static final boolean HAVE_JAXP =
1:b73c2a3:         JDBC.haveClass("org.w3c.dom.Document");
1:cd4ba4a: 
1:b73c2a3:     /**
1:b73c2a3:      * Determine whether or not the classpath with which we're
1:5283796:      * running has a JAXP implementation.
1:cd4ba4a:      */
1:5283796:     private static final boolean HAVE_JAXP_IMPL =
1:5283796:             HAVE_JAXP && checkJAXPImplementation();
1:cd4ba4a: 
1:b73c2a3:     /**
1:1ffa77b:      * Determine if we have support evaluating XPath queries.
1:cd4ba4a:      */
1:1ffa77b:     private static final boolean HAVE_XPATH
1:5283796:             = HAVE_JAXP_IMPL && checkXPathSupport();
1:b73c2a3: 
1:b73c2a3:     /**
1:cd4ba4a:      * The filepath for the directory that holds the XML "helper" files
1:cd4ba4a:      * (i.e. the files to insert and their schema documents).
1:cd4ba4a:      */
1:cd4ba4a:     private static final String HELPER_FILE_LOCATION =
1:cd4ba4a:         "org/apache/derbyTesting/functionTests/tests/lang/xmlTestFiles/";
1:f7abbf4: 
1:f7abbf4:     /**
1:b73c2a3:      * Return true if the classpath contains JAXP and
1:5283796:      * an implementation of the JAXP interfaces, for example the
1:b73c2a3:      * Xalan classes (this method doesn't care about
1:1ffa77b:      * support for XPath queries).
14:b73c2a3:      */
1:5283796:     public static boolean classpathHasJAXP()
7:b73c2a3:     {
1:5283796:         return HAVE_JAXP_IMPL;
8:b73c2a3:     }
1:64e8bd3: 
1:f7abbf4:     /**
1:b73c2a3:      * Return true if the classpath meets all of the requirements
1:1ffa77b:      * for use of the SQL/XML operators.
1:64e8bd3:      */
1:b73c2a3:     public static boolean classpathMeetsXMLReqs()
1:f7abbf4:     {
1:1ffa77b:         return HAVE_XPATH;
1:b73c2a3:     }
1:f7abbf4: 
1:cd4ba4a:     /**
1:cd4ba4a:      * Insert the contents of a file into the received column of
1:cd4ba4a:      * the received table using "setCharacterStream".  Expectation
1:cd4ba4a:      * is that the file is in the directory indicated by 
1:cd4ba4a:      * HELPER_FILE_LOCATION.
1:ccce12c:      *
1:cd4ba4a:      * @param conn Connection on which to perform the insert.
1:cd4ba4a:      * @param tableName Table into which we want to insert.
1:cd4ba4a:      * @param colName Column in tableName into which we want to insert.
1:cd4ba4a:      * @param fName Name of the file whose content we want to insert.
1:cd4ba4a:      * @param numRows Number of times we should insert the received
1:cd4ba4a:      *  file's content.
1:64e8bd3:      */
1:cd4ba4a:     public static void insertFile(Connection conn, String tableName,
1:cd4ba4a:         String colName, String fName, int numRows)
1:cd4ba4a:         throws IOException, SQLException, PrivilegedActionException
1:cd4ba4a:     {
1:cd4ba4a:         // First we have to figure out many chars long the file is.
1:f7abbf4: 
1:cd4ba4a:         fName = HELPER_FILE_LOCATION + fName;
1:cd4ba4a:         java.net.URL xFile = BaseTestCase.getTestResource(fName);
1:cd4ba4a:         Assert.assertNotNull("XML input file missing: " + fName, xFile);
1:f7abbf4:         
1:cd4ba4a:         int charCount = 0;
1:cd4ba4a:         char [] cA = new char[1024];
1:cd4ba4a:         InputStreamReader reader =
1:cd4ba4a:             new InputStreamReader(BaseTestCase.openTestResource(xFile));
1:cd4ba4a: 
1:cd4ba4a:         for (int len = reader.read(cA, 0, cA.length); len != -1;
1:cd4ba4a:             charCount += len, len = reader.read(cA, 0, cA.length));
1:cd4ba4a: 
1:cd4ba4a:         reader.close();
1:cd4ba4a: 
1:cd4ba4a:         // Now that we know the number of characters, we can insert
1:cd4ba4a:         // using a stream.
1:cd4ba4a: 
1:cd4ba4a:         PreparedStatement pSt = conn.prepareStatement(
1:cd4ba4a:             "insert into " + tableName + "(" + colName + ") values " +
1:cd4ba4a:             "(xmlparse(document cast (? as clob) preserve whitespace))");
1:cd4ba4a: 
1:cd4ba4a:         for (int i = 0; i < numRows; i++)
1:cd4ba4a:         {
1:cd4ba4a:             reader = new InputStreamReader(
1:cd4ba4a:                 BaseTestCase.openTestResource(xFile));
1:cd4ba4a: 
1:cd4ba4a:             pSt.setCharacterStream(1, reader, charCount);
1:cd4ba4a:             pSt.execute();
1:cd4ba4a:             reader.close();
1:cd4ba4a:         }
1:cd4ba4a: 
1:cd4ba4a:         pSt.close();
1:cd4ba4a:     }
1:cd4ba4a: 
1:cd4ba4a:     /**
1:cd4ba4a:      * Insert an XML document into the received column of the received
1:cd4ba4a:      * test table using setString.  This method parallels "insertFiles"
1:cd4ba4a:      * above, except that it should be used for documents that require
1:cd4ba4a:      * a Document Type Definition (DTD).  In that case the location of
1:cd4ba4a:      * the DTD has to be modified _within_ the document so that it can
1:cd4ba4a:      * be found in the running user directory.
1:ccce12c:      *
1:cd4ba4a:      * Expectation is that the file to be inserted is in the directory
1:cd4ba4a:      * indicated by HELPER_FILE_LOCATION and that the DTD file has been
1:cd4ba4a:      * copied to the user's running directory (via use of the util
1:cd4ba4a:      * methods in SupportFilesSetup).
1:ccce12c:      *
1:cd4ba4a:      * @param conn Connection on which to perform the insert.
1:cd4ba4a:      * @param tableName Table into which we want to insert.
1:cd4ba4a:      * @param colName Column in tableName into which we want to insert.
1:cd4ba4a:      * @param fName Name of the file whose content we want to insert.
1:cd4ba4a:      * @param dtdName Name of the DTD file that the received file uses.
1:cd4ba4a:      * @param numRows Number of times we should insert the received
1:cd4ba4a:      *  file's content.
1:f7abbf4:      */
1:cd4ba4a:     public static void insertDocWithDTD(Connection conn, String tableName,
1:cd4ba4a:         String colName, String fName, String dtdName, int numRows)
1:cd4ba4a:         throws IOException, SQLException, PrivilegedActionException
1:cd4ba4a:     {
1:cd4ba4a:         // Read the file into memory so we can update it.
1:cd4ba4a:         fName = HELPER_FILE_LOCATION + fName;
1:cd4ba4a:         java.net.URL xFile = BaseTestCase.getTestResource(fName);
1:cd4ba4a:         Assert.assertNotNull("XML input file missing: " + fName, xFile);
1:cd4ba4a: 
1:cd4ba4a:         int charCount = 0;
1:cd4ba4a:         char [] cA = new char[1024];
1:cd4ba4a:         StringBuffer sBuf = new StringBuffer();
1:cd4ba4a:         InputStreamReader reader =
1:cd4ba4a:             new InputStreamReader(BaseTestCase.openTestResource(xFile));
1:cd4ba4a: 
1:cd4ba4a:         for (int len = reader.read(cA, 0, cA.length); len != -1;
1:cd4ba4a:             charCount += len, len = reader.read(cA, 0, cA.length))
1:cd4ba4a:         {
1:cd4ba4a:             sBuf.append(cA, 0, len);
1:cd4ba4a:         }
1:cd4ba4a: 
1:cd4ba4a:         reader.close();
1:cd4ba4a: 
1:cd4ba4a:         // Now replace the DTD location.
1:cd4ba4a: 
1:cd4ba4a:         java.net.URL dtdURL = SupportFilesSetup.getReadOnlyURL(dtdName);
1:cd4ba4a:         Assert.assertNotNull("DTD file missing: " + dtdName, dtdURL);
1:cd4ba4a: 
1:cd4ba4a:         String docAsString = sBuf.toString();
1:cd4ba4a:         int pos = docAsString.indexOf(dtdName);
1:cd4ba4a:         if (pos != -1)
1:cd4ba4a:             sBuf.replace(pos, pos+dtdName.length(), dtdURL.toExternalForm());
1:cd4ba4a: 
1:cd4ba4a:         // Now (finally) do the insert using the in-memory document with
1:cd4ba4a:         // the correct DTD location.
1:cd4ba4a:         docAsString = sBuf.toString();
1:cd4ba4a:         PreparedStatement pSt = conn.prepareStatement(
1:cd4ba4a:             "insert into " + tableName + "(" + colName + ") values " +
1:cd4ba4a:             "(xmlparse(document cast (? as clob) preserve whitespace))");
1:cd4ba4a: 
1:cd4ba4a:         for (int i = 0; i < numRows; i++)
1:cd4ba4a:         {
1:cd4ba4a:             pSt.setString(1, docAsString);
1:cd4ba4a:             pSt.execute();
1:cd4ba4a:         }
1:cd4ba4a: 
1:cd4ba4a:         pSt.close();
1:cd4ba4a:     }
1:cd4ba4a: 
1:cd4ba4a:     /**
1:5283796:      * <p>
1:b73c2a3:      * Determine whether or not the classpath with which we're
1:5283796:      * running contains a JAXP implementation that supports
1:1ffa77b:      * evaluating XPath queries.
1:5283796:      * </p>
1:ccce12c:      *
1:5283796:      * <p>
1:b73c2a3:      * Assumption is that we only get to this method if we already
1:5283796:      * know that there *is* an implementation of JAXP in the classpath.
1:5283796:      * </p>
1:f7abbf4:      */
1:5283796:     private static boolean checkXPathSupport()
1:b73c2a3:     {
1:f7abbf4:         try {
1:2510115:             Class<?> factoryClass =
1:1ffa77b:                     Class.forName("javax.xml.xpath.XPathFactory");
1:5283796: 
1:5283796:             Method newFactory =
1:1ffa77b:                     factoryClass.getMethod("newInstance");
1:f7abbf4: 
1:1ffa77b:             Object factory = newFactory.invoke(null);
1:f7abbf4: 
1:1ffa77b:             return factory != null;
1:f7abbf4: 
1:b73c2a3:         } catch (Throwable t) {
1:b73c2a3:             // If something went wrong, assume we don't have the
1:b73c2a3:             // necessary classes.
1:1ffa77b:             return false;
1:5283796:         }
1:f7abbf4:     }
1:5283796: 
1:5283796:     private static boolean checkJAXPImplementation() {
1:5283796:         try {
1:2510115:             Class<?> factoryClass =
2:5283796:                     Class.forName("javax.xml.parsers.DocumentBuilderFactory");
1:5283796:             Method newFactory =
2:5283796:                     factoryClass.getMethod("newInstance", new Class[0]);
2:5283796:             Object factory = newFactory.invoke(null, new Object[0]);
1:5283796:             return factory != null;
1:5283796:         } catch (Throwable t) {
1:5283796:             return false;
1:5283796:         }
1:b73c2a3:     }
1:64e8bd3: 
1:b73c2a3:     /**
1:f7abbf4:      * Return the string form of the URL for the jar file that contains
1:f7abbf4:      * whichever JAXP parser implementation is picked up from the user's
1:f7abbf4:      * classpath.  If the JAXP parser is not in the user's classpath,
1:f7abbf4:      * then it must be embedded within the JVM (either implicitly or else
1:f7abbf4:      * through use of "endorsed standards" jars), in which case we return
1:f7abbf4:      * null.
1:f7abbf4:      */
1:f7abbf4:     protected static String getJAXPParserLocation()
1:f7abbf4:     {
1:a6fa53b:         /* If the classpath does not have JAXP then we do not want to
1:a6fa53b:          * instantiate the JAXPFinder class (which happens indirectly
1:a6fa53b:          * if we call its static methods).  This is because JAXPFinder
1:a6fa53b:          * references a JAXP class that does not exist for J2ME, so
1:a6fa53b:          * if we try to call a method on JAXPFinder without a JAXP
1:a6fa53b:          * parser in the classpath, the result for J2ME would be
1:a6fa53b:          * be a NoClassDefFound error (DERBY-2153).
1:a6fa53b:          */
1:5283796:         if (!classpathHasJAXP())
1:a6fa53b:             return null;
1:eddb67d: 
1:eddb67d:         try {
1:2510115:             Class<?> jaxpFinderClass = Class.forName("org.apache.derbyTesting.junit.JAXPFinder");
1:2510115:             Method locatorMethod = jaxpFinderClass.getDeclaredMethod("getJAXPParserLocation");
1:f7abbf4: 
1:2510115:             return (String) locatorMethod.invoke(null);
1:eddb67d:         }
1:eddb67d:         catch (Exception e)
1:eddb67d:         {
1:eddb67d:             throw new UnsupportedOperationException( e.getClass().getName() + ": " + e.getMessage() );
1:eddb67d:         }
1:f7abbf4:     }
1:f7abbf4: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1ffa77b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Determine if we have support evaluating XPath queries.
1:     private static final boolean HAVE_XPATH
/////////////////////////////////////////////////////////////////////////
1:      * support for XPath queries).
/////////////////////////////////////////////////////////////////////////
1:      * for use of the SQL/XML operators.
1:         return HAVE_XPATH;
/////////////////////////////////////////////////////////////////////////
1:      * evaluating XPath queries.
/////////////////////////////////////////////////////////////////////////
1:                     Class.forName("javax.xml.xpath.XPathFactory");
1:                     factoryClass.getMethod("newInstance");
1:             Object factory = newFactory.invoke(null);
1:             return factory != null;
1:             return false;
commit:2510115
/////////////////////////////////////////////////////////////////////////
1:             Class<?> factoryClass =
/////////////////////////////////////////////////////////////////////////
0:             Class<?> builderClass =
/////////////////////////////////////////////////////////////////////////
0:             Class<?> domImplClass =
0:                     Class.forName("org.w3c.dom.DOMImplementation");
/////////////////////////////////////////////////////////////////////////
1:             Class<?> factoryClass =
/////////////////////////////////////////////////////////////////////////
1:             Class<?> jaxpFinderClass = Class.forName("org.apache.derbyTesting.junit.JAXPFinder");
1:             Method locatorMethod = jaxpFinderClass.getDeclaredMethod("getJAXPParserLocation");
1:             return (String) locatorMethod.invoke(null);
commit:5283796
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * running has a JAXP implementation.
1:     private static final boolean HAVE_JAXP_IMPL =
1:             HAVE_JAXP && checkJAXPImplementation();
0:      * Determine if we have support for DOM level 3 XPath, which is required
0:     private static final boolean HAVE_XPATH_LEVEL_3
1:             = HAVE_JAXP_IMPL && checkXPathSupport();
/////////////////////////////////////////////////////////////////////////
1:      * an implementation of the JAXP interfaces, for example the
0:      * support for DOM level 3 XPath).
1:     public static boolean classpathHasJAXP()
1:         return HAVE_JAXP_IMPL;
0:      * required classes exist in the classpath AND there is support
0:      * for DOM level 3 XPath.
0:         return HAVE_XPATH_LEVEL_3;
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * running contains a JAXP implementation that supports
0:      * DOM level 3 XPath.
1:      * </p>
1:      * <p>
1:      * know that there *is* an implementation of JAXP in the classpath.
1:      * </p>
1:     private static boolean checkXPathSupport()
0:         boolean supportsXPath;
1: 
0:         // Invoke the following using reflection to see if we have support
0:         // for DOM level 3 XPath:
0:         //
0:         //     DocumentBuilderFactory.newInstance().newDocumentBuilder()
0:         //             .getDOMImplementation().getFeature("+XPath", "3.0");
0:         //
0:             Class factoryClass =
1:                     Class.forName("javax.xml.parsers.DocumentBuilderFactory");
1:             Method newFactory =
1:                     factoryClass.getMethod("newInstance", new Class[0]);
1:             Object factory = newFactory.invoke(null, new Object[0]);
0:             Method newBuilder = factoryClass.getMethod(
0:                     "newDocumentBuilder", new Class[0]);
0:             Object builder = newBuilder.invoke(factory, new Object[0]);
0:             Class builderClass =
0:                     Class.forName("javax.xml.parsers.DocumentBuilder");
0:             Method getImpl = builderClass.getMethod(
0:                     "getDOMImplementation", new Class[0]);
0:             Object impl = getImpl.invoke(builder, new Object[0]);
0:             Class domImplClass = Class.forName("org.w3c.dom.DOMImplementation");
0:             Method getFeature = domImplClass.getMethod(
0:                     "getFeature", new Class[] {String.class, String.class});
0:             Object ret =
0:                     getFeature.invoke(impl, new Object[] {"+XPath", "3.0"});
0:             supportsXPath = (ret != null);
0:             supportsXPath = false;
0:         return supportsXPath;
1:     }
1: 
1:     private static boolean checkJAXPImplementation() {
1:         try {
0:             Class factoryClass =
1:                     Class.forName("javax.xml.parsers.DocumentBuilderFactory");
1:             Method newFactory =
1:                     factoryClass.getMethod("newInstance", new Class[0]);
1:             Object factory = newFactory.invoke(null, new Object[0]);
1:             return factory != null;
1:         } catch (Throwable t) {
1:             return false;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (!classpathHasJAXP())
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:eddb67d
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             Class   jaxpFinderClass = Class.forName( "org.apache.derbyTesting.junit.JAXPFinder" );
0:             Method  locatorMethod = jaxpFinderClass.getDeclaredMethod( "getJAXPParserLocation", null );
1: 
0:             return (String) locatorMethod.invoke(  null, null );
1:         }
1:         catch (Exception e)
1:         {
1:             throw new UnsupportedOperationException( e.getClass().getName() + ": " + e.getMessage() );
1:         }
commit:6a210c5
/////////////////////////////////////////////////////////////////////////
0:  * serializer.jar, xalan.jar, xercesImpl.jar, and xsltc.jar.</li>
commit:ccce12c
/////////////////////////////////////////////////////////////////////////
1:  * <p>
1:  * </p>
1:  *
1:  * <p>
0:  * Note that The XML tests require a more advanced version of Xalan
0:  * than the default version bundled with JDK 1.4. The XML tests silently
0:  * exit if the required environment is not found.
1:  * </p>
1:  *
1:  * <p>
0:  * To run the XML tests under JDK 1.4, you must do the following:
1:  * </p>
1:  *
0:  * <ul>
0:  * <li>Download the latest version of Xalan (2.7.0 as of this writing).</li>
0:  * <li>Copy all of the downloaded jars into the jre/lib/endorsed directory
0:  * of your JDK 1.4 installation. Those jar files are:
0:  * serializer.jar, xalan.jar, xercesImpl.jar, xml-apis.jar, and xsltc.jar.</li>
0:  * </ul>
1:  *
1:  * <p>
0:  *That's it! Now the XML tests should run for you under JDK 1.4.
1:  * </p>
1:  *
1:  * <p>
0:  * To run the XML tests under a higher version of the JDK, you must do the
0:  * following:
1:  * </p>
1:  *
0:  * <ul>
0:  * <li>Download the latest version of Xalan as described above.</li>
0:  * <li>Wire the downloaded jar files into your CLASSPATH.</li>
0:  * </ul>
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:41514af
/////////////////////////////////////////////////////////////////////////
commit:9c86d82
/////////////////////////////////////////////////////////////////////////
author:Army
-------------------------------------------------------------------------------
commit:64e8bd3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 /* We wrote the byte array using the platform's default
0:                  * encodinging (that's what we get with the call to
0:                  * "new PrintWriter(bos)" above), so read it in using
0:                  * the default encoding, as well (i.e. don't pass an
0:                  * encoding into toString()).
1:                  */
0:                 String checkEnvOutput = bos.toString();
0:                 /* The property we're looking for is on a single line
0:                  * of the output, and that line starts with the name
0:                  * of the property.  So extract that line out now. If
0:                  * we can't find it, just return "false" to say that
0:                  * we could not find the minimum version. Note: it's
0:                  * possible (though admittedly unlikely) that the
0:                  * string "version.xalan2_2" appears in the user's
0:                  * classpath.  Adding an equals sign ("=") at the end
0:                  * of our search pattern reduces the chance of the
0:                  * search string appearing in the classpath, but does
0:                  * not eliminate it...
1:                  */
0:                 int pos = checkEnvOutput.indexOf("version.xalan2_2=");
0:                 if (pos < 0)
0:                     return false;
1: 
0:                 String ver = checkEnvOutput.substring(
0:                     pos, checkEnvOutput.indexOf("\n", pos));
1: 
commit:a6fa53b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         /* If the classpath does not have JAXP then we do not want to
1:          * instantiate the JAXPFinder class (which happens indirectly
1:          * if we call its static methods).  This is because JAXPFinder
1:          * references a JAXP class that does not exist for J2ME, so
1:          * if we try to call a method on JAXPFinder without a JAXP
1:          * parser in the classpath, the result for J2ME would be
1:          * be a NoClassDefFound error (DERBY-2153).
1:          */
0:         if (!classpathHasXalanAndJAXP())
1:             return null;
0:         return JAXPFinder.getJAXPParserLocation();
commit:f7abbf4
/////////////////////////////////////////////////////////////////////////
0: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
0: /* The following import is for a JDBC 3.0 JAXP class, which means that
0:  * this file can only be built with 1.4 or later (see build.xml in
0:  * this directory).  This means that 1.3 JVMs will not be able to
0:  * instantiate this class--but since 1.3 is deprecated as of 10.3,
0:  * we do not worry about that here.
1:  */
0: import javax.xml.parsers.DocumentBuilderFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0:      * String form of the URL for the jar file in the user's classpath
0:      * that holds the JAXP implementation in use.  If the implementation
0:      * is embedded within, or endorsed by, the JVM, then we will set this
0:      * field to be an empty string.
1:      */
0:     private static String jaxpURLString = null;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return the string form of the URL for the jar file that contains
1:      * whichever JAXP parser implementation is picked up from the user's
1:      * classpath.  If the JAXP parser is not in the user's classpath,
1:      * then it must be embedded within the JVM (either implicitly or else
1:      * through use of "endorsed standards" jars), in which case we return
1:      * null.
1:      *
0:      * NOTE: Assumption is that we only get here if we know there is in
0:      * fact a JAXP parser available to the JVM.  I.e. if a call to
0:      * the "classpathMeetsXMLReqs()" method of this class will return 
0:      * true.
1:      */
1:     protected static String getJAXPParserLocation()
1:     {
0:         // Only get the URL if we have not already done it.
0:         if (jaxpURLString == null)
1:         {
1:             try {
1: 
0:                 /* Figure out which JAXP implementation we have by
0:                  * instantiating a DocumentBuilderFactory and then getting
0:                  * the implementation-specific class name for that object.
0:                  * Note that we cannot just use:
1:                  *
0:                  *  Class.forName("javax.xml.parsers.DocumentBuilderFactory")
1:                  *
0:                  * because the constructor for DocumentBuilderFactory (and
0:                  * for all JAXP abstract classes) is protected, which means
0:                  * Class.forName() cannot instantiate the object.  So we
0:                  * explicitly create the object using the JAXP method for
0:                  * doing so, and then we pass the object's implementation-
0:                  * specific class name to Class.forName() to get the
0:                  * appropriate Class.  The Class can then be used for
0:                  * retrieval of the URL.
1:                  */
0:                 URL jaxpURL = SecurityManagerSetup.getURL(Class.forName(
0:                     DocumentBuilderFactory.newInstance().getClass().getName()));
1: 
0:                 /* If we found a URL then the JAXP parser is in the classpath
0:                  * in some jar external to the JVM; in that case we have the
0:                  * the jar's location so we use/return that.  Otherwise we
0:                  * assume that the JAXP parser is either embedded within the
0:                  * JVM or else "endorsed" by it. In those cases we set our
0:                  * URL string to be the empty string, which is non-null and
0:                  * thus we will only execute this try-catch once.
1:                  */
0:                 jaxpURLString =
0:                     (jaxpURL == null) ? "" : jaxpURL.toExternalForm();
1: 
0:             } catch (Exception e) {
1: 
0:                 /* Probably a ClassNotFoundException.  We assume this
0:                  * means that there is no JAXP parser implementation
0:                  * in the classpath--but in that case we do not expect
0:                  * to get here.
1:                  */
0:                  Assert.fail("Failed to located JAXP parser.");
1: 
1:             }
1:         }
1: 
0:         // If we didn't find the JAXP parser URL, then return null.
0:         return ((jaxpURLString.length() == 0) ? null : jaxpURLString);
1:     }
commit:cd4ba4a
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.InputStreamReader;
1: import java.security.PrivilegedActionException;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * The filepath for the directory that holds the XML "helper" files
1:      * (i.e. the files to insert and their schema documents).
1:      */
1:     private static final String HELPER_FILE_LOCATION =
1:         "org/apache/derbyTesting/functionTests/tests/lang/xmlTestFiles/";
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Insert the contents of a file into the received column of
1:      * the received table using "setCharacterStream".  Expectation
1:      * is that the file is in the directory indicated by 
1:      * HELPER_FILE_LOCATION.
0:      *
1:      * @param conn Connection on which to perform the insert.
1:      * @param tableName Table into which we want to insert.
1:      * @param colName Column in tableName into which we want to insert.
1:      * @param fName Name of the file whose content we want to insert.
1:      * @param numRows Number of times we should insert the received
1:      *  file's content.
1:      */
1:     public static void insertFile(Connection conn, String tableName,
1:         String colName, String fName, int numRows)
1:         throws IOException, SQLException, PrivilegedActionException
1:     {
1:         // First we have to figure out many chars long the file is.
1: 
1:         fName = HELPER_FILE_LOCATION + fName;
1:         java.net.URL xFile = BaseTestCase.getTestResource(fName);
1:         Assert.assertNotNull("XML input file missing: " + fName, xFile);
1:         
1:         int charCount = 0;
1:         char [] cA = new char[1024];
1:         InputStreamReader reader =
1:             new InputStreamReader(BaseTestCase.openTestResource(xFile));
1: 
1:         for (int len = reader.read(cA, 0, cA.length); len != -1;
1:             charCount += len, len = reader.read(cA, 0, cA.length));
1: 
1:         reader.close();
1: 
1:         // Now that we know the number of characters, we can insert
1:         // using a stream.
1: 
1:         PreparedStatement pSt = conn.prepareStatement(
1:             "insert into " + tableName + "(" + colName + ") values " +
1:             "(xmlparse(document cast (? as clob) preserve whitespace))");
1: 
1:         for (int i = 0; i < numRows; i++)
1:         {
1:             reader = new InputStreamReader(
1:                 BaseTestCase.openTestResource(xFile));
1: 
1:             pSt.setCharacterStream(1, reader, charCount);
1:             pSt.execute();
1:             reader.close();
1:         }
1: 
1:         pSt.close();
1:     }
1: 
1:     /**
1:      * Insert an XML document into the received column of the received
1:      * test table using setString.  This method parallels "insertFiles"
1:      * above, except that it should be used for documents that require
1:      * a Document Type Definition (DTD).  In that case the location of
1:      * the DTD has to be modified _within_ the document so that it can
1:      * be found in the running user directory.
0:      *
1:      * Expectation is that the file to be inserted is in the directory
1:      * indicated by HELPER_FILE_LOCATION and that the DTD file has been
1:      * copied to the user's running directory (via use of the util
1:      * methods in SupportFilesSetup).
0:      *
1:      * @param conn Connection on which to perform the insert.
1:      * @param tableName Table into which we want to insert.
1:      * @param colName Column in tableName into which we want to insert.
1:      * @param fName Name of the file whose content we want to insert.
1:      * @param dtdName Name of the DTD file that the received file uses.
1:      * @param numRows Number of times we should insert the received
1:      *  file's content.
1:      */
1:     public static void insertDocWithDTD(Connection conn, String tableName,
1:         String colName, String fName, String dtdName, int numRows)
1:         throws IOException, SQLException, PrivilegedActionException
1:     {
1:         // Read the file into memory so we can update it.
1:         fName = HELPER_FILE_LOCATION + fName;
1:         java.net.URL xFile = BaseTestCase.getTestResource(fName);
1:         Assert.assertNotNull("XML input file missing: " + fName, xFile);
1: 
1:         int charCount = 0;
1:         char [] cA = new char[1024];
1:         StringBuffer sBuf = new StringBuffer();
1:         InputStreamReader reader =
1:             new InputStreamReader(BaseTestCase.openTestResource(xFile));
1: 
1:         for (int len = reader.read(cA, 0, cA.length); len != -1;
1:             charCount += len, len = reader.read(cA, 0, cA.length))
1:         {
1:             sBuf.append(cA, 0, len);
1:         }
1: 
1:         reader.close();
1: 
1:         // Now replace the DTD location.
1: 
1:         java.net.URL dtdURL = SupportFilesSetup.getReadOnlyURL(dtdName);
1:         Assert.assertNotNull("DTD file missing: " + dtdName, dtdURL);
1: 
1:         String docAsString = sBuf.toString();
1:         int pos = docAsString.indexOf(dtdName);
1:         if (pos != -1)
1:             sBuf.replace(pos, pos+dtdName.length(), dtdURL.toExternalForm());
1: 
1:         // Now (finally) do the insert using the in-memory document with
1:         // the correct DTD location.
1:         docAsString = sBuf.toString();
1:         PreparedStatement pSt = conn.prepareStatement(
1:             "insert into " + tableName + "(" + colName + ") values " +
1:             "(xmlparse(document cast (? as clob) preserve whitespace))");
1: 
1:         for (int i = 0; i < numRows; i++)
1:         {
1:             pSt.setString(1, docAsString);
1:             pSt.execute();
1:         }
1: 
1:         pSt.close();
1:     }
1: 
1:     /**
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b73c2a3
/////////////////////////////////////////////////////////////////////////
1: /*
0:  *
1:  * Derby - Class org.apache.derbyTesting.functionTests.util.XML
0:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.junit;
1: 
0: import java.io.PrintWriter;
0: import java.io.ByteArrayInputStream;
0: import java.io.ByteArrayOutputStream;
1: 
1: import java.lang.reflect.Method;
1: 
0: import java.util.StringTokenizer;
0: import java.util.Properties;
1: 
1: import junit.framework.Assert;
1: 
1: /**
1:  * XML utility methods for the JUnit tests.
0:  *
1:  */
1: public class XML {
1:     
1:     /**
0:      * Minimum version of Xalan required to run XML tests under
0:      * Security Manager. In this case, we're saying that the
0:      * minimum version is Xalan 2.5.0 (because there's a bug
0:      * in earlier versions that causes problems with security
0:      * manager).
1:      */
0:     private static int [] MIN_XALAN_VERSION = new int [] { 2, 5, 0 };
1: 
1:     /**
1:      * Determine whether or not the classpath with which we're
1:      * running has the JAXP API classes required for use of
1:      * the Derby XML operators.
1:      */
1:     private static final boolean HAVE_JAXP =
1:         JDBC.haveClass("org.w3c.dom.Document");
1: 
1:     /**
1:      * Determine whether or not the classpath with which we're
0:      * running has a version of Xalan in it.  Xalan is required
0:      * for use of the Derby XML operators.  In particular we
0:      * check for:
0:      *
0:      *  1. Xalan classes (version doesn't matter here)
0:      *  2. The Xalan "EnvironmentCheck" class, which is included
0:      *     as part of Xalan.  This allows us to check the specific
0:      *     version of Xalan in use so that we can determine if
0:      *     if we satisfy the minimum requirement.
1:      */
0:     private static final boolean HAVE_XALAN =
0:             JDBC.haveClass("org.apache.xpath.XPath") &&
0:             JDBC.haveClass("org.apache.xalan.xslt.EnvironmentCheck");
1: 
1:     /**
0:      * Determine if we have the minimum required version of Xalan
0:      * for successful use of the XML operators.
1:      */
0:     private static final boolean HAVE_MIN_XALAN
0:             = HAVE_XALAN && checkXalanVersion();
1: 
1:     /**
1:      * Return true if the classpath contains JAXP and
1:      * Xalan classes (this method doesn't care about
0:      * the particular version of Xalan).
1:      */
0:     public static boolean classpathHasXalanAndJAXP()
1:     {
0:         return HAVE_JAXP && HAVE_XALAN;
1:     }
1: 
1:     /**
1:      * Return true if the classpath meets all of the requirements
0:      * for use of the SQL/XML operators.  This means that all
0:      * required classes exist in the classpath AND the version
0:      * of Xalan that we found is at least MIN_XALAN_VERSION.
1:      */
1:     public static boolean classpathMeetsXMLReqs()
1:     {
0:         return HAVE_JAXP && HAVE_MIN_XALAN;
1:     }
1: 
1:     /**
1:      * Determine whether or not the classpath with which we're
0:      * running has a version of Xalan that meets the minimum
0:      * Xalan version requirement.  We do that by using a Java
0:      * utility that ships with Xalan--namely, "EnvironmentCheck"--
0:      * and by parsing the info gathered by that method to find
0:      * the Xalan version.  We use reflection when doing this
0:      * so that this file will compile/execute even if XML classes
0:      * are missing.
0:      *
1:      * Assumption is that we only get to this method if we already
0:      * know that there *is* a version of Xalan in the classpath
0:      * and that version includes the "EnvironmentCheck" class.
0:      *
0:      * Note that this method returns false if the call to Xalan's
0:      * EnvironmentCheck.checkEnvironment() returns false for any
0:      * reason.  As a specific example, that method will always
0:      * return false when running with ibm131 because it cannot
0:      * find the required methods on the SAX 2 classes (apparently
0:      * the classes in ibm131 jdk don't have all of the methods
0:      * required by Xalan).  Thus this method will always return
0:      * "false" for ibm131.
1:      */
0:     private static boolean checkXalanVersion()
1:     {
0:         boolean haveMinXalanVersion = false;
0:         try {
1: 
0:             // These io objects allow us to retrieve information generated
0:             // by the call to EnvironmenCheck.checkEnvironment()
0:             ByteArrayOutputStream bos = new ByteArrayOutputStream();
0:             PrintWriter pW = new PrintWriter(bos);
1: 
0:             // Call the method using reflection.
1: 
0:             Class cl = Class.forName("org.apache.xalan.xslt.EnvironmentCheck");
0:             Method meth = cl.getMethod("checkEnvironment",
0:                 new Class[] { PrintWriter.class });
1: 
0:             Boolean boolObj = (Boolean)meth.invoke(
0:                 cl.newInstance(), new Object [] { pW });
1: 
0:             pW.flush();
0:             bos.flush();
1: 
0:             cl = null;
0:             meth = null;
0:             pW = null;
1: 
0:             /* At this point 'bos' holds a list of properties with
0:              * a bunch of environment information.  The specific
0:              * property we're looking for is "version.xalan2_2",
0:              * so get that property, parse the value, and see
0:              * if the version is at least the minimum required.
1:              */
0:             if (boolObj.booleanValue())
1:             {
0:                 // Load the properties gathered from checkEnvironment().
0:                 Properties props = new Properties();
0:                 props.load(new ByteArrayInputStream(bos.toByteArray()));
0:                 bos.close();
1: 
0:                 // Now pull out the one we need.
0:                 String ver = props.getProperty("version.xalan2_2");
0:                 haveMinXalanVersion = (ver != null);
0:                 if (haveMinXalanVersion)
1:                 {
0:                     /* We found the property, so parse out the necessary
0:                      * piece.  The value is of the form:
0:                      *
0:                      *   <productName> Major.minor.x
0:                      *
0:                      * Ex:
0:                      *
0:                      *   version.xalan2_2=Xalan Java 2.5.1 
0:                      *   version.xalan2_2=XSLT4J Java 2.6.6
1:                      */
0:                     int i = 0;
0:                     StringTokenizer tok = new StringTokenizer(ver, ". ");
0:                     while (tok.hasMoreTokens())
1:                     {
0:                         String str = tok.nextToken().trim();
0:                         if (Character.isDigit(str.charAt(0)))
1:                         {
0:                             int val = Integer.valueOf(str).intValue();
0:                             if (val < MIN_XALAN_VERSION[i])
1:                             {
0:                                 haveMinXalanVersion = false;
0:                                 break;
1:                             }
0:                             i++;
1:                         }
1: 
0:                         /* If we've checked all parts of the min version,
0:                          * then we assume we're okay. Ex. "2.5.0.2"
0:                          * is considered greater than "2.5.0".
1:                          */
0:                         if (i >= MIN_XALAN_VERSION.length)
0:                             break;
1:                     }
1: 
0:                     /* If the value had fewer parts than the
0:                      * mininum version, then it doesn't meet
0:                      * the requirement.  Ex. "2.5" is considered
0:                      * to be a lower version than "2.5.0".
1:                      */
0:                     if (i < MIN_XALAN_VERSION.length)
0:                         haveMinXalanVersion = false;
1:                 }
1:             }
1: 
0:             /* Else the call to checkEnvironment() returned "false",
0:              * which means it couldn't find all of the classes/methods
0:              * required for Xalan to function.  So in that case we'll
0:              * fall through and just return false, as well.
1:              */
1: 
1:         } catch (Throwable t) {
1: 
0:             System.out.println("Unexpected exception while " +
0:                 "trying to find Xalan version:");
0:             t.printStackTrace(System.err);
1: 
1:             // If something went wrong, assume we don't have the
1:             // necessary classes.
0:             haveMinXalanVersion = false;
1: 
1:         }
1: 
0:         return haveMinXalanVersion;
1:     }
1: }
============================================================================