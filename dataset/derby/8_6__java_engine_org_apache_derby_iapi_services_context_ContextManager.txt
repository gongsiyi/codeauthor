2:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.context.ContextManager
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
25:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.context;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:eac0369: 
1:7132626: import org.apache.derby.iapi.error.ErrorStringBuilder;
1:eac0369: import org.apache.derby.iapi.error.PassThroughException;
1:4b58cc0: import org.apache.derby.shared.common.error.ShutdownException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:b175fd2: import org.apache.derby.iapi.error.ExceptionUtil;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.ExceptionSeverity;
1:eac0369: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1:4c5c16b: import org.apache.derby.iapi.services.info.JVMInfo;
1:eac0369: 
1:b175fd2: import java.sql.SQLException;
1:a50c94c: import java.util.HashMap;
1:a50c94c: import java.util.ArrayList;
1:a50c94c: import java.util.List;
1:a50c94c: import java.util.Collections;
1:eac0369: import java.util.Locale;
1:801cf0d: import org.apache.derby.iapi.reference.ContextId;
1:eac0369: 
3:eac0369: /**
1:eac0369:  *
1:eac0369:  * The ContextManager collects contexts as they are
1:eac0369:  * created. It maintains stacks of contexts by
1:eac0369:  * named ids, so that the top context of a given
1:eac0369:  * type can be returned. It also maintains a global
1:eac0369:  * stack so that contexts can be traversed in the
1:eac0369:  * order they were created.
1:eac0369:  * <p>
1:eac0369:  * The first implementation of the context manager
1:eac0369:  * assumes there is only one thread to worry about
1:eac0369:  * and that the user(s) of the class only create one
1:eac0369:  * instance of ContextManager.
1:eac0369:  */
1:eac0369: 
1:eac0369: public class ContextManager
5:eac0369: {
1:a50c94c: 	/**
1:a50c94c: 	 * The CtxStack implement a stack on top of an ArrayList (to avoid
1:a50c94c: 	 * the inherent overhead associated with java.util.Stack which is
1:a50c94c: 	 * built on top of java.util.Vector, which is fully
1:a50c94c: 	 * synchronized).
1:eac0369: 	 */
1:a50c94c: 	private static final class CtxStack {
1:b576d15: 		/** Internal list with all the elements of the stack. */
1:073b862: 		private final ArrayList<Context> stack_ = new ArrayList<Context>();
1:b576d15: 		/** Read-only view of the internal list. */
1:073b862: 		private final List<Context> view_ = Collections.unmodifiableList(stack_);
1:eac0369: 
1:a50c94c: 		// Keeping a reference to the top element on the stack
1:a50c94c: 		// optimizes the frequent accesses to this element. The
1:a50c94c: 		// tradeoff is that pushing and popping becomes more
1:a50c94c: 		// expensive, but those operations are infrequent.
1:a50c94c: 		private Context top_ = null;
1:a50c94c: 
1:a50c94c: 		void push(Context context) { 
1:a50c94c: 			stack_.add(context); 
1:a50c94c: 			top_ = context; 
1:a50c94c: 		}
1:a50c94c: 		void pop() {
1:a50c94c: 			stack_.remove(stack_.size()-1);
1:a50c94c: 			top_ = stack_.isEmpty() ? 
1:801cf0d:                 null : stack_.get(stack_.size()-1);
1:a50c94c: 		}
1:a50c94c: 		void remove(Context context) {
1:a50c94c: 			if (context == top_) {
1:a50c94c: 				pop();
1:a50c94c: 				return;
1:a50c94c: 			}
1:a50c94c: 			stack_.remove(stack_.lastIndexOf(context)); 
1:a50c94c: 		}
1:a50c94c: 		Context top() { 
1:a50c94c: 			return top_; 
1:a50c94c: 		}
1:a50c94c: 		boolean isEmpty() { return stack_.isEmpty(); }
1:801cf0d: 
1:801cf0d:         List<Context> getUnmodifiableList() {
1:b576d15: 			return view_;
1:a50c94c: 		}
1:a50c94c: 	}
1:4c5c16b: 
1:4c5c16b: 	/**
1:a50c94c: 	 * Empty ArrayList to use as void value
1:a50c94c: 	 */
1:a50c94c: 	//private final ArrayList voidArrayList_ = new ArrayList(0);
1:a50c94c: 
1:a50c94c: 	/**
1:a50c94c: 	 * HashMap that holds the Context objects. The Contexts are stored
1:a50c94c: 	 * with a String key.
1:a50c94c: 	 * @see ContextManager#pushContext(Context)
1:a50c94c: 	 */
1:073b862: 	private final HashMap<String,CtxStack> ctxTable = new HashMap<String,CtxStack>();
1:a50c94c: 
1:a50c94c: 	/**
1:a50c94c: 	 * List of all Contexts
1:a50c94c: 	 */
1:073b862: 	private final ArrayList<Context> holder = new ArrayList<Context>();
1:a50c94c: 
1:a50c94c: 	/**
1:a50c94c: 	 * Add a Context object to the ContextManager. The object is added
1:a50c94c: 	 * both to the holder list and to a stack for the specific type of
1:a50c94c: 	 * Context.
1:a50c94c: 	 * @param newContext the new Context object
1:a50c94c: 	 */
1:eac0369: 	public void pushContext(Context newContext)
1:eac0369: 	{
1:eac0369: 		checkInterrupt();
1:a50c94c: 		final String contextId = newContext.getIdName();
1:073b862: 		CtxStack idStack = ctxTable.get(contextId);
1:a50c94c: 
1:eac0369: 		// if the stack is null, create a new one.
1:a50c94c: 		if (idStack == null) {
1:a50c94c: 			idStack = new CtxStack();
1:a50c94c: 			ctxTable.put(contextId, idStack);
4:eac0369: 		}
1:eac0369: 
1:eac0369: 		// add to top of id's stack
1:eac0369: 		idStack.push(newContext);
1:eac0369: 
1:eac0369: 		// add to top of global stack too
1:a50c94c: 		holder.add(newContext);
1:eac0369: 	}
1:a50c94c: 	
1:a50c94c: 	/**
1:a50c94c: 	 * Obtain the last pushed Context object of the type indicated by
1:a50c94c: 	 * the contextId argument.
1:a50c94c: 	 * @param contextId a String identifying the type of Context
1:a50c94c: 	 * @return The Context object with the corresponding contextId, or null if not found
1:eac0369: 	 */
1:a50c94c: 	public Context getContext(String contextId) {
1:eac0369: 		checkInterrupt();
1:a50c94c: 		
1:073b862: 		final CtxStack idStack = ctxTable.get(contextId);
2:eac0369: 		if (SanityManager.DEBUG)
1:a50c94c: 			SanityManager.ASSERT( idStack == null ||
1:a50c94c: 								  idStack.isEmpty() ||
1:a50c94c: 								  idStack.top().getIdName() == contextId);
1:a50c94c: 		return (idStack==null?null:idStack.top());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:a50c94c: 	 * Remove the last pushed Context object, regardless of type. If
1:a50c94c: 	 * there are no Context objects, no action is taken.
1:eac0369: 	 */
1:eac0369: 	public void popContext()
1:eac0369: 	{
1:eac0369: 		checkInterrupt();
1:eac0369: 		// no contexts to remove, so we're done.
1:a50c94c: 		if (holder.isEmpty()) {
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// remove the top context from the global stack
1:073b862: 		Context theContext = holder.remove(holder.size()-1);
1:eac0369: 
1:eac0369: 		// now find its id and remove it from there, too
1:a50c94c: 		final String contextId = theContext.getIdName();
1:073b862: 		final CtxStack idStack = ctxTable.get(contextId);
1:eac0369: 
1:a50c94c: 		if (SanityManager.DEBUG) {
1:a50c94c: 			SanityManager.ASSERT( idStack != null &&
1:a50c94c: 								  (! idStack.isEmpty()) &&
1:a50c94c: 								  idStack.top().getIdName() == contextId);
1:a50c94c: 		}
1:eac0369: 		idStack.pop();
1:eac0369: 	}
1:eac0369: 
1:a50c94c: 	/**
1:a50c94c: 	 * Removes the specified Context object. If
1:a50c94c: 	 * the specified Context object does not exist, the call will fail.
1:a50c94c: 	 * @param theContext the Context object to remove.
1:a50c94c: 	 */
1:eac0369: 	void popContext(Context theContext)
1:eac0369: 	{
1:eac0369: 		checkInterrupt();
1:eac0369: 		if (SanityManager.DEBUG)
1:a50c94c: 			SanityManager.ASSERT(!holder.isEmpty());
1:eac0369: 
1:eac0369: 		// first, remove it from the global stack.
1:a50c94c: 		holder.remove(holder.lastIndexOf(theContext));
1:a50c94c: 
1:a50c94c: 		final String contextId = theContext.getIdName();
1:073b862: 		final CtxStack idStack = ctxTable.get(contextId);
1:eac0369: 
1:eac0369: 		// now remove it from its id's stack.
1:a50c94c: 		idStack.remove(theContext);
1:eac0369: 	}
1:7a8d023:     
1:7a8d023:     /**
1:7a8d023:      * Is the ContextManager empty containing no Contexts.
1:7a8d023:      */
1:7a8d023:     final boolean isEmpty()
1:7a8d023:     {
1:7a8d023:         return holder.isEmpty();
1:7a8d023:     }
1:a50c94c: 	
1:a50c94c: 	/**
1:a50c94c: 	 * Return an unmodifiable list reference to the ArrayList backing
1:a50c94c: 	 * CtxStack object for this type of Contexts. This method allows
1:a50c94c: 	 * fast traversal of all Contexts on that stack. The first element
1:a50c94c: 	 * in the List corresponds to the bottom of the stack. The
1:a50c94c: 	 * assumption is that the Stack will not be modified while it is
1:a50c94c: 	 * being traversed.
1:a50c94c: 	 * @param contextId the type of Context stack to return.
1:a50c94c: 	 * @return an unmodifiable "view" of the ArrayList backing the stack
1:a50c94c: 	 * @see org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext#resetSavepoints()
1:a50c94c: 	 * @see org.apache.derby.iapi.sql.conn.StatementContext#resetSavePoint()
1:a50c94c: 	 */
1:801cf0d:     public final List<Context> getContextStack(String contextId) {
1:073b862: 		final CtxStack cs = ctxTable.get(contextId);
1:2706d1f:         return cs == null ?
1:2706d1f:                Collections.<Context>emptyList() :
1:2706d1f:                cs.getUnmodifiableList();
1:a50c94c: 	}
1:a50c94c:     
1:eac0369:     /**
1:4c5c16b:      * clean up error and print it to derby.log. Extended diagnosis including
1:4c5c16b:      * thread dump to derby.log and javaDump if available, will print if the
1:4c5c16b:      * database is active and severity is greater than or equals to
1:4c5c16b:      * SESSTION_SEVERITY or as configured by
1:4c5c16b:      * derby.stream.error.extendedDiagSeverityLevel property
1:4c5c16b:      * 
1:4c5c16b:      * @param error the error we want to clean up
1:4c5c16b:      * @param diagActive
1:4c5c16b:      *        true if extended diagnostics should be considered, 
1:4c5c16b:      *        false not interested of extended diagnostic information
1:4c5c16b:      * @return true if the context manager is shutdown, false otherwise.
1:4c5c16b:      */
1:4c5c16b:     public boolean cleanupOnError(Throwable error, boolean diagActive)
1:eac0369: 	{
1:eac0369: 		if (shutdown)
1:eac0369: 			return true;
1:eac0369: 
1:eac0369: 		if (errorStringBuilder == null)
1:eac0369: 			errorStringBuilder = new ErrorStringBuilder(errorStream.getHeader());
1:eac0369: 
1:eac0369: 		ThreadDeath seenThreadDeath = null;
1:eac0369: 		if (error instanceof ThreadDeath)
1:eac0369: 			seenThreadDeath = (ThreadDeath) error;
1:eac0369: 
1:252f173:         if (error instanceof PassThroughException) {
1:252f173:             error = error.getCause();
1:252f173:         }
1:eac0369: 
1:eac0369: 		boolean reportError = reportError(error);
1:eac0369: 
1:eac0369: 		if (reportError) 
1:eac0369: 		{
1:eac0369: 			StringBuffer sb = null;
1:eac0369: 			if (! shutdown)
1:eac0369: 			{
1:eac0369: 				// report an id for the message if possible
1:801cf0d:                 ContextImpl lcc =
1:801cf0d:                         (ContextImpl)getContext(ContextId.LANG_CONNECTION);
1:eac0369: 				if (lcc != null) {
1:eac0369: 					sb = lcc.appendErrorInfo();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			String cleanup = "Cleanup action starting";
1:eac0369: 
1:eac0369: 			if (sb != null) {
1:eac0369: 				sb.append(cleanup);
1:eac0369: 				cleanup = sb.toString();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			errorStringBuilder.appendln(cleanup);
1:eac0369: 			
1:eac0369: 			if (!shutdown)		// Do this only during normal processing.
1:eac0369: 			{	
1:eac0369: 				ContextImpl sc = (ContextImpl) getContext(org.apache.derby.iapi.reference.ContextId.LANG_STATEMENT);
1:eac0369: 				// Output the SQL statement that failed in the log file.
1:eac0369: 				if (sc != null)
1:eac0369: 				{					
1:eac0369: 					sb = sc.appendErrorInfo();
1:eac0369: 					if (sb != null)
1:eac0369: 						errorStringBuilder.appendln(sb.toString());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		/*
1:eac0369: 		  REVISIT RESOLVE
1:eac0369: 		  Ensure that the traversal of the stack works in all 
1:eac0369: 		  cases where contexts can  pop themselves *and* 
1:eac0369: 		  contexts can pop other contexts off the stack.
1:eac0369: 		*/ 
1:eac0369: 		
1:eac0369: 
1:eac0369: forever: for (;;) {
1:eac0369: 
1:b175fd2:             int errorSeverity = getErrorSeverity(error);
1:eac0369:  			if (reportError) {
1:eac0369: 				errorStringBuilder.stackTrace(error);
1:eac0369: 				flushErrorString();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			
1:eac0369: 			boolean	lastHandler = false;
1:eac0369: 
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 				Walk down the stack, calling
1:eac0369: 				cleanup on each context. We use
1:eac0369: 				the vector interface to do this.
1:eac0369: 			 */
1:eac0369: cleanup:	for (int index = holder.size() - 1; index >= 0; index--) {
1:eac0369: 
1:eac0369: 				try {
1:eac0369: 					if (lastHandler)
1:eac0369: 					{
1:eac0369: 						break;
1:eac0369: 					}
1:eac0369: 
1:073b862: 					Context ctx = (holder.get(index));
1:eac0369: 					lastHandler = ctx.isLastHandler(errorSeverity);
1:eac0369: 
1:eac0369: 					ctx.cleanupOnError(error);
1:4c5c16b:                     //When errorSeverity greater or equals Property.EXT_DIAG_SEVERITY_LEVEL,
1:4c5c16b:                     //the threadDump information will be in derby.log and 
1:4c5c16b:                     //the diagnosis information will be prepared.
1:4c5c16b:                     //If Property.EXT_DIAG_SEVERITY_LEVEL is not set in JVM property or
1:4c5c16b:                     //derby property, we will only handle threadDump information and diagnosis
1:4c5c16b:                     //information for errorSeverity = ExceptionSeverity.SESSION_SEVERITY.
1:4c5c16b:                     if (reportError && diagActive
1:4c5c16b:                             && (errorSeverity >= extDiagSeverityLevel)) {
1:b175fd2:                         threadDump = ExceptionUtil.dumpThreads();
1:b175fd2:                     } else {
1:b175fd2:                         threadDump = null;
1:b175fd2:                     }
1:eac0369: 				}
1:eac0369: 				catch (StandardException se) {
1:eac0369: 	
1:eac0369: 					if (error instanceof StandardException) {
1:eac0369: 	
1:eac0369: 						if (se.getSeverity() > ((StandardException) error).getSeverity()) {
1:eac0369: 							// Ok, error handling raised a more severe error,
1:eac0369: 							// restart with the more severe error
1:eac0369: 							error = se;
1:eac0369: 							reportError = reportError(se);
1:eac0369: 							if (reportError) {
1:eac0369: 								errorStream.println("New exception raised during cleanup " + error.getMessage());
1:eac0369: 								errorStream.flush();
1:eac0369: 							}
1:eac0369: 							continue forever;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					if (reportError(se)) {
1:eac0369: 						errorStringBuilder.appendln("Less severe exception raised during cleanup (ignored) " + se.getMessage());
1:eac0369: 						errorStringBuilder.stackTrace(se);
1:eac0369: 						flushErrorString();
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					/*
1:eac0369: 						For a less severe error, keep with the last error
1:eac0369: 					 */
1:eac0369: 					continue cleanup;
1:eac0369: 				}
1:eac0369: 				catch (Throwable t) {
1:eac0369: 					reportError = reportError(t);
1:eac0369: 
1:eac0369: 
1:eac0369: 					if (error instanceof StandardException) {
1:eac0369: 						/*
1:eac0369: 							Ok, error handling raised a more severe error,
1:eac0369: 							restart with the more severe error
1:eac0369: 							A Throwable after a StandardException is always 
1:eac0369: 							more severe.
1:eac0369: 						 */
1:eac0369: 						error = t;
1:eac0369: 						if (reportError) {
1:eac0369: 							errorStream.println("New exception raised during cleanup " + error.getMessage());
1:eac0369: 							errorStream.flush();
1:eac0369: 						}
1:eac0369: 						continue forever;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 
1:eac0369: 					if (reportError) {
1:eac0369: 						errorStringBuilder.appendln("Equally severe exception raised during cleanup (ignored) " + t.getMessage());
1:eac0369: 						errorStringBuilder.stackTrace(t);
1:eac0369: 						flushErrorString();
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					if (t instanceof ThreadDeath) {
1:eac0369: 						if (seenThreadDeath != null)
1:eac0369: 							throw seenThreadDeath;
1:eac0369: 
1:eac0369: 						seenThreadDeath = (ThreadDeath) t;
1:eac0369: 					}
1:eac0369: 	
1:eac0369: 					/*
1:eac0369: 						For a less severe error, just continue with the last
1:eac0369: 						error
1:eac0369: 					 */
1:eac0369: 					continue cleanup;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:4c5c16b:             if (threadDump != null) {
1:b175fd2:                 errorStream.println(threadDump);
1:4c5c16b:                 JVMInfo.javaDump();
1:4c5c16b:             }
1:4c5c16b: 
1:eac0369: 			if (reportError) {
1:eac0369: 				errorStream.println("Cleanup action completed");
1:eac0369: 				errorStream.flush();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (seenThreadDeath != null)
1:eac0369: 				throw seenThreadDeath;
1:eac0369: 
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	synchronized boolean  setInterrupted(Context c) {
1:eac0369: 
1:eac0369: 		boolean interruptMe = (c == null) || holder.contains(c);
1:eac0369: 
1:eac0369: 		if (interruptMe) {
1:eac0369: 			this.shutdown = true;
1:eac0369: 		}
1:eac0369: 		return interruptMe;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Check to see if we have been interrupted. If we have then
1:eac0369: 		a ShutdownException will be thrown. This will be either the
1:eac0369: 		one passed to interrupt or a generic one if some outside
1:eac0369: 		source interrupted the thread.
1:eac0369: 	*/
1:eac0369: 	private void checkInterrupt() {
1:eac0369: 		if (shutdown) {
1:eac0369: 			// system must have changed underneath us
1:eac0369: 			throw new ShutdownException();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the locale for this context.
1:eac0369: 	*/
1:eac0369: 	public void setLocaleFinder(LocaleFinder finder) {
1:eac0369: 		this.finder = finder;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private Locale messageLocale;
1:eac0369: 
1:eac0369: 	public void setMessageLocale(String localeID) throws StandardException {
1:eac0369: 		this.messageLocale = Monitor.getLocaleFromString(localeID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Locale getMessageLocale()
1:eac0369: 	{
1:eac0369: 		if (messageLocale != null)
1:eac0369: 			return messageLocale;
1:eac0369: 		else if (finder != null) {
1:eac0369: 			try {
1:eac0369: 				return finder.getCurrentLocale();
1:eac0369: 			} catch (StandardException se) {
1:eac0369: 				
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return Locale.getDefault();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Flush the built up error string to whereever
1:eac0369: 	 * it is supposed to go, and reset the error string
1:eac0369: 	 */
1:eac0369: 	private void flushErrorString()
1:eac0369: 	{
1:eac0369: 		errorStream.print(errorStringBuilder.get().toString());
1:eac0369: 		errorStream.flush();
1:eac0369: 		errorStringBuilder.reset();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Class methods
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	private boolean reportError(Throwable t) {
1:eac0369: 
1:eac0369: 		if (t instanceof StandardException) {
1:eac0369: 
1:eac0369: 			StandardException se = (StandardException) t;
1:eac0369: 
1:eac0369: 			switch (se.report()) {
1:eac0369: 			case StandardException.REPORT_DEFAULT:
1:eac0369: 				int level = se.getSeverity();
1:eac0369: 				return (level >= logSeverityLevel) ||
1:eac0369: 					(level == ExceptionSeverity.NO_APPLICABLE_SEVERITY);
1:eac0369: 
1:eac0369: 			case StandardException.REPORT_NEVER:
1:eac0369: 				return false;
1:eac0369: 
1:eac0369: 			case StandardException.REPORT_ALWAYS:
1:eac0369: 			default:
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return !(t instanceof ShutdownException);
1:b175fd2: 
1:eac0369: 	}
1:eac0369:     
1:b175fd2:     /**
1:b175fd2:      * return the severity of the exception. Currently, this method 
1:b175fd2:      * does not determine a severity that is not StandardException 
1:b175fd2:      * or SQLException.
1:b175fd2:      * @param error - Throwable error
1:b175fd2:      * 
1:b175fd2:      * @return int vendorcode/severity for the Throwable error
1:b175fd2:      *            - error/exception to extract vendorcode/severity. 
1:b175fd2:      *            For error that we can not get severity, 
1:b175fd2:      *            NO_APPLICABLE_SEVERITY will return.
1:b175fd2:      */
1:b175fd2:     public int getErrorSeverity(Throwable error) {
1:b175fd2:         
1:b175fd2:         if (error instanceof StandardException) {
1:b175fd2:             return ((StandardException) error).getErrorCode();
1:b175fd2:         }
1:b175fd2:         
1:b175fd2:         if (error instanceof SQLException) {
1:b175fd2:             return ((SQLException) error).getErrorCode();
1:b175fd2:         }
1:b175fd2:         return ExceptionSeverity.NO_APPLICABLE_SEVERITY;
1:b175fd2:     }
1:eac0369: 
1:eac0369: 	/**
1:a50c94c: 	 * Constructs a new instance. No CtxStacks are inserted into the
1:a50c94c: 	 * hashMap as they will be allocated on demand.
1:a50c94c: 	 * @param csf the ContextService owning this ContextManager
1:a50c94c: 	 * @param stream error stream for reporting errors
1:eac0369: 	 */
1:eac0369: 	ContextManager(ContextService csf, HeaderPrintWriter stream)
1:eac0369: 	{
1:eac0369: 		errorStream = stream;
1:eac0369: 		owningCsf = csf;
1:eac0369: 
1:eac0369: 		logSeverityLevel = PropertyUtil.getSystemInt(Property.LOG_SEVERITY_LEVEL,
1:eac0369: 			SanityManager.DEBUG ? 0 : ExceptionSeverity.SESSION_SEVERITY);
1:4c5c16b:         extDiagSeverityLevel = PropertyUtil.getSystemInt(
1:4c5c16b:                 Property.EXT_DIAG_SEVERITY_LEVEL,
1:4c5c16b:                 ExceptionSeverity.SESSION_SEVERITY);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	final ContextService owningCsf;
1:eac0369: 
1:eac0369: 	private int		logSeverityLevel;
1:4c5c16b:     // DERBY-4856 track extendedDiagSeverityLevel variable
1:4c5c16b:     private int extDiagSeverityLevel;
1:eac0369: 
1:eac0369: 	private HeaderPrintWriter errorStream;
1:eac0369: 	private ErrorStringBuilder errorStringBuilder;
1:b175fd2:     // DERBY-4856 add thread dump information.
1:b175fd2:     private String threadDump;
1:eac0369: 
1:eac0369: 	private boolean shutdown;
1:eac0369: 	private LocaleFinder finder;
1:eac0369: 
1:874ccee:     /**
1:874ccee:      * The thread that owns this ContextManager, set by
1:874ccee:      * ContextService.setCurrentContextManager and reset
1:874ccee:      * by resetCurrentContextManager. Only a single
1:874ccee:      * thread can be active in a ContextManager at any time,
1:874ccee:      * and the thread only "owns" the ContextManager while
1:874ccee:      * it is executing code within Derby. In the JDBC case
1:874ccee:      * setCurrentContextManager is called at the start of
1:874ccee:      * a JBDC method and resetCurrentContextManager on completion.
1:874ccee:      * Nesting within the same thread is supported, such as server-side
1:874ccee:      * JDBC calls in a Java routine or procedure. In that case
1:874ccee:      * the activeCount will represent the level of nesting, in
1:874ccee:      * some situations.
1:874ccee:      * <BR>
1:874ccee: 
1:874ccee:      * @see ContextService#setCurrentContextManager(ContextManager)
1:874ccee:      * @see ContextService#resetCurrentContextManager(ContextManager)
1:874ccee:      * @see #activeCount
1:874ccee:      */
1:eac0369: 	Thread	activeThread;
1:874ccee:     
1:874ccee:     /**
1:874ccee:      * Count of the number of setCurrentContextManager calls
1:874ccee:      * by a single thread, for nesting situations with a single
1:874ccee:      * active Contextmanager. If nesting is occuring with multiple
1:874ccee:      * different ContextManagers then this value is set to -1
1:874ccee:      * and nesting is represented by entries in a stack in the
1:874ccee:      * ThreadLocal variable, threadContextList.
1:874ccee:      * 
1:874ccee:      * @see ContextService#threadContextList
1:874ccee:      */
1:eac0369: 	int		activeCount;
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:4b58cc0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.error.ShutdownException;
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
1:         return cs == null ?
1:                Collections.<Context>emptyList() :
1:                cs.getUnmodifiableList();
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.ContextId;
/////////////////////////////////////////////////////////////////////////
1:                 null : stack_.get(stack_.size()-1);
/////////////////////////////////////////////////////////////////////////
1: 
1:         List<Context> getUnmodifiableList() {
/////////////////////////////////////////////////////////////////////////
1:     public final List<Context> getContextStack(String contextId) {
0:         final List<Context> el = Collections.emptyList();
0:         return cs==null ? el : cs.getUnmodifiableList();
/////////////////////////////////////////////////////////////////////////
1:                 ContextImpl lcc =
1:                         (ContextImpl)getContext(ContextId.LANG_CONNECTION);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:073b862
/////////////////////////////////////////////////////////////////////////
1: 		private final ArrayList<Context> stack_ = new ArrayList<Context>();
1: 		private final List<Context> view_ = Collections.unmodifiableList(stack_);
/////////////////////////////////////////////////////////////////////////
1: 	private final HashMap<String,CtxStack> ctxTable = new HashMap<String,CtxStack>();
1: 	private final ArrayList<Context> holder = new ArrayList<Context>();
/////////////////////////////////////////////////////////////////////////
1: 		CtxStack idStack = ctxTable.get(contextId);
/////////////////////////////////////////////////////////////////////////
1: 		final CtxStack idStack = ctxTable.get(contextId);
/////////////////////////////////////////////////////////////////////////
1: 		Context theContext = holder.remove(holder.size()-1);
1: 		final CtxStack idStack = ctxTable.get(contextId);
/////////////////////////////////////////////////////////////////////////
1: 		final CtxStack idStack = ctxTable.get(contextId);
/////////////////////////////////////////////////////////////////////////
1: 		final CtxStack cs = ctxTable.get(contextId);
/////////////////////////////////////////////////////////////////////////
1: 					Context ctx = (holder.get(index));
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Lily Wei
-------------------------------------------------------------------------------
commit:4c5c16b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * clean up error and print it to derby.log. Extended diagnosis including
1:      * thread dump to derby.log and javaDump if available, will print if the
1:      * database is active and severity is greater than or equals to
1:      * SESSTION_SEVERITY or as configured by
1:      * derby.stream.error.extendedDiagSeverityLevel property
1:      * 
1:      * @param error the error we want to clean up
1:      * @param diagActive
1:      *        true if extended diagnostics should be considered, 
1:      *        false not interested of extended diagnostic information
1:      * @return true if the context manager is shutdown, false otherwise.
1:      */
1:     public boolean cleanupOnError(Throwable error, boolean diagActive)
/////////////////////////////////////////////////////////////////////////
1:                     //When errorSeverity greater or equals Property.EXT_DIAG_SEVERITY_LEVEL,
1:                     //the threadDump information will be in derby.log and 
1:                     //the diagnosis information will be prepared.
1:                     //If Property.EXT_DIAG_SEVERITY_LEVEL is not set in JVM property or
1:                     //derby property, we will only handle threadDump information and diagnosis
1:                     //information for errorSeverity = ExceptionSeverity.SESSION_SEVERITY.
1:                     if (reportError && diagActive
1:                             && (errorSeverity >= extDiagSeverityLevel)) {
/////////////////////////////////////////////////////////////////////////
1:             if (threadDump != null) {
1:                 JVMInfo.javaDump();
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         extDiagSeverityLevel = PropertyUtil.getSystemInt(
1:                 Property.EXT_DIAG_SEVERITY_LEVEL,
1:                 ExceptionSeverity.SESSION_SEVERITY);
1:     // DERBY-4856 track extendedDiagSeverityLevel variable
1:     private int extDiagSeverityLevel;
commit:b175fd2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.ExceptionUtil;
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:             int errorSeverity = getErrorSeverity(error);
/////////////////////////////////////////////////////////////////////////
0:                     if (reportError
0:                             && errorSeverity >= ExceptionSeverity.SESSION_SEVERITY) {
1:                         threadDump = ExceptionUtil.dumpThreads();
1:                     } else {
1:                         threadDump = null;
1:                     }
/////////////////////////////////////////////////////////////////////////
0:             if (threadDump != null)
1:                 errorStream.println(threadDump);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * return the severity of the exception. Currently, this method 
1:      * does not determine a severity that is not StandardException 
1:      * or SQLException.
1:      * @param error - Throwable error
1:      * 
1:      * @return int vendorcode/severity for the Throwable error
1:      *            - error/exception to extract vendorcode/severity. 
1:      *            For error that we can not get severity, 
1:      *            NO_APPLICABLE_SEVERITY will return.
1:      */
1:     public int getErrorSeverity(Throwable error) {
1:         
1:         if (error instanceof StandardException) {
1:             return ((StandardException) error).getErrorCode();
1:         }
1:         
1:         if (error instanceof SQLException) {
1:             return ((SQLException) error).getErrorCode();
1:         }
1:         return ExceptionSeverity.NO_APPLICABLE_SEVERITY;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     // DERBY-4856 add thread dump information.
1:     private String threadDump;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:252f173
/////////////////////////////////////////////////////////////////////////
1:         if (error instanceof PassThroughException) {
1:             error = error.getCause();
1:         }
commit:b576d15
/////////////////////////////////////////////////////////////////////////
1: 		/** Internal list with all the elements of the stack. */
0: 		private final ArrayList stack_ = new ArrayList();
1: 		/** Read-only view of the internal list. */
0: 		private final List view_ = Collections.unmodifiableList(stack_);
/////////////////////////////////////////////////////////////////////////
1: 			return view_;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7132626
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.ErrorStringBuilder;
0: import org.apache.derby.iapi.error.ShutdownException;
commit:7a8d023
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Is the ContextManager empty containing no Contexts.
1:      */
1:     final boolean isEmpty()
1:     {
1:         return holder.isEmpty();
1:     }
commit:874ccee
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The thread that owns this ContextManager, set by
1:      * ContextService.setCurrentContextManager and reset
1:      * by resetCurrentContextManager. Only a single
1:      * thread can be active in a ContextManager at any time,
1:      * and the thread only "owns" the ContextManager while
1:      * it is executing code within Derby. In the JDBC case
1:      * setCurrentContextManager is called at the start of
1:      * a JBDC method and resetCurrentContextManager on completion.
1:      * Nesting within the same thread is supported, such as server-side
1:      * JDBC calls in a Java routine or procedure. In that case
1:      * the activeCount will represent the level of nesting, in
1:      * some situations.
1:      * <BR>
1: 
1:      * @see ContextService#setCurrentContextManager(ContextManager)
1:      * @see ContextService#resetCurrentContextManager(ContextManager)
1:      * @see #activeCount
1:      */
1:     
1:     /**
1:      * Count of the number of setCurrentContextManager calls
1:      * by a single thread, for nesting situations with a single
1:      * active Contextmanager. If nesting is occuring with multiple
1:      * different ContextManagers then this value is set to -1
1:      * and nesting is represented by entries in a stack in the
1:      * ThreadLocal variable, threadContextList.
1:      * 
1:      * @see ContextService#threadContextList
1:      */
commit:a50c94c
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * The CtxStack implement a stack on top of an ArrayList (to avoid
1: 	 * the inherent overhead associated with java.util.Stack which is
1: 	 * built on top of java.util.Vector, which is fully
1: 	 * synchronized).
1: 	private static final class CtxStack {
0: 		private ArrayList stack_ = new ArrayList();
1: 		// Keeping a reference to the top element on the stack
1: 		// optimizes the frequent accesses to this element. The
1: 		// tradeoff is that pushing and popping becomes more
1: 		// expensive, but those operations are infrequent.
1: 		private Context top_ = null;
1: 
1: 		void push(Context context) { 
1: 			stack_.add(context); 
1: 			top_ = context; 
1: 		}
1: 		void pop() {
1: 			stack_.remove(stack_.size()-1);
1: 			top_ = stack_.isEmpty() ? 
0: 				null : (Context) stack_.get(stack_.size()-1); 
1: 		}
1: 		void remove(Context context) {
1: 			if (context == top_) {
1: 				pop();
1: 				return;
1: 			}
1: 			stack_.remove(stack_.lastIndexOf(context)); 
1: 		}
1: 		Context top() { 
1: 			return top_; 
1: 		}
1: 		boolean isEmpty() { return stack_.isEmpty(); }
0: 		List getUnmodifiableList() { 
0: 		    return Collections.unmodifiableList(stack_); 
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Empty ArrayList to use as void value
1: 	 */
1: 	//private final ArrayList voidArrayList_ = new ArrayList(0);
1: 
1: 	/**
1: 	 * HashMap that holds the Context objects. The Contexts are stored
1: 	 * with a String key.
1: 	 * @see ContextManager#pushContext(Context)
1: 	 */
0: 	private final HashMap ctxTable = new HashMap();
1: 
1: 	/**
1: 	 * List of all Contexts
1: 	 */
0: 	private final ArrayList holder = new ArrayList();
1: 
1: 	/**
1: 	 * Add a Context object to the ContextManager. The object is added
1: 	 * both to the holder list and to a stack for the specific type of
1: 	 * Context.
1: 	 * @param newContext the new Context object
1: 	 */
1: 		final String contextId = newContext.getIdName();
0: 		CtxStack idStack = (CtxStack) ctxTable.get(contextId);
1: 		if (idStack == null) {
1: 			idStack = new CtxStack();
1: 			ctxTable.put(contextId, idStack);
1: 		holder.add(newContext);
1: 	
1: 	 * Obtain the last pushed Context object of the type indicated by
1: 	 * the contextId argument.
1: 	 * @param contextId a String identifying the type of Context
1: 	 * @return The Context object with the corresponding contextId, or null if not found
1: 	public Context getContext(String contextId) {
1: 		
0: 		final CtxStack idStack = (CtxStack) ctxTable.get(contextId);
1: 			SanityManager.ASSERT( idStack == null ||
1: 								  idStack.isEmpty() ||
1: 								  idStack.top().getIdName() == contextId);
1: 		return (idStack==null?null:idStack.top());
1: 	 * Remove the last pushed Context object, regardless of type. If
1: 	 * there are no Context objects, no action is taken.
1: 		if (holder.isEmpty()) {
0: 		Context theContext = (Context) holder.remove(holder.size()-1);
1: 		final String contextId = theContext.getIdName();
0: 		final CtxStack idStack = (CtxStack) ctxTable.get(contextId);
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT( idStack != null &&
1: 								  (! idStack.isEmpty()) &&
1: 								  idStack.top().getIdName() == contextId);
1: 		}
1: 	/**
1: 	 * Removes the specified Context object. If
1: 	 * the specified Context object does not exist, the call will fail.
1: 	 * @param theContext the Context object to remove.
1: 	 */
1: 			SanityManager.ASSERT(!holder.isEmpty());
1: 		holder.remove(holder.lastIndexOf(theContext));
1: 
1: 		final String contextId = theContext.getIdName();
0: 		final CtxStack idStack = (CtxStack) ctxTable.get(contextId);
1: 		idStack.remove(theContext);
1: 	
1: 	/**
1: 	 * Return an unmodifiable list reference to the ArrayList backing
1: 	 * CtxStack object for this type of Contexts. This method allows
1: 	 * fast traversal of all Contexts on that stack. The first element
1: 	 * in the List corresponds to the bottom of the stack. The
1: 	 * assumption is that the Stack will not be modified while it is
1: 	 * being traversed.
1: 	 * @param contextId the type of Context stack to return.
1: 	 * @return an unmodifiable "view" of the ArrayList backing the stack
1: 	 * @see org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext#resetSavepoints()
1: 	 * @see org.apache.derby.iapi.sql.conn.StatementContext#resetSavePoint()
1: 	 */
0: 	public final List getContextStack(String contextId) {
0: 		final CtxStack cs = (CtxStack) ctxTable.get(contextId);
0: 		return (cs==null?Collections.EMPTY_LIST:cs.getUnmodifiableList());
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
0: 					Context ctx = ((Context) holder.get(index));
/////////////////////////////////////////////////////////////////////////
1: 	 * Constructs a new instance. No CtxStacks are inserted into the
1: 	 * hashMap as they will be allocated on demand.
1: 	 * @param csf the ContextService owning this ContextManager
1: 	 * @param stream error stream for reporting errors
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.context.ContextManager
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.context
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.context;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.PrintWriterGetHeader;
1: 
1: import org.apache.derby.iapi.error.PassThroughException;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: 
1: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: import java.io.PrintWriter;
1: 
0: import java.util.Hashtable;
0: import java.util.Stack;
0: import java.util.Vector;
1: import java.util.Locale;
1: 
1: /**
1:  *
1:  * The ContextManager collects contexts as they are
1:  * created. It maintains stacks of contexts by
1:  * named ids, so that the top context of a given
1:  * type can be returned. It also maintains a global
1:  * stack so that contexts can be traversed in the
1:  * order they were created.
1:  * <p>
1:  * The first implementation of the context manager
1:  * assumes there is only one thread to worry about
1:  * and that the user(s) of the class only create one
1:  * instance of ContextManager.
1:  */
1: 
1: public class ContextManager
1: 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 
0: 	private final Stack holder;
1: 
1: 	/*
0: 	 * ContextManager interface
1: 	 */
1: 
1: 	public void pushContext(Context newContext)
1: 	{
1: 		checkInterrupt();
1: 
0: 		String contextId = newContext.getIdName();
1: 
0: 		Stack idStack = (Stack) ctxTable.get(contextId);
1: 
1: 		// if the stack is null, create a new one.
0: 		if (idStack == null)
1: 		{
0: 			idStack = new Stack();
0: 			ctxTable.put(contextId,idStack);
1: 		}
1: 
1: 		// add to top of id's stack
1: 		idStack.push(newContext);
1: 
1: 		// add to top of global stack too
0: 		holder.push(newContext);
1: 	}
1: 
1: 	/**
0: 	 * @see org.apache.derby.iapi.services.context.ContextManager#getContext
1: 	 */
0: 	public Context getContext(String contextId)
1: 	{
1: 		checkInterrupt();
1: 
0: 		Stack idStack = (Stack)ctxTable.get(contextId);
1: 
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT( idStack == null ||
0: 			idStack.empty() ||
0: 			((Context)idStack.peek()).getIdName().equals(contextId));
1: 
0: 		if (idStack == null ||
0: 		    idStack.empty())
1: 		{
0: 			return null;
1: 		}
1: 
1: 
1: 
0: 		return (Context) idStack.peek();
1: 	}
1: 
1: 	/**
0: 	 * @see org.apache.derby.iapi.services.context.ContextManager#popContext
1: 	 */
1: 	public void popContext()
1: 	{
1: 		checkInterrupt();
1: 
0: 		Context theContext;
0: 		String contextId;
0: 		Stack idStack;
1: 
1: 		// no contexts to remove, so we're done.
0: 		if (holder.empty())
1: 		{
1: 			return;
1: 		}
1: 
1: 		// remove the top context from the global stack
0: 		theContext = (Context) holder.pop();
1: 
1: 		// now find its id and remove it from there, too
0: 		contextId = theContext.getIdName();
0: 		idStack = (Stack)ctxTable.get(contextId);
1: 
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT( idStack != null &&
0: 			(! idStack.empty()) &&
0: 			((Context)idStack.peek()).getIdName() == contextId);
1: 
1: 		idStack.pop();
1: 	}
1: 
1: 	void popContext(Context theContext)
1: 	{
1: 		checkInterrupt();
1: 
0: 		Stack idStack;
1: 
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(!holder.empty());
1: 
1: 		// first, remove it from the global stack.
0: 		// to do this we treat it like its vector supertype.
0: 		int index = holder.lastIndexOf(theContext);
0: 		if (index != -1)
0: 			holder.removeElementAt(index);
0: 		else if (SanityManager.DEBUG) {
0: 			//SanityManager.THROWASSERT("Popped non-existent context by id " + theContext + " type " + theContext.getIdName());
1: 		}
1: 
1: 		// now remove it from its id's stack.
0: 		idStack = (Stack) ctxTable.get(theContext.getIdName());
0: 		boolean wasThere = idStack.removeElement(theContext);
0: 		if (SanityManager.DEBUG) {
0: 			//if (!wasThere)
0: 			//	SanityManager.THROWASSERT("Popped non-existent stack by id " + theContext + " type " + theContext.getIdName());
1: 		}
1: 	}
1: 
1: 	/**
0: 		@return true if the context manager is shutdown, false otherwise.
1: 	 */
0: 	public boolean cleanupOnError(Throwable error)
1: 	{
1: 		if (shutdown)
1: 			return true;
1: 
1: 		if (errorStringBuilder == null)
1: 			errorStringBuilder = new ErrorStringBuilder(errorStream.getHeader());
1: 
1: 		ThreadDeath seenThreadDeath = null;
1: 		if (error instanceof ThreadDeath)
1: 			seenThreadDeath = (ThreadDeath) error;
1: 
0: 		if (error instanceof PassThroughException)
0: 			error = ((PassThroughException) error).getException();
1: 
1: 		boolean reportError = reportError(error);
1: 
1: 		if (reportError) 
1: 		{
0: 			ContextImpl lcc = null;
1: 			StringBuffer sb = null;
1: 			if (! shutdown)
1: 			{
1: 				// report an id for the message if possible
0: 				lcc = (ContextImpl) getContext(org.apache.derby.iapi.reference.ContextId.LANG_CONNECTION);
1: 				if (lcc != null) {
1: 					sb = lcc.appendErrorInfo();
1: 				}
1: 			}
1: 
1: 			String cleanup = "Cleanup action starting";
1: 
1: 			if (sb != null) {
1: 				sb.append(cleanup);
1: 				cleanup = sb.toString();
1: 			}
1: 
1: 			errorStringBuilder.appendln(cleanup);
1: 			
1: 			if (!shutdown)		// Do this only during normal processing.
1: 			{	
1: 				ContextImpl sc = (ContextImpl) getContext(org.apache.derby.iapi.reference.ContextId.LANG_STATEMENT);
1: 				// Output the SQL statement that failed in the log file.
1: 				if (sc != null)
1: 				{					
1: 					sb = sc.appendErrorInfo();
1: 					if (sb != null)
1: 						errorStringBuilder.appendln(sb.toString());
1: 				}
1: 			}
1: 		}
1: 		
1: 		/*
1: 		  REVISIT RESOLVE
1: 		  Ensure that the traversal of the stack works in all 
1: 		  cases where contexts can  pop themselves *and* 
1: 		  contexts can pop other contexts off the stack.
1: 		*/ 
1: 		
1: 
1: forever: for (;;) {
1: 
0: 			int errorSeverity = error instanceof StandardException ?
0: 				((StandardException) error).getSeverity() :
0: 				ExceptionSeverity.NO_APPLICABLE_SEVERITY;
1:  			if (reportError) {
1: 				errorStringBuilder.stackTrace(error);
1: 				flushErrorString();
1: 			}
1: 
1: 			
1: 			boolean	lastHandler = false;
1: 
1: 
1: 			/*
1: 				Walk down the stack, calling
1: 				cleanup on each context. We use
1: 				the vector interface to do this.
1: 			 */
1: cleanup:	for (int index = holder.size() - 1; index >= 0; index--) {
1: 
1: 				try {
1: 					if (lastHandler)
1: 					{
1: 						break;
1: 					}
1: 
0: 					Context ctx = ((Context) holder.elementAt(index));
1: 					lastHandler = ctx.isLastHandler(errorSeverity);
1: 
1: 					ctx.cleanupOnError(error);
1: 				}
1: 				catch (StandardException se) {
1: 	
1: 					if (error instanceof StandardException) {
1: 	
1: 						if (se.getSeverity() > ((StandardException) error).getSeverity()) {
1: 							// Ok, error handling raised a more severe error,
1: 							// restart with the more severe error
1: 							error = se;
1: 							reportError = reportError(se);
1: 							if (reportError) {
1: 								errorStream.println("New exception raised during cleanup " + error.getMessage());
1: 								errorStream.flush();
1: 							}
1: 							continue forever;
1: 						}
1: 					}
1: 
1: 					if (reportError(se)) {
1: 						errorStringBuilder.appendln("Less severe exception raised during cleanup (ignored) " + se.getMessage());
1: 						errorStringBuilder.stackTrace(se);
1: 						flushErrorString();
1: 					}
1: 
1: 					/*
1: 						For a less severe error, keep with the last error
1: 					 */
1: 					continue cleanup;
1: 				}
1: 				catch (Throwable t) {
1: 					reportError = reportError(t);
1: 
1: 
1: 					if (error instanceof StandardException) {
1: 						/*
1: 							Ok, error handling raised a more severe error,
1: 							restart with the more severe error
1: 							A Throwable after a StandardException is always 
1: 							more severe.
1: 						 */
1: 						error = t;
1: 						if (reportError) {
1: 							errorStream.println("New exception raised during cleanup " + error.getMessage());
1: 							errorStream.flush();
1: 						}
1: 						continue forever;
1: 					}
1: 
1: 
1: 					if (reportError) {
1: 						errorStringBuilder.appendln("Equally severe exception raised during cleanup (ignored) " + t.getMessage());
1: 						errorStringBuilder.stackTrace(t);
1: 						flushErrorString();
1: 					}
1: 
1: 					if (t instanceof ThreadDeath) {
1: 						if (seenThreadDeath != null)
1: 							throw seenThreadDeath;
1: 
1: 						seenThreadDeath = (ThreadDeath) t;
1: 					}
1: 	
1: 					/*
1: 						For a less severe error, just continue with the last
1: 						error
1: 					 */
1: 					continue cleanup;
1: 				}
1: 			}
1: 
1: 			if (reportError) {
1: 				errorStream.println("Cleanup action completed");
1: 				errorStream.flush();
1: 			}
1: 
1: 			if (seenThreadDeath != null)
1: 				throw seenThreadDeath;
1: 
1: 			return false;
1: 		}
1: 
1: 	}
1: 
1: 
1: 	synchronized boolean  setInterrupted(Context c) {
1: 
1: 		boolean interruptMe = (c == null) || holder.contains(c);
1: 
1: 		if (interruptMe) {
1: 			this.shutdown = true;
1: 		}
1: 		return interruptMe;
1: 	}
1: 
1: 	/**
1: 		Check to see if we have been interrupted. If we have then
1: 		a ShutdownException will be thrown. This will be either the
1: 		one passed to interrupt or a generic one if some outside
1: 		source interrupted the thread.
1: 	*/
1: 	private void checkInterrupt() {
1: 		if (shutdown) {
1: 			// system must have changed underneath us
1: 			throw new ShutdownException();
1: 		}
1: 	}
1: 
1: 	/**
1: 		Set the locale for this context.
1: 	*/
1: 	public void setLocaleFinder(LocaleFinder finder) {
1: 		this.finder = finder;
1: 	}
1: 
1: 	private Locale messageLocale;
1: 
1: 	public void setMessageLocale(String localeID) throws StandardException {
1: 		this.messageLocale = Monitor.getLocaleFromString(localeID);
1: 	}
1: 
1: 	public Locale getMessageLocale()
1: 	{
1: 		if (messageLocale != null)
1: 			return messageLocale;
1: 		else if (finder != null) {
1: 			try {
1: 				return finder.getCurrentLocale();
1: 			} catch (StandardException se) {
1: 				
1: 			}
1: 		}
1: 		return Locale.getDefault();
1: 	}
1: 
1: 	/**
1: 	 * Flush the built up error string to whereever
1: 	 * it is supposed to go, and reset the error string
1: 	 */
1: 	private void flushErrorString()
1: 	{
1: 		errorStream.print(errorStringBuilder.get().toString());
1: 		errorStream.flush();
1: 		errorStringBuilder.reset();
1: 	}
1: 
1: 	/*
1: 	** Class methods
1: 	*/
1: 
1: 	private boolean reportError(Throwable t) {
1: 
1: 		if (t instanceof StandardException) {
1: 
1: 			StandardException se = (StandardException) t;
1: 
1: 			switch (se.report()) {
1: 			case StandardException.REPORT_DEFAULT:
1: 				int level = se.getSeverity();
1: 				return (level >= logSeverityLevel) ||
1: 					(level == ExceptionSeverity.NO_APPLICABLE_SEVERITY);
1: 
1: 			case StandardException.REPORT_NEVER:
1: 				return false;
1: 
1: 			case StandardException.REPORT_ALWAYS:
1: 			default:
1: 				return true;
1: 			}
1: 		}
1: 
1: 		return !(t instanceof ShutdownException);
1: 
1: 	}
1: 
1: 	/**
0: 	 * constructor specifying the hash table size and load
0: 	 * factor for the hashed-by-id context stacks.
1: 	 */
1: 	ContextManager(ContextService csf, HeaderPrintWriter stream)
1: 	{
1: 		errorStream = stream;
0: 		ctxTable = new Hashtable();
1: 		owningCsf = csf;
1: 
1: 		logSeverityLevel = PropertyUtil.getSystemInt(Property.LOG_SEVERITY_LEVEL,
1: 			SanityManager.DEBUG ? 0 : ExceptionSeverity.SESSION_SEVERITY);
1: 
0: 		holder = new Stack();
1: 	}
1: 
0: 	private final Hashtable ctxTable;
1: 
1: 	final ContextService owningCsf;
1: 
1: 	private int		logSeverityLevel;
1: 
1: 	private HeaderPrintWriter errorStream;
1: 	private ErrorStringBuilder errorStringBuilder;
1: 
1: 	private boolean shutdown;
1: 	private LocaleFinder finder;
1: 
0: 	final Stack cmStack = new Stack();
1: 
1: 	Thread	activeThread;
1: 	int		activeCount;
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.context
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.context;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.PrintWriterGetHeader;
0: 
0: import org.apache.derby.iapi.error.PassThroughException;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: 
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: import java.io.PrintWriter;
0: 
0: import java.util.Hashtable;
0: import java.util.Stack;
0: import java.util.Vector;
0: import java.util.Locale;
0: 
0: /**
0:  *
0:  * The ContextManager collects contexts as they are
0:  * created. It maintains stacks of contexts by
0:  * named ids, so that the top context of a given
0:  * type can be returned. It also maintains a global
0:  * stack so that contexts can be traversed in the
0:  * order they were created.
0:  * <p>
0:  * The first implementation of the context manager
0:  * assumes there is only one thread to worry about
0:  * and that the user(s) of the class only create one
0:  * instance of ContextManager.
0:  */
0: 
0: public class ContextManager
0: 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 
0: 	private final Stack holder;
0: 
0: 	/*
0: 	 * ContextManager interface
0: 	 */
0: 
0: 	public void pushContext(Context newContext)
0: 	{
0: 		checkInterrupt();
0: 
0: 		String contextId = newContext.getIdName();
0: 
0: 		Stack idStack = (Stack) ctxTable.get(contextId);
0: 
0: 		// if the stack is null, create a new one.
0: 		if (idStack == null)
0: 		{
0: 			idStack = new Stack();
0: 			ctxTable.put(contextId,idStack);
0: 		}
0: 
0: 		// add to top of id's stack
0: 		idStack.push(newContext);
0: 
0: 		// add to top of global stack too
0: 		holder.push(newContext);
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.context.ContextManager#getContext
0: 	 */
0: 	public Context getContext(String contextId)
0: 	{
0: 		checkInterrupt();
0: 
0: 		Stack idStack = (Stack)ctxTable.get(contextId);
0: 
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT( idStack == null ||
0: 			idStack.empty() ||
0: 			((Context)idStack.peek()).getIdName().equals(contextId));
0: 
0: 		if (idStack == null ||
0: 		    idStack.empty())
0: 		{
0: 			return null;
0: 		}
0: 
0: 
0: 
0: 		return (Context) idStack.peek();
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.context.ContextManager#popContext
0: 	 */
0: 	public void popContext()
0: 	{
0: 		checkInterrupt();
0: 
0: 		Context theContext;
0: 		String contextId;
0: 		Stack idStack;
0: 
0: 		// no contexts to remove, so we're done.
0: 		if (holder.empty())
0: 		{
0: 			return;
0: 		}
0: 
0: 		// remove the top context from the global stack
0: 		theContext = (Context) holder.pop();
0: 
0: 		// now find its id and remove it from there, too
0: 		contextId = theContext.getIdName();
0: 		idStack = (Stack)ctxTable.get(contextId);
0: 
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT( idStack != null &&
0: 			(! idStack.empty()) &&
0: 			((Context)idStack.peek()).getIdName() == contextId);
0: 
0: 		idStack.pop();
0: 	}
0: 
0: 	void popContext(Context theContext)
0: 	{
0: 		checkInterrupt();
0: 
0: 		Stack idStack;
0: 
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(!holder.empty());
0: 
0: 		// first, remove it from the global stack.
0: 		// to do this we treat it like its vector supertype.
0: 		int index = holder.lastIndexOf(theContext);
0: 		if (index != -1)
0: 			holder.removeElementAt(index);
0: 		else if (SanityManager.DEBUG) {
0: 			//SanityManager.THROWASSERT("Popped non-existent context by id " + theContext + " type " + theContext.getIdName());
0: 		}
0: 
0: 		// now remove it from its id's stack.
0: 		idStack = (Stack) ctxTable.get(theContext.getIdName());
0: 		boolean wasThere = idStack.removeElement(theContext);
0: 		if (SanityManager.DEBUG) {
0: 			//if (!wasThere)
0: 			//	SanityManager.THROWASSERT("Popped non-existent stack by id " + theContext + " type " + theContext.getIdName());
0: 		}
0: 	}
0: 
0: 	/**
0: 		@return true if the context manager is shutdown, false otherwise.
0: 	 */
0: 	public boolean cleanupOnError(Throwable error)
0: 	{
0: 		if (shutdown)
0: 			return true;
0: 
0: 		if (errorStringBuilder == null)
0: 			errorStringBuilder = new ErrorStringBuilder(errorStream.getHeader());
0: 
0: 		ThreadDeath seenThreadDeath = null;
0: 		if (error instanceof ThreadDeath)
0: 			seenThreadDeath = (ThreadDeath) error;
0: 
0: 		if (error instanceof PassThroughException)
0: 			error = ((PassThroughException) error).getException();
0: 
0: 		boolean reportError = reportError(error);
0: 
0: 		if (reportError) 
0: 		{
0: 			ContextImpl lcc = null;
0: 			StringBuffer sb = null;
0: 			if (! shutdown)
0: 			{
0: 				// report an id for the message if possible
0: 				lcc = (ContextImpl) getContext(org.apache.derby.iapi.reference.ContextId.LANG_CONNECTION);
0: 				if (lcc != null) {
0: 					sb = lcc.appendErrorInfo();
0: 				}
0: 			}
0: 
0: 			String cleanup = "Cleanup action starting";
0: 
0: 			if (sb != null) {
0: 				sb.append(cleanup);
0: 				cleanup = sb.toString();
0: 			}
0: 
0: 			errorStringBuilder.appendln(cleanup);
0: 			
0: 			if (!shutdown)		// Do this only during normal processing.
0: 			{	
0: 				ContextImpl sc = (ContextImpl) getContext(org.apache.derby.iapi.reference.ContextId.LANG_STATEMENT);
0: 				// Output the SQL statement that failed in the log file.
0: 				if (sc != null)
0: 				{					
0: 					sb = sc.appendErrorInfo();
0: 					if (sb != null)
0: 						errorStringBuilder.appendln(sb.toString());
0: 				}
0: 			}
0: 		}
0: 		
0: 		/*
0: 		  REVISIT RESOLVE
0: 		  Ensure that the traversal of the stack works in all 
0: 		  cases where contexts can  pop themselves *and* 
0: 		  contexts can pop other contexts off the stack.
0: 		*/ 
0: 		
0: 
0: forever: for (;;) {
0: 
0: 			int errorSeverity = error instanceof StandardException ?
0: 				((StandardException) error).getSeverity() :
0: 				ExceptionSeverity.NO_APPLICABLE_SEVERITY;
0:  			if (reportError) {
0: 				errorStringBuilder.stackTrace(error);
0: 				flushErrorString();
0: 			}
0: 
0: 			
0: 			boolean	lastHandler = false;
0: 
0: 
0: 			/*
0: 				Walk down the stack, calling
0: 				cleanup on each context. We use
0: 				the vector interface to do this.
0: 			 */
0: cleanup:	for (int index = holder.size() - 1; index >= 0; index--) {
0: 
0: 				try {
0: 					if (lastHandler)
0: 					{
0: 						break;
0: 					}
0: 
0: 					Context ctx = ((Context) holder.elementAt(index));
0: 					lastHandler = ctx.isLastHandler(errorSeverity);
0: 
0: 					ctx.cleanupOnError(error);
0: 				}
0: 				catch (StandardException se) {
0: 	
0: 					if (error instanceof StandardException) {
0: 	
0: 						if (se.getSeverity() > ((StandardException) error).getSeverity()) {
0: 							// Ok, error handling raised a more severe error,
0: 							// restart with the more severe error
0: 							error = se;
0: 							reportError = reportError(se);
0: 							if (reportError) {
0: 								errorStream.println("New exception raised during cleanup " + error.getMessage());
0: 								errorStream.flush();
0: 							}
0: 							continue forever;
0: 						}
0: 					}
0: 
0: 					if (reportError(se)) {
0: 						errorStringBuilder.appendln("Less severe exception raised during cleanup (ignored) " + se.getMessage());
0: 						errorStringBuilder.stackTrace(se);
0: 						flushErrorString();
0: 					}
0: 
0: 					/*
0: 						For a less severe error, keep with the last error
0: 					 */
0: 					continue cleanup;
0: 				}
0: 				catch (Throwable t) {
0: 					reportError = reportError(t);
0: 
0: 
0: 					if (error instanceof StandardException) {
0: 						/*
0: 							Ok, error handling raised a more severe error,
0: 							restart with the more severe error
0: 							A Throwable after a StandardException is always 
0: 							more severe.
0: 						 */
0: 						error = t;
0: 						if (reportError) {
0: 							errorStream.println("New exception raised during cleanup " + error.getMessage());
0: 							errorStream.flush();
0: 						}
0: 						continue forever;
0: 					}
0: 
0: 
0: 					if (reportError) {
0: 						errorStringBuilder.appendln("Equally severe exception raised during cleanup (ignored) " + t.getMessage());
0: 						errorStringBuilder.stackTrace(t);
0: 						flushErrorString();
0: 					}
0: 
0: 					if (t instanceof ThreadDeath) {
0: 						if (seenThreadDeath != null)
0: 							throw seenThreadDeath;
0: 
0: 						seenThreadDeath = (ThreadDeath) t;
0: 					}
0: 	
0: 					/*
0: 						For a less severe error, just continue with the last
0: 						error
0: 					 */
0: 					continue cleanup;
0: 				}
0: 			}
0: 
0: 			if (reportError) {
0: 				errorStream.println("Cleanup action completed");
0: 				errorStream.flush();
0: 			}
0: 
0: 			if (seenThreadDeath != null)
0: 				throw seenThreadDeath;
0: 
0: 			return false;
0: 		}
0: 
0: 	}
0: 
0: 
0: 	synchronized boolean  setInterrupted(Context c) {
0: 
0: 		boolean interruptMe = (c == null) || holder.contains(c);
0: 
0: 		if (interruptMe) {
0: 			this.shutdown = true;
0: 		}
0: 		return interruptMe;
0: 	}
0: 
0: 	/**
0: 		Check to see if we have been interrupted. If we have then
0: 		a ShutdownException will be thrown. This will be either the
0: 		one passed to interrupt or a generic one if some outside
0: 		source interrupted the thread.
0: 	*/
0: 	private void checkInterrupt() {
0: 		if (shutdown) {
0: 			// system must have changed underneath us
0: 			throw new ShutdownException();
0: 		}
0: 	}
0: 
0: 	/**
0: 		Set the locale for this context.
0: 	*/
0: 	public void setLocaleFinder(LocaleFinder finder) {
0: 		this.finder = finder;
0: 	}
0: 
0: 	private Locale messageLocale;
0: 
0: 	public void setMessageLocale(String localeID) throws StandardException {
0: 		this.messageLocale = Monitor.getLocaleFromString(localeID);
0: 	}
0: 
0: 	public Locale getMessageLocale()
0: 	{
0: 		if (messageLocale != null)
0: 			return messageLocale;
0: 		else if (finder != null) {
0: 			try {
0: 				return finder.getCurrentLocale();
0: 			} catch (StandardException se) {
0: 				
0: 			}
0: 		}
0: 		return Locale.getDefault();
0: 	}
0: 
0: 	/**
0: 	 * Flush the built up error string to whereever
0: 	 * it is supposed to go, and reset the error string
0: 	 */
0: 	private void flushErrorString()
0: 	{
0: 		errorStream.print(errorStringBuilder.get().toString());
0: 		errorStream.flush();
0: 		errorStringBuilder.reset();
0: 	}
0: 
0: 	/*
0: 	** Class methods
0: 	*/
0: 
0: 	private boolean reportError(Throwable t) {
0: 
0: 		if (t instanceof StandardException) {
0: 
0: 			StandardException se = (StandardException) t;
0: 
0: 			switch (se.report()) {
0: 			case StandardException.REPORT_DEFAULT:
0: 				int level = se.getSeverity();
0: 				return (level >= logSeverityLevel) ||
0: 					(level == ExceptionSeverity.NO_APPLICABLE_SEVERITY);
0: 
0: 			case StandardException.REPORT_NEVER:
0: 				return false;
0: 
0: 			case StandardException.REPORT_ALWAYS:
0: 			default:
0: 				return true;
0: 			}
0: 		}
0: 
0: 		return !(t instanceof ShutdownException);
0: 
0: 	}
0: 
0: 	/**
0: 	 * constructor specifying the hash table size and load
0: 	 * factor for the hashed-by-id context stacks.
0: 	 */
0: 	ContextManager(ContextService csf, HeaderPrintWriter stream)
0: 	{
0: 		errorStream = stream;
0: 		ctxTable = new Hashtable();
0: 		owningCsf = csf;
0: 
0: 		logSeverityLevel = PropertyUtil.getSystemInt(Property.LOG_SEVERITY_LEVEL,
0: 			SanityManager.DEBUG ? 0 : ExceptionSeverity.SESSION_SEVERITY);
0: 
0: 		holder = new Stack();
0: 	}
0: 
0: 	private final Hashtable ctxTable;
0: 
0: 	final ContextService owningCsf;
0: 
0: 	private int		logSeverityLevel;
0: 
0: 	private HeaderPrintWriter errorStream;
0: 	private ErrorStringBuilder errorStringBuilder;
0: 
0: 	private boolean shutdown;
0: 	private LocaleFinder finder;
0: 
0: 	final Stack cmStack = new Stack();
0: 
0: 	Thread	activeThread;
0: 	int		activeCount;
0: }
============================================================================