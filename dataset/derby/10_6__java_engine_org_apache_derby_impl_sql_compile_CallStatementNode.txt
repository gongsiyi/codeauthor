2:eac0369: /*
32:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CallStatementNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:4fb136d: import java.lang.reflect.Modifier;
1:4fb136d: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:4fb136d: import org.apache.derby.iapi.reference.ClassName;
1:4fb136d: import org.apache.derby.iapi.reference.SQLState;
1:4fb136d: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:4fb136d: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:eac0369: import org.apache.derby.iapi.sql.compile.Visitor;
1:c45f5b1: import org.apache.derby.iapi.sql.conn.Authorizer;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: 
3:eac0369: /**
1:1bf5390:  * An CallStatementNode represents a CALL <procedure> statement.
1:1bf5390:  * It is the top node of the query tree for that statement.
1:1bf5390:  * A procedure call is very simple.
1:1bf5390:  * 
1:1bf5390:  * CALL [<schema>.]<procedure>(<args>)
1:1bf5390:  * 
1:1bf5390:  * <args> are either constants or parameter markers.
1:1bf5390:  * This implementation assumes that no subqueries or aggregates
1:1bf5390:  * can be in the argument list.
1:1bf5390:  * 
1:1bf5390:  * A procedure is always represented by a MethodCallNode.
5:eac0369:  *
1:eac0369:  */
1:3bb140c: class CallStatementNode extends DMLStatementNode
1:1bf5390: {	
1:1bf5390: 	/**
1:1bf5390: 	 * The method call for the Java procedure. Guaranteed to be
1:1bf5390: 	 * a JavaToSQLValueNode wrapping a MethodCallNode by checks
1:1bf5390: 	 * in the parser.
1:1bf5390: 	 */
1:1bf5390: 	private JavaToSQLValueNode	methodCall;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a CallStatementNode.
1:eac0369: 	 *
1:eac0369: 	 * @param methodCall		The expression to "call"
1:3bb140c:      * @param cm                The context manager
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     CallStatementNode(JavaToSQLValueNode methodCall, ContextManager cm)
8:eac0369: 	{
1:3bb140c:         super(null, cm);
1:3bb140c:         this.methodCall = methodCall;
1:1bf5390: 		this.methodCall.getJavaValueNode().markForCallStatement();
7:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:3bb140c:     String statementToString()
1:eac0369: 	{
1:eac0369: 		return "CALL";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
3:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (methodCall != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "methodCall: ");
1:eac0369: 				methodCall.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this UpdateNode.  This means looking up tables and columns and
1:eac0369: 	 * getting their types, and figuring out the result types of all
1:eac0369: 	 * expressions, as well as doing view resolution, permissions checking,
1:eac0369: 	 * etc.
1:eac0369: 	 * <p>
1:eac0369: 	 * Binding an update will also massage the tree so that
1:eac0369: 	 * the ResultSetNode has a single column, the RID.
1:eac0369: 	 *
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:1bf5390: 		DataDictionary dd = getDataDictionary();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT((dd != null), "Failed to get data dictionary");
1:4ce6a9b: 
1:3bb140c:         SubqueryList subqueries = new SubqueryList(getContextManager());
1:eac0369: 
1:c45f5b1: 		getCompilerContext().pushCurrentPrivType(getPrivType());
1:1bf5390: 		methodCall = (JavaToSQLValueNode) methodCall.bindExpression(
1:3bb140c:                             new FromList(
1:3bb140c:                                 getOptimizerFactory().doJoinOrderOptimization(),
3:eac0369: 								getContextManager()), 
1:4ce6a9b:                             subqueries,
1:1bf5390: 							null);
1:eac0369: 
1:4ce6a9b:         // Don't allow sub-queries in CALL statements.
1:4ce6a9b:         if (subqueries.size() != 0) {
1:4ce6a9b:             throw StandardException.newException(
1:4ce6a9b:                     SQLState.LANG_INVALID_CALL_STATEMENT);
1:4ce6a9b:         }
1:4ce6a9b: 
1:3b1291b: 		// Disallow creation of BEFORE triggers which contain calls to 
1:3b1291b: 		// procedures that modify SQL data. 
1:3b1291b:   		checkReliability();
1:3b1291b: 
1:c45f5b1: 		getCompilerContext().popCurrentPrivType();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Optimize a DML statement (which is the only type of statement that
1:eac0369: 	 * should need optimizing, I think). This method over-rides the one
1:eac0369: 	 * in QueryTreeNode.
1:eac0369: 	 *
1:eac0369: 	 * This method takes a bound tree, and returns an optimized tree.
1:eac0369: 	 * It annotates the bound tree rather than creating an entirely
1:eac0369: 	 * new tree.
1:eac0369: 	 *
1:eac0369: 	 * Throws an exception if the tree is not bound, or if the binding
1:eac0369: 	 * is out of date.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:d725d43: 	public void optimizeStatement() throws StandardException
1:eac0369: 	{
1:1bf5390: 		DataDictionary dd = getDataDictionary();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		SanityManager.ASSERT((dd != null), "Failed to get data dictionary");
1:eac0369: 
1:eac0369: 		/* Preprocess the method call tree */
1:3bb140c:         methodCall =
1:3bb140c:             (JavaToSQLValueNode) methodCall.preprocess(
1:3bb140c:                 getCompilerContext().getNumTables(),
1:3bb140c:                 new FromList(
1:3bb140c:                     getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                     getContextManager()),
1:3bb140c:                 (SubqueryList) null,
1:3bb140c:                 (PredicateList) null);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Code generation for CallStatementNode.
1:eac0369: 	 * The generated code will contain:
1:eac0369: 	 *		o  A generated void method for the user's method call.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method for the execute() method to be built
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
2:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		JavaValueNode		methodCallBody;
1:eac0369: 
1:eac0369: 		/* generate the parameters */
1:eac0369: 		generateParameterValueSet(acb);
1:eac0369: 
1:eac0369: 		/* 
1:eac0369: 		 * Skip over the JavaToSQLValueNode and call generate() for the JavaValueNode.
1:eac0369: 		 * (This skips over generated code which is unnecessary since we are throwing
1:eac0369: 		 * away any return value and which won't work with void methods.)
1:eac0369: 		 * generates:
1:eac0369: 		 *     <methodCall.generate(acb)>;
1:eac0369: 		 * and adds it to userExprFun
1:eac0369: 		 */
1:1bf5390: 		methodCallBody = methodCall.getJavaValueNode();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Tell the method call that its return value (if any) will be
1:eac0369: 		** discarded.  This is so it doesn't generate the ?: operator
1:eac0369: 		** that would return null if the receiver is null.  This is
1:eac0369: 		** important because the ?: operator cannot be made into a statement.
1:eac0369: 		*/
1:eac0369: 		methodCallBody.markReturnValueDiscarded();
1:eac0369: 
1:eac0369: 		// this sets up the method
1:eac0369: 		// generates:
1:1bf5390: 		// 	void userExprFun {
1:1bf5390: 		//     method_call(<args>);
1:1bf5390: 		//  }
1:1bf5390: 		//
1:1bf5390: 		//  An expression function is used to avoid reflection.
1:1bf5390: 		//  Since the arguments to a procedure are simple, this
1:1bf5390: 		// will be the only expression function and so it will
1:1bf5390: 		// be executed directly as e0.
1:eac0369: 		MethodBuilder userExprFun = acb.newGeneratedFun("void", Modifier.PUBLIC);
1:eac0369: 		userExprFun.addThrownException("java.lang.Exception");
1:eac0369: 		methodCallBody.generate(acb, userExprFun);
1:eac0369: 		userExprFun.endStatement();
1:eac0369: 		userExprFun.methodReturn();
1:eac0369: 		userExprFun.complete();
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 		acb.pushMethodReference(mb, userExprFun); // first arg
1:eac0369: 		acb.pushThisAsActivation(mb); // arg 2
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getCallStatementResultSet", ClassName.ResultSet, 2);
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:eac0369: 	public ResultDescription makeResultDescription()
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (methodCall != null)
1:eac0369: 		{
1:1bf5390: 			methodCall = (JavaToSQLValueNode) methodCall.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c45f5b1: 	 * Set default privilege of EXECUTE for this node. 
1:eac0369: 	 */
1:3bb140c:     @Override
1:c45f5b1: 	int getPrivType()
1:eac0369: 	{
1:c45f5b1: 		return Authorizer.EXECUTE_PRIV;
1:eac0369: 	}
1:3b1291b: 	
1:3b1291b: 	/**
1:3b1291b: 	 * This method checks if the called procedure allows modification of SQL 
1:3b1291b: 	 * data. If yes, it cannot be compiled if the reliability is 
1:3b1291b: 	 * <code>CompilerContext.MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL</code>. This 
1:3b1291b: 	 * reliability is set for BEFORE triggers in the create trigger node. This 
1:3b1291b: 	 * check thus disallows creation of BEFORE triggers which contain calls to 
1:3b1291b: 	 * procedures that modify SQL data in the trigger action statement.  
1:3b1291b: 	 * 
1:3b1291b: 	 * @throws StandardException
1:3b1291b: 	 */
1:3b1291b: 	private void checkReliability() throws StandardException {
1:3b1291b: 		if(getSQLAllowedInProcedure() == RoutineAliasInfo.MODIFIES_SQL_DATA &&
1:3b1291b: 				getCompilerContext().getReliability() == CompilerContext.MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL) 
1:3b1291b: 			throw StandardException.newException(SQLState.LANG_UNSUPPORTED_TRIGGER_PROC);
1:3b1291b: 	}
1:3b1291b: 	
1:3b1291b: 	/**
1:3b1291b: 	 * This method checks the SQL allowed by the called procedure. This method 
1:3b1291b: 	 * should be called only after the procedure has been resolved.
1:3b1291b: 	 * 
1:3b1291b: 	 * @return	SQL allowed by the procedure
1:3b1291b: 	 */
1:3b1291b: 	private short getSQLAllowedInProcedure() {
1:3b1291b: 		RoutineAliasInfo routineInfo = ((MethodCallNode)methodCall.getJavaValueNode()).routineInfo;
1:3b1291b: 		
1:3b1291b: 		// If this method is called before the routine has been resolved, routineInfo will be null 
1:3b1291b: 		if (SanityManager.DEBUG)
1:3b1291b: 			SanityManager.ASSERT((routineInfo != null), "Failed to get routineInfo");
1:3b1291b: 
1:3b1291b: 		return routineInfo.getSQLAllowed();
1:3b1291b: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
1: class CallStatementNode extends DMLStatementNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a CallStatementNode.
1:      * @param cm                The context manager
1:     CallStatementNode(JavaToSQLValueNode methodCall, ContextManager cm)
1:         super(null, cm);
0:         setNodeType(C_NodeTypes.CALL_STATEMENT_NODE);
1:         this.methodCall = methodCall;
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         SubqueryList subqueries = new SubqueryList(getContextManager());
1:                             new FromList(
1:                                 getOptimizerFactory().doJoinOrderOptimization(),
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         methodCall =
1:             (JavaToSQLValueNode) methodCall.preprocess(
1:                 getCompilerContext().getNumTables(),
1:                 new FromList(
1:                     getOptimizerFactory().doJoinOrderOptimization(),
1:                     getContextManager()),
1:                 (SubqueryList) null,
1:                 (PredicateList) null);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4ce6a9b
/////////////////////////////////////////////////////////////////////////
0:         SubqueryList subqueries = (SubqueryList) getNodeFactory().getNode(
0:                 C_NodeTypes.SUBQUERY_LIST, getContextManager());
1: 
1:                             subqueries,
1:         // Don't allow sub-queries in CALL statements.
1:         if (subqueries.size() != 0) {
1:             throw StandardException.newException(
1:                     SQLState.LANG_INVALID_CALL_STATEMENT);
1:         }
1: 
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (methodCall != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4fb136d
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Modifier;
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
commit:d725d43
/////////////////////////////////////////////////////////////////////////
1: 	public void optimizeStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:3b1291b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import org.apache.derby.iapi.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1: 		// Disallow creation of BEFORE triggers which contain calls to 
1: 		// procedures that modify SQL data. 
1:   		checkReliability();
1: 
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * This method checks if the called procedure allows modification of SQL 
1: 	 * data. If yes, it cannot be compiled if the reliability is 
1: 	 * <code>CompilerContext.MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL</code>. This 
1: 	 * reliability is set for BEFORE triggers in the create trigger node. This 
1: 	 * check thus disallows creation of BEFORE triggers which contain calls to 
1: 	 * procedures that modify SQL data in the trigger action statement.  
1: 	 * 
1: 	 * @throws StandardException
1: 	 */
1: 	private void checkReliability() throws StandardException {
1: 		if(getSQLAllowedInProcedure() == RoutineAliasInfo.MODIFIES_SQL_DATA &&
1: 				getCompilerContext().getReliability() == CompilerContext.MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL) 
1: 			throw StandardException.newException(SQLState.LANG_UNSUPPORTED_TRIGGER_PROC);
1: 	}
1: 	
1: 	/**
1: 	 * This method checks the SQL allowed by the called procedure. This method 
1: 	 * should be called only after the procedure has been resolved.
1: 	 * 
1: 	 * @return	SQL allowed by the procedure
1: 	 */
1: 	private short getSQLAllowedInProcedure() {
1: 		RoutineAliasInfo routineInfo = ((MethodCallNode)methodCall.getJavaValueNode()).routineInfo;
1: 		
1: 		// If this method is called before the routine has been resolved, routineInfo will be null 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT((routineInfo != null), "Failed to get routineInfo");
1: 
1: 		return routineInfo.getSQLAllowed();
1: 	}
commit:1bf5390
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2006 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
1:  * An CallStatementNode represents a CALL <procedure> statement.
1:  * It is the top node of the query tree for that statement.
1:  * A procedure call is very simple.
1:  * 
1:  * CALL [<schema>.]<procedure>(<args>)
1:  * 
1:  * <args> are either constants or parameter markers.
1:  * This implementation assumes that no subqueries or aggregates
1:  * can be in the argument list.
1:  * 
1:  * A procedure is always represented by a MethodCallNode.
1: {	
1: 	/**
1: 	 * The method call for the Java procedure. Guaranteed to be
1: 	 * a JavaToSQLValueNode wrapping a MethodCallNode by checks
1: 	 * in the parser.
1: 	 */
1: 	private JavaToSQLValueNode	methodCall;
0: 		this.methodCall = (JavaToSQLValueNode) methodCall;
1: 		this.methodCall.getJavaValueNode().markForCallStatement();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		DataDictionary dd = getDataDictionary();
1: 		methodCall = (JavaToSQLValueNode) methodCall.bindExpression(
0: 							null,
1: 							null);
/////////////////////////////////////////////////////////////////////////
1: 		DataDictionary dd = getDataDictionary();
0: 		methodCall = (JavaToSQLValueNode) methodCall.preprocess(
0: 								(SubqueryList) null,
0: 								(PredicateList) null);
/////////////////////////////////////////////////////////////////////////
1: 		methodCallBody = methodCall.getJavaValueNode();
/////////////////////////////////////////////////////////////////////////
1: 		// 	void userExprFun {
1: 		//     method_call(<args>);
1: 		//  }
1: 		//
1: 		//  An expression function is used to avoid reflection.
1: 		//  Since the arguments to a procedure are simple, this
1: 		// will be the only expression function and so it will
1: 		// be executed directly as e0.
/////////////////////////////////////////////////////////////////////////
0: 		if (!v.stopTraversal())
1: 			methodCall = (JavaToSQLValueNode) methodCall.accept(v);
commit:efce9b2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public void init(Object methodCall)
0: 		super.init(null);
/////////////////////////////////////////////////////////////////////////
0: 			return "CALL " + methodCall.toString() + "\n" +
/////////////////////////////////////////////////////////////////////////
commit:7736829
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CallStatementNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: 
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
1: 
0: import java.lang.reflect.Modifier;
1: 
0: import java.util.Vector;
1: 
1: /**
0:  * An CallStatementNode represents a CALL statement.  It is the top node of the
0:  * query tree for that statement. There are 2 flavors, class and object, of call
0:  * statements.  A class call statement is a static method call off of a class
0:  * expression (class classnameandpath), while an object call statement is a
0:  * method call off of an object expression.  The return value, if any,
0:  * from the underlying method call is ignored.
1:  *
0:  * @author Jerry Brenner
1:  */
0: public class CallStatementNode extends DMLStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private String		methodName;
0: 	private ValueNode	methodCall;
1: 
0: 	/* Need to track any subqueries under the methodCall */
0: 	private SubqueryList subqueries;
1: 
0: 	/* JRESOLVE?? Need to track any aggregates under the methodCall */
0: 	private Vector aggregateVector;
1: 
1: 	/**
0: 	 * Initializer for a CallStatementNode.
1: 	 *
0: 	 * @param methodName		The method name
1: 	 * @param methodCall		The expression to "call"
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(Object methodName, Object methodCall)
1: 		throws StandardException
1: 	{
0: 		init(null);
0: 		this.methodName = (String) methodName;
0: 		this.methodCall = (ValueNode) methodCall;
0: 		((JavaToSQLValueNode)methodCall).getJavaValueNode().markForCallStatement();
1: 	}
1: 
1: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
1: 	 *
0: 	 * @return	This object as a String
1: 	 */
1: 
0: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "methodName: " + methodName + "\n" +
0: 				super.toString();
1: 		}
0: 		else
1: 		{
0: 			return "";
1: 		}
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		return "CALL";
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (methodCall != null)
1: 			{
1: 				printLabel(depth, "methodCall: ");
1: 				methodCall.treePrint(depth + 1);
1: 			}
1: 
0: 			if (subqueries != null && subqueries.size() >= 1)
1: 			{
0: 				printLabel(depth, "subqueries: ");
0: 				subqueries.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this UpdateNode.  This means looking up tables and columns and
1: 	 * getting their types, and figuring out the result types of all
1: 	 * expressions, as well as doing view resolution, permissions checking,
1: 	 * etc.
1: 	 * <p>
1: 	 * Binding an update will also massage the tree so that
1: 	 * the ResultSetNode has a single column, the RID.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
0: 		DataDictionary				dd;
1: 
0: 		subqueries = (SubqueryList) getNodeFactory().getNode(
0: 											C_NodeTypes.SUBQUERY_LIST,
0: 											getContextManager());
0: 		aggregateVector = new Vector();
1: 
0: 		dd = getDataDictionary();
1: 
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT((dd != null), "Failed to get data dictionary");
1: 
0: 		methodCall = methodCall.bindExpression(
0: 							(FromList) getNodeFactory().getNode(
0: 								C_NodeTypes.FROM_LIST,
0: 								getNodeFactory().doJoinOrderOptimization(),
1: 								getContextManager()), 
0: 							subqueries,
0: 							aggregateVector);
1: 
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Optimize a DML statement (which is the only type of statement that
1: 	 * should need optimizing, I think). This method over-rides the one
1: 	 * in QueryTreeNode.
1: 	 *
1: 	 * This method takes a bound tree, and returns an optimized tree.
1: 	 * It annotates the bound tree rather than creating an entirely
1: 	 * new tree.
1: 	 *
1: 	 * Throws an exception if the tree is not bound, or if the binding
1: 	 * is out of date.
1: 	 *
0: 	 * @return	An optimized QueryTree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public QueryTreeNode optimize() throws StandardException
1: 	{
0: 		DataDictionary				dd;
1: 
0: 		dd = getDataDictionary();
1: 
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT((dd != null), "Failed to get data dictionary");
1: 
1: 		/* Preprocess the method call tree */
0: 		methodCall = methodCall.preprocess(
0: 								getCompilerContext().getNumTables(),
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
1: 									getContextManager()),
0: 								(SubqueryList) getNodeFactory().getNode(
0: 													C_NodeTypes.SUBQUERY_LIST,
1: 													getContextManager()),
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager()));
1: 
0: 		/* Optimize any subqueries in the method call tree */
0: 		if (subqueries.size() >= 1)
1: 		{
0: 			subqueries.optimize(dd, 1.0);
0: 			subqueries.modifyAccessPaths();
1: 		}
1: 
0: 		// JRESOLVE: no need to optimize aggregates, right?
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Code generation for CallStatementNode.
1: 	 * The generated code will contain:
1: 	 *		o  A generated void method for the user's method call.
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb	The method for the execute() method to be built
1: 	 *
0: 	 * @return		A compiled Expression returning a ResultSet for the call statement.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		JavaValueNode		methodCallBody;
1: 
1: 		/* generate the parameters */
1: 		generateParameterValueSet(acb);
1: 
1: 		/* 
1: 		 * Skip over the JavaToSQLValueNode and call generate() for the JavaValueNode.
1: 		 * (This skips over generated code which is unnecessary since we are throwing
1: 		 * away any return value and which won't work with void methods.)
1: 		 * generates:
1: 		 *     <methodCall.generate(acb)>;
1: 		 * and adds it to userExprFun
1: 		 */
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(methodCall instanceof JavaToSQLValueNode,
0: 					"methodCall is expected to be instanceof JavaToSQLValueNode");
0: 		methodCallBody = ((JavaToSQLValueNode)methodCall).getJavaValueNode();
1: 
1: 		/*
1: 		** Tell the method call that its return value (if any) will be
1: 		** discarded.  This is so it doesn't generate the ?: operator
1: 		** that would return null if the receiver is null.  This is
1: 		** important because the ?: operator cannot be made into a statement.
1: 		*/
1: 		methodCallBody.markReturnValueDiscarded();
1: 
1: 		// this sets up the method
1: 		// generates:
0: 		// 	void userExprFun { }
1: 		MethodBuilder userExprFun = acb.newGeneratedFun("void", Modifier.PUBLIC);
1: 		userExprFun.addThrownException("java.lang.Exception");
1: 		methodCallBody.generate(acb, userExprFun);
1: 		userExprFun.endStatement();
1: 		userExprFun.methodReturn();
1: 
0: 		// we are done modifying userExprFun, complete it.
1: 		userExprFun.complete();
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 		acb.pushMethodReference(mb, userExprFun); // first arg
1: 		acb.pushThisAsActivation(mb); // arg 2
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getCallStatementResultSet", ClassName.ResultSet, 2);
1: 
1: 		/*
0: 		** ensure all parameters have been generated
1: 		*/
0: 		generateParameterHolders(acb);
1: 	}
1: 
1: 	public ResultDescription makeResultDescription()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		if (v.skipChildren(this))
1: 		{
0: 			return v.visit(this);
1: 		}
1: 
0: 		Visitable returnNode = super.accept(v);
1: 
0: 		if (methodCall != null && !v.stopTraversal())
1: 		{
0: 			methodCall = (ValueNode)methodCall.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: 
0: 	/////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	ACCESSORS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	  *	Get the method call node.
1: 	  *
0: 	  *	@return	the method call node.
1: 	  */
0: 	public	MethodCallNode	getMethodCallNode()
1: 	{
0: 		JavaToSQLValueNode	jnode = (JavaToSQLValueNode) methodCall;
1: 
0: 		MethodCallNode		mnode = (MethodCallNode) jnode.getJavaValueNode();
1: 
0: 		return mnode;
1: 	}
1: }
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
0: 			SanityManager.ASSERT((dd != null), "Failed to get data dictionary");
1: 		getCompilerContext().pushCurrentPrivType(getPrivType());
/////////////////////////////////////////////////////////////////////////
1: 		getCompilerContext().popCurrentPrivType();
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Set default privilege of EXECUTE for this node. 
0: 	 */
1: 	int getPrivType()
0: 	{
1: 		return Authorizer.EXECUTE_PRIV;
0: 	}
0: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * An CallStatementNode represents a CALL statement.  It is the top node of the
0:  * query tree for that statement. There are 2 flavors, class and object, of call
0:  * statements.  A class call statement is a static method call off of a class
0:  * expression (class classnameandpath), while an object call statement is a
0:  * method call off of an object expression.  The return value, if any,
0:  * from the underlying method call is ignored.
0:  *
0:  * @author Jerry Brenner
0:  */
0: public class CallStatementNode extends DMLStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private String		methodName;
0: 	private ValueNode	methodCall;
0: 
0: 	/* Need to track any subqueries under the methodCall */
0: 	private SubqueryList subqueries;
0: 
0: 	/* JRESOLVE?? Need to track any aggregates under the methodCall */
0: 	private Vector aggregateVector;
0: 
0: 	/**
0: 	 * Initializer for a CallStatementNode.
0: 	 *
0: 	 * @param methodName		The method name
0: 	 * @param methodCall		The expression to "call"
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(Object methodName, Object methodCall)
0: 		throws StandardException
0: 	{
0: 		init(null);
0: 		this.methodName = (String) methodName;
0: 		this.methodCall = (ValueNode) methodCall;
0: 		((JavaToSQLValueNode)methodCall).getJavaValueNode().markForCallStatement();
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "methodName: " + methodName + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		return "CALL";
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (methodCall != null)
0: 			{
0: 				printLabel(depth, "methodCall: ");
0: 				methodCall.treePrint(depth + 1);
0: 			}
0: 
0: 			if (subqueries != null && subqueries.size() >= 1)
0: 			{
0: 				printLabel(depth, "subqueries: ");
0: 				subqueries.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this UpdateNode.  This means looking up tables and columns and
0: 	 * getting their types, and figuring out the result types of all
0: 	 * expressions, as well as doing view resolution, permissions checking,
0: 	 * etc.
0: 	 * <p>
0: 	 * Binding an update will also massage the tree so that
0: 	 * the ResultSetNode has a single column, the RID.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		DataDictionary				dd;
0: 
0: 		subqueries = (SubqueryList) getNodeFactory().getNode(
0: 											C_NodeTypes.SUBQUERY_LIST,
0: 											getContextManager());
0: 		aggregateVector = new Vector();
0: 
0: 		dd = getDataDictionary();
0: 
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT((dd != null), "Failed to get data dictionary");
0: 
0: 		methodCall = methodCall.bindExpression(
0: 							(FromList) getNodeFactory().getNode(
0: 								C_NodeTypes.FROM_LIST,
0: 								getNodeFactory().doJoinOrderOptimization(),
0: 								getContextManager()), 
0: 							subqueries,
0: 							aggregateVector);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Optimize a DML statement (which is the only type of statement that
0: 	 * should need optimizing, I think). This method over-rides the one
0: 	 * in QueryTreeNode.
0: 	 *
0: 	 * This method takes a bound tree, and returns an optimized tree.
0: 	 * It annotates the bound tree rather than creating an entirely
0: 	 * new tree.
0: 	 *
0: 	 * Throws an exception if the tree is not bound, or if the binding
0: 	 * is out of date.
0: 	 *
0: 	 * @return	An optimized QueryTree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public QueryTreeNode optimize() throws StandardException
0: 	{
0: 		DataDictionary				dd;
0: 
0: 		dd = getDataDictionary();
0: 
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT((dd != null), "Failed to get data dictionary");
0: 
0: 		/* Preprocess the method call tree */
0: 		methodCall = methodCall.preprocess(
0: 								getCompilerContext().getNumTables(),
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 								(SubqueryList) getNodeFactory().getNode(
0: 													C_NodeTypes.SUBQUERY_LIST,
0: 													getContextManager()),
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager()));
0: 
0: 		/* Optimize any subqueries in the method call tree */
0: 		if (subqueries.size() >= 1)
0: 		{
0: 			subqueries.optimize(dd, 1.0);
0: 			subqueries.modifyAccessPaths();
0: 		}
0: 
0: 		// JRESOLVE: no need to optimize aggregates, right?
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Code generation for CallStatementNode.
0: 	 * The generated code will contain:
0: 	 *		o  A generated void method for the user's method call.
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb	The method for the execute() method to be built
0: 	 *
0: 	 * @return		A compiled Expression returning a ResultSet for the call statement.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		JavaValueNode		methodCallBody;
0: 
0: 		/* generate the parameters */
0: 		generateParameterValueSet(acb);
0: 
0: 		/* 
0: 		 * Skip over the JavaToSQLValueNode and call generate() for the JavaValueNode.
0: 		 * (This skips over generated code which is unnecessary since we are throwing
0: 		 * away any return value and which won't work with void methods.)
0: 		 * generates:
0: 		 *     <methodCall.generate(acb)>;
0: 		 * and adds it to userExprFun
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(methodCall instanceof JavaToSQLValueNode,
0: 					"methodCall is expected to be instanceof JavaToSQLValueNode");
0: 		methodCallBody = ((JavaToSQLValueNode)methodCall).getJavaValueNode();
0: 
0: 		/*
0: 		** Tell the method call that its return value (if any) will be
0: 		** discarded.  This is so it doesn't generate the ?: operator
0: 		** that would return null if the receiver is null.  This is
0: 		** important because the ?: operator cannot be made into a statement.
0: 		*/
0: 		methodCallBody.markReturnValueDiscarded();
0: 
0: 		// this sets up the method
0: 		// generates:
0: 		// 	void userExprFun { }
0: 		MethodBuilder userExprFun = acb.newGeneratedFun("void", Modifier.PUBLIC);
0: 		userExprFun.addThrownException("java.lang.Exception");
0: 		methodCallBody.generate(acb, userExprFun);
0: 		userExprFun.endStatement();
0: 		userExprFun.methodReturn();
0: 
0: 		// we are done modifying userExprFun, complete it.
0: 		userExprFun.complete();
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 		acb.pushMethodReference(mb, userExprFun); // first arg
0: 		acb.pushThisAsActivation(mb); // arg 2
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getCallStatementResultSet", ClassName.ResultSet, 2);
0: 
0: 		/*
0: 		** ensure all parameters have been generated
0: 		*/
0: 		generateParameterHolders(acb);
0: 	}
0: 
0: 	public ResultDescription makeResultDescription()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		if (v.skipChildren(this))
0: 		{
0: 			return v.visit(this);
0: 		}
0: 
0: 		Visitable returnNode = super.accept(v);
0: 
0: 		if (methodCall != null && !v.stopTraversal())
0: 		{
0: 			methodCall = (ValueNode)methodCall.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	ACCESSORS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	Get the method call node.
0: 	  *
0: 	  *	@return	the method call node.
0: 	  */
0: 	public	MethodCallNode	getMethodCallNode()
0: 	{
0: 		JavaToSQLValueNode	jnode = (JavaToSQLValueNode) methodCall;
0: 
0: 		MethodCallNode		mnode = (MethodCallNode) jnode.getJavaValueNode();
0: 
0: 		return mnode;
0: 	}
0: }
0: 
============================================================================