1:eac0369: /*
1:faf2134: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.Database
1:faf2134: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
1:d7258ed: 
1:faf2134:  */
1:d7258ed: 
1:eac0369: package org.apache.derby.impl.drda;
41:eac0369: 
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.util.Enumeration;
1:db4c995: import java.util.Hashtable;
1:4383496: import java.util.Properties;
1:faf2134: import org.apache.derby.iapi.jdbc.EngineConnection;
1:4383496: import org.apache.derby.iapi.reference.Attribute;
1:eac0369: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1:7233e33: 
1:25dfe8c: /**
1:4f996a4:     Database stores information about the current database
1:4f996a4:     It is used so that a session may have more than one database
1:4383496: */
1:eac0369: class Database
3:4383496: {
1:df2ca5a:     /*
1:df2ca5a:      * Considering that we are now doing some fiddling with the db name
1:df2ca5a:      * it is probably wise to keep dbName and shortDbName private and have 
1:df2ca5a:      * accessors for them.
1:df2ca5a:      */
1:db9a013:     private String dbName;          // database name
1:4f996a4:     private String shortDbName;       // database name without attributes
1:4f996a4:     String attrString="";               // attribute string
1:4f996a4:     protected int securityMechanism;    // Security mechanism
1:4f996a4:     protected String userId;            // User Id
1:db9a013:     protected String password;          // password
1:db9a013:     protected String decryptedUserId;   // Decrypted User id
1:db9a013:     protected String decryptedPassword; // Decrypted password
1:7233e33:     protected byte[] passwordSubstitute;// password substitute - SECMEC_USRSSBPWD
1:db9a013:     protected boolean rdbAllowUpdates = true; // Database allows updates -default is true
1:db9a013:     protected int   accessCount;        // Number of times we have tried to
1:4f996a4:                                         // set up access to this database (only 1 
1:4f996a4:                                         // allowed)
1:4f996a4:     protected byte[] secTokenIn;        // Security token from app requester
1:db9a013:     protected byte[] secTokenOut;       // Security token sent to app requester
1:4f996a4:     protected byte[] crrtkn;            // Correlation token
1:db9a013:     protected String typDefNam;         // Type definition name
1:4f996a4:     protected int byteOrder;            //deduced from typDefNam, save String comparisons
1:db9a013:     protected int ccsidSBC;             // Single byte CCSID
1:db9a013:     protected int ccsidDBC;             // Double byte CCSID
1:db9a013:     protected int ccsidMBC;             // Mixed byte CCSID
1:db9a013:     protected String ccsidSBCEncoding;  // Encoding for single byte code page
1:db9a013:     protected String ccsidDBCEncoding;  // Encoding for double byte code page
1:db9a013:     protected String ccsidMBCEncoding;  // Encoding for mixed byte code page
1:4f996a4:     protected boolean RDBUPDRM_sent = false;    //We have sent that an update
1:4f996a4:                                             // occurred in this transaction
1:4f996a4:     protected boolean sendTRGDFTRT = false; // Send package target default value
1:3f89d24:     /**
1:faf2134:      * Connection to the database in the embedded engine.
1:25dfe8c:      */
1:4f996a4:     private EngineConnection conn;
1:4f996a4:     DRDAStatement defaultStatement;    // default statement used 
1:4f996a4:                                                        // for execute imm
1:4f996a4:     private DRDAStatement currentStatement; // current statement we are working on
1:27fbf33:     /** Hash table for storing statements. */
1:27fbf33:     private Hashtable<Object, DRDAStatement> stmtTable;
1:3f89d24: 
1:4f996a4:     // constructor
1:4f996a4:     /**
1:4f996a4:      * Database constructor
1:4f996a4:      * 
1:4f996a4:      * @param dbName    database name
1:4f996a4:      */
1:4f996a4:     Database (String dbName)
1:4f996a4:     {
1:4f996a4:         setDatabaseName(dbName);
1:27fbf33:         this.stmtTable = new Hashtable<Object, DRDAStatement>();
1:4f996a4:         initializeDefaultStatement();
1:4f996a4:     }
1:df2ca5a: 
1:4f996a4:     /**
1:4f996a4:      * Take database name including attributes and set
1:4f996a4:      * attrString and shortDbName accordingly.
1:4f996a4:      * 
1:4f996a4:      * @param dbName database name, including attributes.
1:4f996a4:      */
1:4f996a4:     public void setDatabaseName(String dbName) {
1:4f996a4:         if (dbName != null)
1:4f996a4:         {
1:4f996a4:             int attrOffset = dbName.indexOf(';');
1:4f996a4:             if (attrOffset != -1)
1:4f996a4:             {
1:4f996a4:                 this.attrString = dbName.substring(attrOffset,dbName.length());
1:4f996a4:                 this.shortDbName = dbName.substring(0,attrOffset);
1:4f996a4:             }
1:4f996a4:             else
1:4f996a4:                 this.shortDbName = dbName;
1:4f996a4:         }
1:3f89d24: 
1:4f996a4:         this.dbName = dbName;
1:4f996a4: 
1:4f996a4:     }
1:3f89d24:     
1:4f996a4:     public String getDatabaseName() {
1:4f996a4:         return this.dbName;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     public String getShortDbName() {
1:4f996a4:         return this.shortDbName;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     private void initializeDefaultStatement()
1:4f996a4:     {
1:4f996a4:         this.defaultStatement = new DRDAStatement(this);
1:4f996a4:     }
1:df2ca5a: 
1:4f996a4:     /**
1:4f996a4:      * Set connection and create the SQL statement for the default statement
1:4f996a4:      *
1:4f996a4:      * @param conn Connection
1:4f996a4:      * @exception SQLException
1:4f996a4:      */
1:4f996a4:     final void setConnection(EngineConnection conn)
1:4f996a4:         throws SQLException
1:4f996a4:     {
1:c6c4d4d:         if (this.conn != conn) {
1:c6c4d4d:             // Need to drop the pb session data when switching connections
1:c6c4d4d:             pbsd_ = null;
1:df2ca5a:         }
1:4f996a4:         this.conn = conn;
1:4f996a4:         if(conn != null)
1:4f996a4:             defaultStatement.setStatement(conn);
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Get the connection
1:4f996a4:      *
1:4f996a4:      * @return connection
1:4f996a4:      */
1:4f996a4:     final EngineConnection getConnection()
1:4f996a4:     {
1:4f996a4:         return conn;
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Get current DRDA statement 
1:4f996a4:      *
1:4f996a4:      * @return DRDAStatement
1:4f996a4:      * @exception SQLException
1:4f996a4:      */
1:4f996a4:     protected DRDAStatement getCurrentStatement() 
1:4f996a4:     {
1:4f996a4:         return currentStatement;
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Get default statement for use in EXCIMM
1:4f996a4:      *
1:4f996a4:      * @return DRDAStatement
1:4f996a4:      */
1:4f996a4:     protected DRDAStatement getDefaultStatement() 
1:4f996a4:     {
1:4f996a4:         currentStatement = defaultStatement;
1:4f996a4:         return defaultStatement;
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /**
1:4f996a4:      * Get default statement for use in EXCIMM with specified pkgnamcsn
1:4f996a4:      * The pkgnamcsn has the encoded isolation level
1:4f996a4:      *
1:4f996a4:      * @param pkgnamcsn package/ section # for statement
1:4f996a4:      * @return DRDAStatement
1:4f996a4:      */
1:4f996a4:     protected DRDAStatement getDefaultStatement(Pkgnamcsn pkgnamcsn) 
1:4f996a4:     {
1:4f996a4:         currentStatement = defaultStatement;
1:4f996a4:         currentStatement.setPkgnamcsn(pkgnamcsn);
1:4f996a4:         return currentStatement;
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /**
1:4f996a4:      * Get a new DRDA statement and store it in the stmtTable if stortStmt is 
1:4f996a4:      * true. If possible recycle an existing statement. When the server gets a
1:4f996a4:      * new statement with a previously used pkgnamcsn, it means that 
1:4f996a4:      * client-side statement associated with this pkgnamcsn has been closed. In 
1:4f996a4:      * this case, server can re-use the DRDAStatement by doing the following:  
1:4f996a4:      * 1) Retrieve the old DRDAStatement associated with this pkgnamcsn and
1:4f996a4:      * close it.
1:4f996a4:      * 2) Reset the DRDAStatement state for re-use.
1:4f996a4:      * 
1:4f996a4:      * @param pkgnamcsn  Package name and section
1:4f996a4:      * @return DRDAStatement  
1:4f996a4:      */
1:4f996a4:     protected DRDAStatement newDRDAStatement(Pkgnamcsn pkgnamcsn)
1:4f996a4:     throws SQLException
1:4f996a4:     {
1:4f996a4:         DRDAStatement stmt = getDRDAStatement(pkgnamcsn);
1:4f996a4:         if (stmt != null) {
1:4f996a4:             stmt.close();
1:4f996a4:             stmt.reset();
1:4f996a4:         }
1:4f996a4:         else
1:4f996a4:         {
1:4f996a4:             stmt = new DRDAStatement(this);
1:4f996a4:             stmt.setPkgnamcsn(pkgnamcsn);
1:4f996a4:             storeStatement(stmt);
1:4f996a4:         }
1:4f996a4:         return stmt;
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /**
1:4f996a4:      * Get DRDA statement based on pkgnamcsn
1:4f996a4:      *
1:4f996a4:      * @param pkgnamcsn - key to access statement
1:4f996a4:      * @return DRDAStatement
1:4f996a4:      */
1:4f996a4:     protected DRDAStatement getDRDAStatement(Pkgnamcsn pkgnamcsn) {
1:4f996a4:         DRDAStatement newStmt =
1:4f996a4:             (DRDAStatement) stmtTable.get(pkgnamcsn.getStatementKey());
1:4f996a4:         if (newStmt != null) {
1:4f996a4:             currentStatement = newStmt;
1:4f996a4:             currentStatement.setCurrentDrdaResultSet(pkgnamcsn);
1:4f996a4:         }
1:4f996a4:         return newStmt;
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /**
1:4f996a4:      * Make a new connection using the database name and set 
1:4f996a4:      * the connection in the database
1:4f996a4:      * @param p Properties for connection attributes to pass to connect
1:4f996a4:      */
1:4f996a4:     void makeConnection(Properties p) throws SQLException
1:4f996a4:     {
1:4f996a4:         p.put(Attribute.USERNAME_ATTR, userId);
1:673d33b:                 
1:7233e33:         // take care of case of SECMEC_USRIDONL
1:7233e33:         if (password != null) 
1:4f996a4:             p.put(Attribute.PASSWORD_ATTR, password);
1:25dfe8c:                 
1:faf2134:         // Contract between network server and embedded engine
1:faf2134:         // is that any connection returned implements EngineConnection.
1:faf2134:         EngineConnection conn = (EngineConnection)
1:faf2134:             NetworkServerControlImpl.getDriver().connect(Attribute.PROTOCOL
1:4f996a4:                              + shortDbName + attrString, p);
1:7233e33:         if (conn != null) {
1:4f996a4:             conn.setAutoCommit(false);
1:4f996a4:         }
1:4f996a4:         setConnection(conn);
1:4f996a4:     }
1:4383496: 
1:7233e33:     /**
1:7233e33:      * This makes a dummy connection to the database in order to 
1:7233e33:      * boot and/or create this last one. If database cannot
1:7233e33:      * be found or authentication does not succeed, this will throw
1:7233e33:      * a SQLException which we catch and do nothing. We don't pass a
1:7233e33:      * userid and password here as we don't need to for the purpose
1:7233e33:      * of this method - main goal is to cause the database to be
1:7233e33:      * booted via a dummy connection.
1:7233e33:      */
1:7233e33:     void makeDummyConnection()
1:7233e33:     {
1:7233e33:         try {
1:7233e33:             // Contract between network server and embedded engine
1:7233e33:             // is that any connection returned implements EngineConnection.
1:7233e33:             EngineConnection conn = (EngineConnection)
1:7233e33:                 NetworkServerControlImpl.getDriver().connect(Attribute.PROTOCOL
1:7233e33:                     + shortDbName + attrString, new Properties());
1:7233e33: 
1:7233e33:             // If we succeeded in getting a connection, well just close it
1:7233e33:             if (conn != null) {
1:7233e33:                 conn.close();
1:7233e33:             }
1:7233e33:         } catch (SQLException se) {} // Simply do nothing
1:7233e33:     }
1:7233e33:     
1:4f996a4:     // Create string to pass to DataSource.setConnectionAttributes
1:4f996a4:     String appendAttrString(Properties p)
1:4f996a4:     {
1:4f996a4:         if (p == null)
1:4f996a4:             return null;
1:4f996a4:         
1:4f996a4:         Enumeration pKeys = p.propertyNames();
1:4f996a4:         while (pKeys.hasMoreElements()) 
1:4f996a4:         {
1:4f996a4:             String key = (String) pKeys.nextElement();
1:7233e33:             attrString +=";" + key  + "=" + p.getProperty(key);
1:4f996a4:         }
1:4383496: 
1:4f996a4:         return attrString;
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /**
1:4f996a4:      * Store DRDA prepared statement
1:db9a013:      * @param  stmt DRDA prepared statement
1:4f996a4:      */
1:4f996a4:     protected void storeStatement(DRDAStatement stmt) throws SQLException
1:4f996a4:     {
1:4f996a4:         stmtTable.put(stmt.getPkgnamcsn().getStatementKey(), stmt);
1:4f996a4:     }
1:4383496: 
1:4f996a4:     protected void removeStatement(DRDAStatement stmt) throws SQLException
1:4f996a4:     {
1:4f996a4:         stmtTable.remove(stmt.getPkgnamcsn().getStatementKey());
1:4f996a4:         stmt.close();
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * Make statement the current statement
1:4f996a4:      * @param stmt
1:4f996a4:      *
1:4f996a4:      */
1:eac0369: 
1:4f996a4:     protected void setCurrentStatement(DRDAStatement stmt)
1:4f996a4:     {
1:4f996a4:         currentStatement = stmt;
1:4f996a4:     }
1:eac0369: 
1:eac0369:    
1:4f996a4:     protected void commit() throws SQLException
1:4f996a4:     {
1:4f996a4:         
1:4f996a4:         if (conn != null)
1:4f996a4:             conn.commit();
1:4f996a4:     }
1:4383496: 
1:4f996a4:     protected void rollback() throws SQLException
1:4f996a4:     {
1:4f996a4:         
1:4f996a4:         if (conn != null)
1:4f996a4:             conn.rollback();
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:       * Database close does following cleanup tasks
1:4f996a4:       * 1)Rollback any pending transaction on the Connection object (except 
1:4f996a4:       * for a global-XA Connection obejct) before closing the Connection. 
1:4f996a4:       * Without the rollback, the Connection close will result into an 
1:4f996a4:       * exception if there is a pending transaction on that Connection.
1:4f996a4:       * 2)Clean up the statement table 
1:4f996a4:       * @throws SQLException on conn.close() error to be handled in DRDAConnThread.
1:4f996a4:       */
1:4f996a4:     protected void close() throws SQLException
1:4f996a4:     {
1:eac0369: 
1:4f996a4:         try {
1:4f996a4:             if (stmtTable != null)
1:4f996a4:             {
2:4f996a4:                 for (Enumeration e = stmtTable.elements() ; e.hasMoreElements() ;) 
1:4f996a4:                 {
1:4f996a4:                     ((DRDAStatement) e.nextElement()).close();
1:4f996a4:                 }
1:4f996a4:             
1:4f996a4:             }
1:db9a013:             if (defaultStatement != null)
1:4f996a4:                 defaultStatement.close();
1:4f996a4:             if ((conn != null) && !conn.isClosed())
1:4f996a4:             {
1:4f996a4:                 //rollback all the pending transactions except global XA trans
1:4f996a4:                 if (! conn.isInGlobalTransaction())
1:4f996a4:                 {
1:4f996a4:                     conn.rollback();
1:4f996a4:                 }
1:db9a013:                 conn.close();
1:4f996a4:             }
1:4f996a4:         }
1:4f996a4:         finally {
1:4f996a4:             conn = null;
1:4f996a4:             currentStatement = null;
1:4f996a4:             defaultStatement = null;
1:4f996a4:             stmtTable=null;
1:4f996a4:         }
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     final void setDrdaID(String drdaID)
1:4f996a4:     {
1:4f996a4:         if (conn != null)
1:4f996a4:             conn.setDrdaID(drdaID);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      *  Set the internal isolation level to use for preparing statements.
1:4f996a4:      *  Subsequent prepares will use this isoalation level
1:4f996a4:      * @param level internal isolation level 
1:4f996a4:      *
1:4f996a4:      * @throws SQLException
1:4f996a4:      * @see EngineConnection#setPrepareIsolation
1:4f996a4:      * 
1:4f996a4:      */
1:4f996a4:     final void setPrepareIsolation(int level) throws SQLException
1:4f996a4:     {
1:4f996a4:         conn.setPrepareIsolation(level);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     final int getPrepareIsolation() throws SQLException
1:4f996a4:     {
1:4f996a4:         return conn.getPrepareIsolation();
1:4f996a4:     }
1:4f996a4: 
1:4f996a4:     protected String buildRuntimeInfo(String indent, LocalizedResource localLangUtil)
1:db9a013:     {
1:4f1dcde:         // DERBY-6714: stmtTable can be null if the session gets closed
1:4f1dcde:         // while we are constructing the runtime info. Create a local copy
1:4f1dcde:         // and check for null before accessing it.
1:4f1dcde:         Hashtable<Object, DRDAStatement> statements = stmtTable;
1:4f1dcde: 
1:4f996a4:         String s = indent + 
1:4f996a4:         localLangUtil.getTextMessage("DRDA_RuntimeInfoDatabase.I") +
1:4f996a4:             dbName + "\n" +  
1:4f996a4:         localLangUtil.getTextMessage("DRDA_RuntimeInfoUser.I")  +
1:4f996a4:             userId +  "\n" +
1:4f996a4:         localLangUtil.getTextMessage("DRDA_RuntimeInfoNumStatements.I") +
1:4f1dcde:             (statements == null ? 0 : statements.size()) + "\n";
1:4f996a4:         s += localLangUtil.getTextMessage("DRDA_RuntimeInfoPreparedStatementHeader.I");
1:4f1dcde: 
1:4f1dcde:         if (statements != null) {
1:4f1dcde:             for (Enumeration e = statements.elements(); e.hasMoreElements(); )
1:4f996a4:                 {
1:4f996a4:                     s += ((DRDAStatement) e.nextElement()).toDebugString(indent
1:4f996a4:                                                                          +"\t") +"\n";
1:4f1dcde:                 }
1:4f996a4:         }
1:4f1dcde: 
1:4f996a4:         return s;
1:4f996a4:     }
1:d6948ea:     
1:d6948ea:     private boolean locatorSupport = false;
1:d6948ea:     private boolean locatorSupportChecked = false;
1:d6948ea:     
1:d6948ea:     /**
1:d6948ea:      * Checks whether database can support locators.  This is done by
1:d6948ea:      * checking whether one of the stored procedures needed for
1:d6948ea:      * locators exists.  (If the database has been soft-upgraded from
1:d6948ea:      * an earlier version, the procedures will not exist).
1:d6948ea:      *
1:d6948ea:      * @throws SQLException if metadata call fails
1:d6948ea:      * @return <code>true</code> if locators are supported,
1:dbed020:      *         <code>false</code> otherwise
1:d6948ea:      */
1:d6948ea:     boolean supportsLocator() throws SQLException
1:d6948ea:     {
1:d6948ea:         if (!locatorSupportChecked) {
1:d6948ea:             // Check if locator procedures exist
1:d6948ea:             ResultSet rs = getConnection().getMetaData()
1:d6948ea:                     .getProcedures(null, "SYSIBM", "BLOBTRUNCATE");
1:d6948ea:             locatorSupport =  rs.next();  // True if procedure exists
1:d6948ea:             rs.close();
1:d6948ea:             locatorSupportChecked = true;
1:d6948ea:         }
1:d6948ea:         
1:d6948ea:         return locatorSupport;
1:d6948ea:     }
1:d6948ea:        
1:25dfe8c: 
1:4383496:     /**
1:25dfe8c:      * This method resets the state of this Database object so that it can
1:25dfe8c:      * be re-used.
1:25dfe8c:      * Note: currently this method resets the variables related to security
1:25dfe8c:      * mechanisms that have been investigated as needing a reset.  
1:25dfe8c:      * TODO: Investigate what all variables in this class need to be 
1:25dfe8c:      * reset when this database object is re-used on a connection pooling or
1:25dfe8c:      * transaction pooling. see DRDAConnThread.parseACCSEC (CodePoint.RDBNAM)
1:25dfe8c:      * where database object is re-used on a connection reset.
1:3f89d24:      */
1:25dfe8c:     public void reset()
1:4f996a4:     {
1:25dfe8c:         // Reset variables for connection re-use. Currently only takes care
1:7233e33:         // of reset the variables that affect EUSRIDPWD and USRSSBPWD
1:7233e33:         // security mechanisms.  (DERBY-1080)
1:25dfe8c:         decryptedUserId = null;
1:25dfe8c:         decryptedPassword = null;
1:7233e33:         passwordSubstitute = null;
1:7233e33:         secTokenIn = null;
1:7233e33:         secTokenOut = null;
1:25dfe8c:         userId = null;
1:25dfe8c:         password = null;
1:25dfe8c:         securityMechanism = 0;
1:df2ca5a:     }
1:c6c4d4d: 
1:c6c4d4d:     /**
1:c6c4d4d:      * Piggy-backed session data. Null if no piggy-backing
1:c6c4d4d:      * has happened yet. Lazy initialization is acceptable since the client's
1:c6c4d4d:      * cache initially is empty so that any request made prior to the first
1:c6c4d4d:      * round of piggy-backing will trigger an actual request to the server.
1:c6c4d4d:      */
1:c6c4d4d:     private PiggyBackedSessionData pbsd_ = null;
1:c6c4d4d: 
1:c6c4d4d:     /**
1:c6c4d4d:      * Get a reference (handle) to the PiggyBackedSessionData object. Null will
1:c6c4d4d:      * be returned either if Database.conn is not a valid connection, or if the
1:c6c4d4d:      * create argument is false and no object has yet been created.
1:c6c4d4d:      * @param createOnDemand if true create the PiggyBackedSessionData on demand
1:c6c4d4d:      * @return a reference to the PBSD object or null
1:c6c4d4d:      * @throws java.sql.SQLException
1:c6c4d4d:      */
1:c6c4d4d:     public PiggyBackedSessionData getPiggyBackedSessionData(
1:c6c4d4d:             boolean createOnDemand) throws SQLException {
1:c6c4d4d:         pbsd_ = PiggyBackedSessionData.getInstance(pbsd_, conn, createOnDemand);
1:c6c4d4d:         return pbsd_;
1:3f89d24:     }
1:f0dcf0b: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      *         <code>false</code> otherwise
commit:d6948ea
/////////////////////////////////////////////////////////////////////////
1:     
1:     private boolean locatorSupport = false;
1:     private boolean locatorSupportChecked = false;
1:     
1:     /**
1:      * Checks whether database can support locators.  This is done by
1:      * checking whether one of the stored procedures needed for
1:      * locators exists.  (If the database has been soft-upgraded from
1:      * an earlier version, the procedures will not exist).
1:      *
1:      * @throws SQLException if metadata call fails
1:      * @return <code>true</code> if locators are supported,
0:      *         <code>false</code otherwise
1:      */
1:     boolean supportsLocator() throws SQLException
1:     {
1:         if (!locatorSupportChecked) {
1:             // Check if locator procedures exist
1:             ResultSet rs = getConnection().getMetaData()
1:                     .getProcedures(null, "SYSIBM", "BLOBTRUNCATE");
1:             locatorSupport =  rs.next();  // True if procedure exists
1:             rs.close();
1:             locatorSupportChecked = true;
1:         }
1:         
1:         return locatorSupport;
1:     }
1:        
commit:7233e33
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected byte[] passwordSubstitute;// password substitute - SECMEC_USRSSBPWD
0:     protected byte[] secTokenIn;		// Security token from app requester
0:     protected byte[] secTokenOut;		// Security token sent to app requester
/////////////////////////////////////////////////////////////////////////
1:         // take care of case of SECMEC_USRIDONL
1:         if (password != null) 
/////////////////////////////////////////////////////////////////////////
1: 		if (conn != null) {
1:     /**
1:      * This makes a dummy connection to the database in order to 
1:      * boot and/or create this last one. If database cannot
1:      * be found or authentication does not succeed, this will throw
1:      * a SQLException which we catch and do nothing. We don't pass a
1:      * userid and password here as we don't need to for the purpose
1:      * of this method - main goal is to cause the database to be
1:      * booted via a dummy connection.
1:      */
1:     void makeDummyConnection()
1:     {
1:         try {
1:             // Contract between network server and embedded engine
1:             // is that any connection returned implements EngineConnection.
1:             EngineConnection conn = (EngineConnection)
1:                 NetworkServerControlImpl.getDriver().connect(Attribute.PROTOCOL
1:                     + shortDbName + attrString, new Properties());
1: 
1:             // If we succeeded in getting a connection, well just close it
1:             if (conn != null) {
1:                 conn.close();
1:             }
1:         } catch (SQLException se) {} // Simply do nothing
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: 			attrString +=";" + key  + "=" + p.getProperty(key);
/////////////////////////////////////////////////////////////////////////
1:         // of reset the variables that affect EUSRIDPWD and USRSSBPWD
1:         // security mechanisms.  (DERBY-1080)
1:         passwordSubstitute = null;
1:         secTokenIn = null;
1:         secTokenOut = null;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4f1dcde
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-6714: stmtTable can be null if the session gets closed
1:         // while we are constructing the runtime info. Create a local copy
1:         // and check for null before accessing it.
1:         Hashtable<Object, DRDAStatement> statements = stmtTable;
1: 
1:             (statements == null ? 0 : statements.size()) + "\n";
1: 
1:         if (statements != null) {
1:             for (Enumeration e = statements.elements(); e.hasMoreElements(); )
1:         }
1: 
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:     private String dbName;          // database name
1:     protected String password;          // password
1:     protected String decryptedUserId;   // Decrypted User id
1:     protected String decryptedPassword; // Decrypted password
1:     protected boolean rdbAllowUpdates = true; // Database allows updates -default is true
1:     protected int   accessCount;        // Number of times we have tried to
1:     protected byte[] secTokenOut;       // Security token sent to app requester
1:     protected String typDefNam;         // Type definition name
1:     protected int ccsidSBC;             // Single byte CCSID
1:     protected int ccsidDBC;             // Double byte CCSID
1:     protected int ccsidMBC;             // Mixed byte CCSID
1:     protected String ccsidSBCEncoding;  // Encoding for single byte code page
1:     protected String ccsidDBCEncoding;  // Encoding for double byte code page
1:     protected String ccsidMBCEncoding;  // Encoding for mixed byte code page
/////////////////////////////////////////////////////////////////////////
1:      * @param  stmt DRDA prepared statement
/////////////////////////////////////////////////////////////////////////
1:             if (defaultStatement != null)
/////////////////////////////////////////////////////////////////////////
1:                 conn.close();
/////////////////////////////////////////////////////////////////////////
1:     {
commit:db4c995
/////////////////////////////////////////////////////////////////////////
1: import java.util.Hashtable;
commit:27fbf33
/////////////////////////////////////////////////////////////////////////
1:     /** Hash table for storing statements. */
1:     private Hashtable<Object, DRDAStatement> stmtTable;
/////////////////////////////////////////////////////////////////////////
1: 		this.stmtTable = new Hashtable<Object, DRDAStatement>();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     Database stores information about the current database
1:     It is used so that a session may have more than one database
/////////////////////////////////////////////////////////////////////////
0:     private String dbName;            // database name 
1:     private String shortDbName;       // database name without attributes
1:     String attrString="";               // attribute string
1:     protected int securityMechanism;    // Security mechanism
1:     protected String userId;            // User Id
0:     protected String password;            // password
0:     protected String decryptedUserId;    // Decrypted User id
0:     protected String decryptedPassword;    // Decrypted password
0:     protected boolean rdbAllowUpdates = true; // Database allows updates -default is true        
0:     protected int    accessCount;        // Number of times we have tried to
1:                                         // set up access to this database (only 1 
1:                                         // allowed)
1:     protected byte[] secTokenIn;        // Security token from app requester
0:     protected byte[] secTokenOut;        // Security token sent to app requester
1:     protected byte[] crrtkn;            // Correlation token
0:     protected String typDefNam;            // Type definition name
1:     protected int byteOrder;            //deduced from typDefNam, save String comparisons
0:     protected int ccsidSBC;                // Single byte CCSID
0:     protected int ccsidDBC;                // Double byte CCSID
0:     protected int ccsidMBC;                // Mixed byte CCSID
0:     protected String ccsidSBCEncoding;    // Encoding for single byte code page
0:     protected String ccsidDBCEncoding;    // Encoding for double byte code page
0:     protected String ccsidMBCEncoding;    // Encoding for mixed byte code page
1:     protected boolean RDBUPDRM_sent = false;    //We have sent that an update
1:                                             // occurred in this transaction
1:     protected boolean sendTRGDFTRT = false; // Send package target default value
1:     private EngineConnection conn;
1:     DRDAStatement defaultStatement;    // default statement used 
1:                                                        // for execute imm
1:     private DRDAStatement currentStatement; // current statement we are working on
1:     // constructor
1:     /**
1:      * Database constructor
1:      * 
1:      * @param dbName    database name
1:      */
1:     Database (String dbName)
1:     {
1:         setDatabaseName(dbName);
0:         this.stmtTable = new Hashtable<Object, DRDAStatement>();
1:         initializeDefaultStatement();
1:     }
1:     /**
1:      * Take database name including attributes and set
1:      * attrString and shortDbName accordingly.
1:      * 
1:      * @param dbName database name, including attributes.
1:      */
1:     public void setDatabaseName(String dbName) {
1:         if (dbName != null)
1:         {
1:             int attrOffset = dbName.indexOf(';');
1:             if (attrOffset != -1)
1:             {
1:                 this.attrString = dbName.substring(attrOffset,dbName.length());
1:                 this.shortDbName = dbName.substring(0,attrOffset);
1:             }
1:             else
1:                 this.shortDbName = dbName;
1:         }
1:         this.dbName = dbName;
1:     }
1:     
1:     public String getDatabaseName() {
1:         return this.dbName;
1:     }
1:     
1:     public String getShortDbName() {
1:         return this.shortDbName;
1:     }
1:     
1:     private void initializeDefaultStatement()
1:     {
1:         this.defaultStatement = new DRDAStatement(this);
1:     }
1:     /**
1:      * Set connection and create the SQL statement for the default statement
1:      *
1:      * @param conn Connection
1:      * @exception SQLException
1:      */
1:     final void setConnection(EngineConnection conn)
1:         throws SQLException
1:     {
1:         this.conn = conn;
1:         if(conn != null)
1:             defaultStatement.setStatement(conn);
1:     }
1:     /**
1:      * Get the connection
1:      *
1:      * @return connection
1:      */
1:     final EngineConnection getConnection()
1:     {
1:         return conn;
1:     }
1:     /**
1:      * Get current DRDA statement 
1:      *
1:      * @return DRDAStatement
1:      * @exception SQLException
1:      */
1:     protected DRDAStatement getCurrentStatement() 
1:     {
1:         return currentStatement;
1:     }
1:     /**
1:      * Get default statement for use in EXCIMM
1:      *
1:      * @return DRDAStatement
1:      */
1:     protected DRDAStatement getDefaultStatement() 
1:     {
1:         currentStatement = defaultStatement;
1:         return defaultStatement;
1:     }
1:     /**
1:      * Get default statement for use in EXCIMM with specified pkgnamcsn
1:      * The pkgnamcsn has the encoded isolation level
1:      *
1:      * @param pkgnamcsn package/ section # for statement
1:      * @return DRDAStatement
1:      */
1:     protected DRDAStatement getDefaultStatement(Pkgnamcsn pkgnamcsn) 
1:     {
1:         currentStatement = defaultStatement;
1:         currentStatement.setPkgnamcsn(pkgnamcsn);
1:         return currentStatement;
1:     }
1:     /**
1:      * Get a new DRDA statement and store it in the stmtTable if stortStmt is 
1:      * true. If possible recycle an existing statement. When the server gets a
1:      * new statement with a previously used pkgnamcsn, it means that 
1:      * client-side statement associated with this pkgnamcsn has been closed. In 
1:      * this case, server can re-use the DRDAStatement by doing the following:  
1:      * 1) Retrieve the old DRDAStatement associated with this pkgnamcsn and
1:      * close it.
1:      * 2) Reset the DRDAStatement state for re-use.
1:      * 
1:      * @param pkgnamcsn  Package name and section
1:      * @return DRDAStatement  
1:      */
1:     protected DRDAStatement newDRDAStatement(Pkgnamcsn pkgnamcsn)
1:     throws SQLException
1:     {
1:         DRDAStatement stmt = getDRDAStatement(pkgnamcsn);
1:         if (stmt != null) {
1:             stmt.close();
1:             stmt.reset();
1:         }
1:         else
1:         {
1:             stmt = new DRDAStatement(this);
1:             stmt.setPkgnamcsn(pkgnamcsn);
1:             storeStatement(stmt);
1:         }
1:         return stmt;
1:     }
1:     /**
1:      * Get DRDA statement based on pkgnamcsn
1:      *
1:      * @param pkgnamcsn - key to access statement
1:      * @return DRDAStatement
1:      */
1:     protected DRDAStatement getDRDAStatement(Pkgnamcsn pkgnamcsn) {
1:         DRDAStatement newStmt =
1:             (DRDAStatement) stmtTable.get(pkgnamcsn.getStatementKey());
1:         if (newStmt != null) {
1:             currentStatement = newStmt;
1:             currentStatement.setCurrentDrdaResultSet(pkgnamcsn);
1:         }
1:         return newStmt;
1:     }
1:     /**
1:      * Make a new connection using the database name and set 
1:      * the connection in the database
1:      * @param p Properties for connection attributes to pass to connect
1:      */
1:     void makeConnection(Properties p) throws SQLException
1:     {
1:         p.put(Attribute.USERNAME_ATTR, userId);
1:             p.put(Attribute.PASSWORD_ATTR, password);
1:                              + shortDbName + attrString, p);
0:         if (conn != null) {
1:             conn.setAutoCommit(false);
1:         }
1:         setConnection(conn);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     // Create string to pass to DataSource.setConnectionAttributes
1:     String appendAttrString(Properties p)
1:     {
1:         if (p == null)
1:             return null;
1:         
1:         Enumeration pKeys = p.propertyNames();
1:         while (pKeys.hasMoreElements()) 
1:         {
1:             String key = (String) pKeys.nextElement();
0:             attrString +=";" + key  + "=" + p.getProperty(key);
1:         }
1:         return attrString;
1:     }
1:     /**
1:      * Store DRDA prepared statement
0:      * @param  stmt    DRDA prepared statement
1:      */
1:     protected void storeStatement(DRDAStatement stmt) throws SQLException
1:     {
1:         stmtTable.put(stmt.getPkgnamcsn().getStatementKey(), stmt);
1:     }
1:     protected void removeStatement(DRDAStatement stmt) throws SQLException
1:     {
1:         stmtTable.remove(stmt.getPkgnamcsn().getStatementKey());
1:         stmt.close();
1:     }
1:     
1:     /**
1:      * Make statement the current statement
1:      * @param stmt
1:      *
1:      */
1:     protected void setCurrentStatement(DRDAStatement stmt)
1:     {
1:         currentStatement = stmt;
1:     }
1:     protected void commit() throws SQLException
1:     {
1:         
1:         if (conn != null)
1:             conn.commit();
1:     }
1:     protected void rollback() throws SQLException
1:     {
1:         
1:         if (conn != null)
1:             conn.rollback();
1:     }
1:     /**
1:       * Database close does following cleanup tasks
1:       * 1)Rollback any pending transaction on the Connection object (except 
1:       * for a global-XA Connection obejct) before closing the Connection. 
1:       * Without the rollback, the Connection close will result into an 
1:       * exception if there is a pending transaction on that Connection.
1:       * 2)Clean up the statement table 
1:       * @throws SQLException on conn.close() error to be handled in DRDAConnThread.
1:       */
1:     protected void close() throws SQLException
1:     {
1:         try {
1:             if (stmtTable != null)
1:             {
1:                 for (Enumeration e = stmtTable.elements() ; e.hasMoreElements() ;) 
1:                 {
1:                     ((DRDAStatement) e.nextElement()).close();
1:                 }
1:             
1:             }
0:             if (defaultStatement != null)            
1:                 defaultStatement.close();
1:             if ((conn != null) && !conn.isClosed())
1:             {
1:                 //rollback all the pending transactions except global XA trans
1:                 if (! conn.isInGlobalTransaction())
1:                 {
1:                     conn.rollback();
1:                 }
0:                 conn.close();                    
1:             }
1:         }
1:         finally {
1:             conn = null;
1:             currentStatement = null;
1:             defaultStatement = null;
1:             stmtTable=null;
1:         }
1:     }
1:     final void setDrdaID(String drdaID)
1:     {
1:         if (conn != null)
1:             conn.setDrdaID(drdaID);
1:     }
1:     /**
1:      *  Set the internal isolation level to use for preparing statements.
1:      *  Subsequent prepares will use this isoalation level
1:      * @param level internal isolation level 
1:      *
1:      * @throws SQLException
1:      * @see EngineConnection#setPrepareIsolation
1:      * 
1:      */
1:     final void setPrepareIsolation(int level) throws SQLException
1:     {
1:         conn.setPrepareIsolation(level);
1:     }
1:     final int getPrepareIsolation() throws SQLException
1:     {
1:         return conn.getPrepareIsolation();
1:     }
1:     protected String buildRuntimeInfo(String indent, LocalizedResource localLangUtil)
1:     {    
1:       
1:         String s = indent + 
1:         localLangUtil.getTextMessage("DRDA_RuntimeInfoDatabase.I") +
1:             dbName + "\n" +  
1:         localLangUtil.getTextMessage("DRDA_RuntimeInfoUser.I")  +
1:             userId +  "\n" +
1:         localLangUtil.getTextMessage("DRDA_RuntimeInfoNumStatements.I") +
0:             stmtTable.size() + "\n";
1:         s += localLangUtil.getTextMessage("DRDA_RuntimeInfoPreparedStatementHeader.I");
1:         for (Enumeration e = stmtTable.elements() ; e.hasMoreElements() ;) 
1:                 {
1:                     s += ((DRDAStatement) e.nextElement()).toDebugString(indent
1:                                                                          +"\t") +"\n";
1:                 }
1:         return s;
1:     }
commit:df2ca5a
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * Considering that we are now doing some fiddling with the db name
1:      * it is probably wise to keep dbName and shortDbName private and have 
1:      * accessors for them.
1:      */
0: 	private String dbName;			// database name 
0: 	private String shortDbName;       // database name without attributes
/////////////////////////////////////////////////////////////////////////
0: 	public String getDatabaseName() {
0: 	    return this.dbName;
1: 	}
1: 	
0: 	public String getShortDbName() {
0: 	    return this.shortDbName;
1: 	}
1: 	
commit:3f89d24
/////////////////////////////////////////////////////////////////////////
0: 		setDatabaseName(dbName);
0: 		this.stmtTable = new Hashtable();
0: 		initializeDefaultStatement();
1: 	}
1: 
1: 	/**
0: 	 * Take database name including attributes and set
0: 	 * attrString and shortDbName accordingly.
0: 	 * 
0: 	 * @param dbName database name, including attributes.
1: 	 */
0: 	public void setDatabaseName(String dbName) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 	
commit:f0dcf0b
/////////////////////////////////////////////////////////////////////////
0: 	 * Get a new DRDA statement and store it in the stmtTable if stortStmt is 
0: 	 * true. If possible recycle an existing statement. When the server gets a
0: 	 * new statement with a previously used pkgnamcsn, it means that 
0: 	 * client-side statement associated with this pkgnamcsn has been closed. In 
0: 	 * this case, server can re-use the DRDAStatement by doing the following:  
0: 	 * 1) Retrieve the old DRDAStatement associated with this pkgnamcsn and
0: 	 * close it.
0: 	 * 2) Reset the DRDAStatement state for re-use.
0: 	 * 
/////////////////////////////////////////////////////////////////////////
0: 		if (stmt != null) {
0: 			stmt.reset();
1: 		}
commit:2e4a44e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:a36fdb7
/////////////////////////////////////////////////////////////////////////
0: 		if(conn != null)
0: 			defaultStatement.setStatement(conn);
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = NetworkServerControlImpl.getDriver().connect(Attribute.PROTOCOL
0: 							 + shortDbName + attrString, p);
0: 		if(conn != null){
0: 			conn.setAutoCommit(false);
0: 		}
commit:9085abb
/////////////////////////////////////////////////////////////////////////
0: 		Connection conn = NetworkServerControlImpl.getDriver().connect(Attribute.PROTOCOL
commit:673d33b
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 // take care of case of SECMEC_USRIDONL
0:                 if(password != null) 
0: 		    p.put(Attribute.PASSWORD_ATTR, password);
commit:4383496
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Driver;
1: import java.util.Properties;
1: import org.apache.derby.iapi.reference.Attribute;
/////////////////////////////////////////////////////////////////////////
0: 	protected String shortDbName;       // database name without attributes
0: 	String attrString="";               // attribute string
/////////////////////////////////////////////////////////////////////////
0: 	DRDAStatement defaultStatement;    // default statement used 
0: 	Hashtable stmtTable;		// Hash table for storing statements
0: 	boolean forXA = false;
/////////////////////////////////////////////////////////////////////////
0: 		if (dbName != null)
1: 		{
0: 			int attrOffset = dbName.indexOf(';');
0: 			if (attrOffset != -1)
1: 			{
0: 				this.attrString = dbName.substring(attrOffset,dbName.length());
0: 				this.shortDbName = dbName.substring(0,attrOffset);
0: 			}
0: 			else
0: 				this.shortDbName = dbName;
0: 		}
1: 
0: 		initializeDefaultStatement();
0: 	}
1: 
1: 
0: 	private void initializeDefaultStatement()
1: 	{
1: 
/////////////////////////////////////////////////////////////////////////
0: 	 * Make a new connection using the database name and set 
0: 	 * the connection in the database
0: 	 * @param p Properties for connection attributes to pass to connect
0: 	 * @return new local connection
1: 	 */
0: 	protected Connection makeConnection(Properties p) throws SQLException
0: 	{
0: 		p.put(Attribute.USERNAME_ATTR, userId);
0: 		p.put(Attribute.PASSWORD_ATTR, password);
0: 		Connection conn = DB2jServerImpl.getDriver().connect(Attribute.PROTOCOL
0: 							 + dbName + attrString, p);
0: 		conn.setAutoCommit(false);
0: 		setConnection(conn);
0: 		return conn;
0: 	}
1: 
0: 	// Create string to pass to DataSource.setConnectionAttributes
0: 	String appendAttrString(Properties p)
0: 	{
0: 		if (p == null)
0: 			return null;
1: 		
0: 		Enumeration pKeys = p.propertyNames();
0: 		while (pKeys.hasMoreElements()) 
0: 		{
0: 			String key = (String) pKeys.nextElement();
0: 			attrString +=";" + key  +"=" + p.getProperty(key);
0: 		}
1: 
0: 		return attrString;
0: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
0: 				if (! forXA)
0: 				{
0: 					conn.rollback();
0: 				}
0: 				conn.close();					
/////////////////////////////////////////////////////////////////////////
0: 	protected void setDrdaID(String drdaID)
0: 	{
0: 		if (conn != null)
0: 			((EmbedConnection)conn).setDrdaID(drdaID);
0: 	}
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:ad40eda
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	  * Database close does following cleanup tasks
0: 	  * 1)Rollback any pending transaction on the Connection object (except 
0: 	  * for a global-XA Connection obejct) before closing the Connection. 
0: 	  * Without the rollback, the Connection close will result into an 
0: 	  * exception if there is a pending transaction on that Connection.
0: 	  * 2)Clean up the statement table 
/////////////////////////////////////////////////////////////////////////
0: 				//rollback all the pending transactions except global XA trans
0: 				if (! conn.isInGlobalTransaction())
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:c6c4d4d
/////////////////////////////////////////////////////////////////////////
1:         if (this.conn != conn) {
1:             // Need to drop the pb session data when switching connections
1:             pbsd_ = null;
0:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Piggy-backed session data. Null if no piggy-backing
1:      * has happened yet. Lazy initialization is acceptable since the client's
1:      * cache initially is empty so that any request made prior to the first
1:      * round of piggy-backing will trigger an actual request to the server.
1:      */
1:     private PiggyBackedSessionData pbsd_ = null;
1: 
1:     /**
1:      * Get a reference (handle) to the PiggyBackedSessionData object. Null will
1:      * be returned either if Database.conn is not a valid connection, or if the
1:      * create argument is false and no object has yet been created.
1:      * @param createOnDemand if true create the PiggyBackedSessionData on demand
1:      * @return a reference to the PBSD object or null
1:      * @throws java.sql.SQLException
1:      */
1:     public PiggyBackedSessionData getPiggyBackedSessionData(
1:             boolean createOnDemand) throws SQLException {
1:         pbsd_ = PiggyBackedSessionData.getInstance(pbsd_, conn, createOnDemand);
1:         return pbsd_;
0:     }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:f0b0870
/////////////////////////////////////////////////////////////////////////
0: 	 * @param level internal isolation level 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:25dfe8c
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * This method resets the state of this Database object so that it can
1:      * be re-used.
1:      * Note: currently this method resets the variables related to security
1:      * mechanisms that have been investigated as needing a reset.  
1:      * TODO: Investigate what all variables in this class need to be 
1:      * reset when this database object is re-used on a connection pooling or
1:      * transaction pooling. see DRDAConnThread.parseACCSEC (CodePoint.RDBNAM)
1:      * where database object is re-used on a connection reset.
1:      */
1:     public void reset()
0:     {
1:         // Reset variables for connection re-use. Currently only takes care
0:         // of reset the variables that affect EUSRIDPWD security mechanism.  (DERBY-1080)
1:         decryptedUserId = null;
1:         decryptedPassword = null;
0:         publicKeyIn = null;
0:         publicKeyOut = null;
1:         userId = null;
1:         password = null;
1:         securityMechanism = 0;
0:     }
1:         
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:3734dde
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	final void setDrdaID(String drdaID)
0: 			conn.setDrdaID(drdaID);
/////////////////////////////////////////////////////////////////////////
0: 	 * @see EngineConnection#setPrepareIsolation
0: 	final void setPrepareIsolation(int level) throws SQLException
0: 		conn.setPrepareIsolation(level);
0: 	final int getPrepareIsolation() throws SQLException
0: 		return conn.getPrepareIsolation();
commit:faf2134
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.derby.iapi.jdbc.EngineConnection;
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Connection to the database in the embedded engine.
1:      */
0: 	private EngineConnection conn;
/////////////////////////////////////////////////////////////////////////
0: 	final void setConnection(EngineConnection conn)
/////////////////////////////////////////////////////////////////////////
0: 	final EngineConnection getConnection()
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 
1:         // Contract between network server and embedded engine
1:         // is that any connection returned implements EngineConnection.
1:         EngineConnection conn = (EngineConnection)
1:             NetworkServerControlImpl.getDriver().connect(Attribute.PROTOCOL
commit:af35756
/////////////////////////////////////////////////////////////////////////
0: 	void setConnection(Connection conn)
/////////////////////////////////////////////////////////////////////////
0: 	Connection getConnection()
/////////////////////////////////////////////////////////////////////////
0: 	void makeConnection(Properties p) throws SQLException
/////////////////////////////////////////////////////////////////////////
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
0: 	Database (String dbName)
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.Database
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.impl.drda;
1: 
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.Statement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
0: import java.util.Hashtable;
1: import java.util.Enumeration;
1: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1: 
0: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: /**
0: 	Database stores information about the current database
0: 	It is used so that a session may have more than one database
0: */
1: class Database
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
0: 	protected String dbName;			// database name 
0: 	protected int securityMechanism;	// Security mechanism
0: 	protected String userId;			// User Id
0: 	protected String password;			// password
0: 	protected String decryptedUserId;	// Decrypted User id
0: 	protected String decryptedPassword;	// Decrypted password
0: 	protected boolean rdbAllowUpdates = true; // Database allows updates -default is true		
0: 	protected int	accessCount;		// Number of times we have tried to
0: 										// set up access to this database (only 1 
0: 										// allowed)
0: 	protected byte[] publicKeyIn;		// Security token from app requester
0: 	protected byte[] publicKeyOut;		// Security token sent to app requester
0: 	protected byte[] crrtkn;			// Correlation token
0: 	protected String typDefNam;			// Type definition name
0: 	protected int byteOrder;			//deduced from typDefNam, save String comparisons
0: 	protected int ccsidSBC;				// Single byte CCSID
0: 	protected int ccsidDBC;				// Double byte CCSID
0: 	protected int ccsidMBC;				// Mixed byte CCSID
0: 	protected String ccsidSBCEncoding;	// Encoding for single byte code page
0: 	protected String ccsidDBCEncoding;	// Encoding for double byte code page
0: 	protected String ccsidMBCEncoding;	// Encoding for mixed byte code page
0: 	protected boolean RDBUPDRM_sent = false;	//We have sent that an update
0: 											// occurred in this transaction
0: 	protected boolean sendTRGDFTRT = false; // Send package target default value
1: 
0: 	private Connection conn;			// Connection to the database
0: 	private DRDAStatement defaultStatement; // default statement used 
0: 													   // for execute imm
0: 	private DRDAStatement currentStatement; // current statement we are working on
0: 	private Hashtable stmtTable;		// Hash table for storing statements
1: 
1: 
0: 	// constructor
0: 	/**
0: 	 * Database constructor
0: 	 * 
0: 	 * @param dbName	database name
0: 	 */
0: 	protected Database (String dbName)
0: 	{
0: 		this.dbName = dbName;
0: 		this.stmtTable = new Hashtable();
0: 		this.defaultStatement = new DRDAStatement(this);
0: 	}
0: 	/**
0: 	 * Set connection and create the SQL statement for the default statement
0: 	 *
0: 	 * @param conn Connection
0: 	 * @exception SQLException
0: 	 */
0: 	protected void setConnection(Connection conn)
0: 		throws SQLException
0: 	{
0: 		this.conn = conn;
0: 		defaultStatement.setStatement(conn);
0: 	}
0: 	/**
0: 	 * Get the connection
0: 	 *
0: 	 * @return connection
0: 	 */
0: 	protected Connection getConnection()
0: 	{
0: 		return conn;
0: 	}
0: 	/**
0: 	 * Get current DRDA statement 
0: 	 *
0: 	 * @return DRDAStatement
0: 	 * @exception SQLException
0: 	 */
0: 	protected DRDAStatement getCurrentStatement() 
0: 	{
0: 		return currentStatement;
0: 	}
0: 	/**
0: 	 * Get default statement for use in EXCIMM
0: 	 *
0: 	 * @return DRDAStatement
0: 	 */
0: 	protected DRDAStatement getDefaultStatement() 
0: 	{
0: 		currentStatement = defaultStatement;
0: 		return defaultStatement;
0: 	}
1: 
0: 	/**
0: 	 * Get default statement for use in EXCIMM with specified pkgnamcsn
0: 	 * The pkgnamcsn has the encoded isolation level
0: 	 *
0: 	 * @param pkgnamcsn package/ section # for statement
0: 	 * @return DRDAStatement
0: 	 */
0: 	protected DRDAStatement getDefaultStatement(String pkgnamcsn) 
0: 	{
0: 		currentStatement = defaultStatement;
0: 		currentStatement.setPkgnamcsn(pkgnamcsn);
0: 		return currentStatement;
0: 	}
1: 
0: 	/**
0: 	 * Get prepared statement based on pkgnamcsn
0: 	 *
0: 	 * @param pkgnamcsn - key to access statement
0: 	 * @return prepared statement
0: 	 */
0: 	protected PreparedStatement getPreparedStatement(String pkgnamcsn) 
0: 		throws SQLException
0: 	{
0: 		currentStatement = getDRDAStatement(pkgnamcsn);
0: 		if (currentStatement == null)
0: 			return null;
0: 		return currentStatement.getPreparedStatement();
0: 	}
1: 	
0: 	/**
0: 	 * Get a new DRDA statement and store it in the stmtTable if stortStmt is true
0: 	 * If possible recycle an existing statement
0: 	 * If we are asking for one with the same name it means it
0: 	 * was already closed.
0: 	 * @param pkgnamcsn  Package name and section
0: 	 * @return DRDAStatement  
0: 	 */
0: 	protected DRDAStatement newDRDAStatement(String pkgnamcsn)
0: 	throws SQLException
0: 	{
0: 		DRDAStatement stmt = getDRDAStatement(pkgnamcsn);
0: 		if (stmt != null)
0: 			stmt.close();
0: 		else
0: 		{
0: 			stmt = new DRDAStatement(this);
0: 			stmt.setPkgnamcsn(pkgnamcsn);
0: 			storeStatement(stmt);
0: 		}
0: 		return stmt;
0: 	}
1: 
0: 	/**
0: 	 * Get DRDA statement based on pkgnamcsn
0: 	 *
0: 	 * @param pkgnamcsn - key to access statement
0: 	 * @return DRDAStatement
0: 	 */
0: 	protected DRDAStatement getDRDAStatement(String pkgnamcsn) 
0: 		throws SQLException
0: 	{
0: 		// Need to get the short version because resultSets have different
0: 		// corelation ids.
0: 		String key = getStmtKey(pkgnamcsn);
0: 		DRDAStatement newStmt = null;
1: 
0: 		// If our current statement doesn't match,retrieve the statement
0: 		// and make it current if not null.
0: 		if (currentStatement == null || 
0: 			!key.equals(getStmtKey(currentStatement.getPkgnamcsn())));
0: 			{
0: 				newStmt  = (DRDAStatement) stmtTable.get(key);				
0: 			}
1: 			
0: 			if (newStmt != null)	 // don't blow away currentStatement if we can't find this one
0: 				currentStatement = newStmt;
0: 			else
0: 				return null;
1: 
0: 		// Set the correct result set.
0: 		currentStatement.setCurrentDrdaResultSet(pkgnamcsn);
0: 		return currentStatement;
0: 	}
1: 
0: 	/**
0: 	 * Get result set
0: 	 *
0: 	 * @param pkgnamcsn - key to access prepared statement
0: 	 * @return result set
0: 	 */
0: 	protected ResultSet getResultSet(String pkgnamcsn) throws SQLException
0: 	{
0: 		return getDRDAStatement(pkgnamcsn).getResultSet();
0: 	}
0: 	/**
0:  	 * Set result set
0: 	 *
0: 	 * @param value
0: 	 */
0: 	protected void setResultSet(ResultSet value) throws SQLException
0: 	{
0: 		currentStatement.setResultSet(value);
0: 	}
0: 	/**
0: 	 * Store DRDA prepared statement
0: 	 * @param  stmt	DRDA prepared statement
0: 	 */
0: 	protected void storeStatement(DRDAStatement stmt) throws SQLException
0: 	{
0: 		stmtTable.put(getStmtKey(stmt.getPkgnamcsn()), stmt);
0: 	}
1: 
0: 	protected void removeStatement(DRDAStatement stmt) throws SQLException
0: 	{
0: 		stmtTable.remove(stmt.getPkgnamcsn());
0: 		stmt.close();
0: 	}
1: 	
0: 	/**
0: 	 * Make statement the current statement
0: 	 * @param stmt
0: 	 *
0: 	 */
1: 
0: 	protected void setCurrentStatement(DRDAStatement stmt)
0: 	{
0: 		currentStatement = stmt;
0: 	}
1: 
1:    
0: 	protected void commit() throws SQLException
0: 	{
1: 		
0: 		if (conn != null)
0: 			conn.commit();
0: 	}
1: 
0: 	protected void rollback() throws SQLException
0: 	{
1: 		
0: 		if (conn != null)
0: 			conn.rollback();
0: 	}
0: 	/**
0: 	  * Close the connection and clean up the statement table
0: 	  * @throws SQLException on conn.close() error to be handled in DRDAConnThread.
0: 	  */
0: 	protected void close() throws SQLException
0: 	{
1: 
0: 		try {
0: 			if (stmtTable != null)
0: 			{
0: 				for (Enumeration e = stmtTable.elements() ; e.hasMoreElements() ;) 
0: 				{
0: 					((DRDAStatement) e.nextElement()).close();
0: 				}
1: 			
0: 			}
0: 			if (defaultStatement != null)			
0: 				defaultStatement.close();
0: 			if ((conn != null) && !conn.isClosed())
0: 			{
0: 				conn.rollback();
0: 				conn.close();
0: 			}
0: 		}
0: 		finally {
0: 			conn = null;
0: 			currentStatement = null;
0: 			defaultStatement = null;
0: 			stmtTable=null;
0: 		}
0: 	}
1: 
0: 	/**
0: 	 *  Set the internal isolation level to use for preparing statements.
0: 	 *  Subsequent prepares will use this isoalation level
0: 	 * @param internal isolation level 
0: 	 *
0: 	 * @throws SQLException
0: 	 * @see EmbedConnection#setPrepareIsolation
0: 	 * 
0: 	 */
0: 	protected void setPrepareIsolation(int level) throws SQLException
0: 	{
0: 		((EmbedConnection) conn).setPrepareIsolation(level);
0: 	}
1: 
0: 	protected int getPrepareIsolation() throws SQLException
0: 	{
0: 		return ((EmbedConnection) conn).getPrepareIsolation();
0: 	}
1: 
0: 	protected String buildRuntimeInfo(String indent, LocalizedResource localLangUtil)
0: 	{	
1: 	  
0: 		String s = indent + 
0: 		localLangUtil.getTextMessage("DRDA_RuntimeInfoDatabase.I") +
0: 			dbName + "\n" +  
0: 		localLangUtil.getTextMessage("DRDA_RuntimeInfoUser.I")  +
0: 			userId +  "\n" +
0: 		localLangUtil.getTextMessage("DRDA_RuntimeInfoNumStatements.I") +
0: 			stmtTable.size() + "\n";
0: 		s += localLangUtil.getTextMessage("DRDA_RuntimeInfoPreparedStatementHeader.I");
0: 		for (Enumeration e = stmtTable.elements() ; e.hasMoreElements() ;) 
0: 				{
0: 					s += ((DRDAStatement) e.nextElement()).toDebugString(indent
0: 																		 +"\t") +"\n";
0: 				}
0: 		return s;
0: 	}
1: 
1: 
0: 	private String getStmtKey(String pkgnamcsn)
0: 	{
0: 		if (pkgnamcsn == null)
0: 			return null;
0: 		return  pkgnamcsn.substring(0,pkgnamcsn.length() - CodePoint.PKGCNSTKN_LEN);
0: 	}
0: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:ee2a860
/////////////////////////////////////////////////////////////////////////
0: 	private Hashtable stmtTable;		// Hash table for storing statements
/////////////////////////////////////////////////////////////////////////
0: 	protected DRDAStatement getDefaultStatement(Pkgnamcsn pkgnamcsn) 
/////////////////////////////////////////////////////////////////////////
0: 	protected DRDAStatement newDRDAStatement(Pkgnamcsn pkgnamcsn)
/////////////////////////////////////////////////////////////////////////
0: 	protected DRDAStatement getDRDAStatement(Pkgnamcsn pkgnamcsn) {
0: 		DRDAStatement newStmt =
0: 			(DRDAStatement) stmtTable.get(pkgnamcsn.getStatementKey());
0: 		if (newStmt != null) {
0: 			currentStatement = newStmt;
0: 			currentStatement.setCurrentDrdaResultSet(pkgnamcsn);
0: 		}
0: 		return newStmt;
/////////////////////////////////////////////////////////////////////////
0: 		stmtTable.put(stmt.getPkgnamcsn().getStatementKey(), stmt);
0: 		stmtTable.remove(stmt.getPkgnamcsn().getStatementKey());
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: 
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.Statement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
0: 
0: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: /**
0: 	Database stores information about the current database
0: 	It is used so that a session may have more than one database
0: */
0: class Database
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: 
0: 	protected String dbName;			// database name 
0: 	protected int securityMechanism;	// Security mechanism
0: 	protected String userId;			// User Id
0: 	protected String password;			// password
0: 	protected String decryptedUserId;	// Decrypted User id
0: 	protected String decryptedPassword;	// Decrypted password
0: 	protected boolean rdbAllowUpdates = true; // Database allows updates -default is true		
0: 	protected int	accessCount;		// Number of times we have tried to
0: 										// set up access to this database (only 1 
0: 										// allowed)
0: 	protected byte[] publicKeyIn;		// Security token from app requester
0: 	protected byte[] publicKeyOut;		// Security token sent to app requester
0: 	protected byte[] crrtkn;			// Correlation token
0: 	protected String typDefNam;			// Type definition name
0: 	protected int byteOrder;			//deduced from typDefNam, save String comparisons
0: 	protected int ccsidSBC;				// Single byte CCSID
0: 	protected int ccsidDBC;				// Double byte CCSID
0: 	protected int ccsidMBC;				// Mixed byte CCSID
0: 	protected String ccsidSBCEncoding;	// Encoding for single byte code page
0: 	protected String ccsidDBCEncoding;	// Encoding for double byte code page
0: 	protected String ccsidMBCEncoding;	// Encoding for mixed byte code page
0: 	protected boolean RDBUPDRM_sent = false;	//We have sent that an update
0: 											// occurred in this transaction
0: 	protected boolean sendTRGDFTRT = false; // Send package target default value
0: 
0: 	private Connection conn;			// Connection to the database
0: 	private DRDAStatement defaultStatement; // default statement used 
0: 													   // for execute imm
0: 	private DRDAStatement currentStatement; // current statement we are working on
0: 	private Hashtable stmtTable;		// Hash table for storing statements
0: 
0: 
0: 	// constructor
0: 	/**
0: 	 * Database constructor
0: 	 * 
0: 	 * @param dbName	database name
0: 	 */
0: 	protected Database (String dbName)
0: 	{
0: 		this.dbName = dbName;
0: 		this.stmtTable = new Hashtable();
0: 		this.defaultStatement = new DRDAStatement(this);
0: 	}
0: 	/**
0: 	 * Set connection and create the SQL statement for the default statement
0: 	 *
0: 	 * @param conn Connection
0: 	 * @exception SQLException
0: 	 */
0: 	protected void setConnection(Connection conn)
0: 		throws SQLException
0: 	{
0: 		this.conn = conn;
0: 		defaultStatement.setStatement(conn);
0: 	}
0: 	/**
0: 	 * Get the connection
0: 	 *
0: 	 * @return connection
0: 	 */
0: 	protected Connection getConnection()
0: 	{
0: 		return conn;
0: 	}
0: 	/**
0: 	 * Get current DRDA statement 
0: 	 *
0: 	 * @return DRDAStatement
0: 	 * @exception SQLException
0: 	 */
0: 	protected DRDAStatement getCurrentStatement() 
0: 	{
0: 		return currentStatement;
0: 	}
0: 	/**
0: 	 * Get default statement for use in EXCIMM
0: 	 *
0: 	 * @return DRDAStatement
0: 	 */
0: 	protected DRDAStatement getDefaultStatement() 
0: 	{
0: 		currentStatement = defaultStatement;
0: 		return defaultStatement;
0: 	}
0: 
0: 	/**
0: 	 * Get default statement for use in EXCIMM with specified pkgnamcsn
0: 	 * The pkgnamcsn has the encoded isolation level
0: 	 *
0: 	 * @param pkgnamcsn package/ section # for statement
0: 	 * @return DRDAStatement
0: 	 */
0: 	protected DRDAStatement getDefaultStatement(String pkgnamcsn) 
0: 	{
0: 		currentStatement = defaultStatement;
0: 		currentStatement.setPkgnamcsn(pkgnamcsn);
0: 		return currentStatement;
0: 	}
0: 
0: 	/**
0: 	 * Get prepared statement based on pkgnamcsn
0: 	 *
0: 	 * @param pkgnamcsn - key to access statement
0: 	 * @return prepared statement
0: 	 */
0: 	protected PreparedStatement getPreparedStatement(String pkgnamcsn) 
0: 		throws SQLException
0: 	{
0: 		currentStatement = getDRDAStatement(pkgnamcsn);
0: 		if (currentStatement == null)
0: 			return null;
0: 		return currentStatement.getPreparedStatement();
0: 	}
0: 	
0: 	/**
0: 	 * Get a new DRDA statement and store it in the stmtTable if stortStmt is true
0: 	 * If possible recycle an existing statement
0: 	 * If we are asking for one with the same name it means it
0: 	 * was already closed.
0: 	 * @param pkgnamcsn  Package name and section
0: 	 * @return DRDAStatement  
0: 	 */
0: 	protected DRDAStatement newDRDAStatement(String pkgnamcsn)
0: 	throws SQLException
0: 	{
0: 		DRDAStatement stmt = getDRDAStatement(pkgnamcsn);
0: 		if (stmt != null)
0: 			stmt.close();
0: 		else
0: 		{
0: 			stmt = new DRDAStatement(this);
0: 			stmt.setPkgnamcsn(pkgnamcsn);
0: 			storeStatement(stmt);
0: 		}
0: 		return stmt;
0: 	}
0: 
0: 	/**
0: 	 * Get DRDA statement based on pkgnamcsn
0: 	 *
0: 	 * @param pkgnamcsn - key to access statement
0: 	 * @return DRDAStatement
0: 	 */
0: 	protected DRDAStatement getDRDAStatement(String pkgnamcsn) 
0: 		throws SQLException
0: 	{
0: 		// Need to get the short version because resultSets have different
0: 		// corelation ids.
0: 		String key = getStmtKey(pkgnamcsn);
0: 		DRDAStatement newStmt = null;
0: 
0: 		// If our current statement doesn't match,retrieve the statement
0: 		// and make it current if not null.
0: 		if (currentStatement == null || 
0: 			!key.equals(getStmtKey(currentStatement.getPkgnamcsn())));
0: 			{
0: 				newStmt  = (DRDAStatement) stmtTable.get(key);				
0: 			}
0: 			
0: 			if (newStmt != null)	 // don't blow away currentStatement if we can't find this one
0: 				currentStatement = newStmt;
0: 			else
0: 				return null;
0: 
0: 		// Set the correct result set.
0: 		currentStatement.setCurrentDrdaResultSet(pkgnamcsn);
0: 		return currentStatement;
0: 	}
0: 
0: 	/**
0: 	 * Get result set
0: 	 *
0: 	 * @param pkgnamcsn - key to access prepared statement
0: 	 * @return result set
0: 	 */
0: 	protected ResultSet getResultSet(String pkgnamcsn) throws SQLException
0: 	{
0: 		return getDRDAStatement(pkgnamcsn).getResultSet();
0: 	}
0: 	/**
0:  	 * Set result set
0: 	 *
0: 	 * @param value
0: 	 */
0: 	protected void setResultSet(ResultSet value) throws SQLException
0: 	{
0: 		currentStatement.setResultSet(value);
0: 	}
0: 	/**
0: 	 * Store DRDA prepared statement
0: 	 * @param  stmt	DRDA prepared statement
0: 	 */
0: 	protected void storeStatement(DRDAStatement stmt) throws SQLException
0: 	{
0: 		stmtTable.put(getStmtKey(stmt.getPkgnamcsn()), stmt);
0: 	}
0: 
0: 	protected void removeStatement(DRDAStatement stmt) throws SQLException
0: 	{
0: 		stmtTable.remove(stmt.getPkgnamcsn());
0: 		stmt.close();
0: 	}
0: 	
0: 	/**
0: 	 * Make statement the current statement
0: 	 * @param stmt
0: 	 *
0: 	 */
0: 
0: 	protected void setCurrentStatement(DRDAStatement stmt)
0: 	{
0: 		currentStatement = stmt;
0: 	}
0: 
0:    
0: 	protected void commit() throws SQLException
0: 	{
0: 		
0: 		if (conn != null)
0: 			conn.commit();
0: 	}
0: 
0: 	protected void rollback() throws SQLException
0: 	{
0: 		
0: 		if (conn != null)
0: 			conn.rollback();
0: 	}
0: 	/**
0: 	  * Close the connection and clean up the statement table
0: 	  * @throws SQLException on conn.close() error to be handled in DRDAConnThread.
0: 	  */
0: 	protected void close() throws SQLException
0: 	{
0: 
0: 		try {
0: 			if (stmtTable != null)
0: 			{
0: 				for (Enumeration e = stmtTable.elements() ; e.hasMoreElements() ;) 
0: 				{
0: 					((DRDAStatement) e.nextElement()).close();
0: 				}
0: 			
0: 			}
0: 			if (defaultStatement != null)			
0: 				defaultStatement.close();
0: 			if ((conn != null) && !conn.isClosed())
0: 			{
0: 				conn.rollback();
0: 				conn.close();
0: 			}
0: 		}
0: 		finally {
0: 			conn = null;
0: 			currentStatement = null;
0: 			defaultStatement = null;
0: 			stmtTable=null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 *  Set the internal isolation level to use for preparing statements.
0: 	 *  Subsequent prepares will use this isoalation level
0: 	 * @param internal isolation level 
0: 	 *
0: 	 * @throws SQLException
0: 	 * @see EmbedConnection#setPrepareIsolation
0: 	 * 
0: 	 */
0: 	protected void setPrepareIsolation(int level) throws SQLException
0: 	{
0: 		((EmbedConnection) conn).setPrepareIsolation(level);
0: 	}
0: 
0: 	protected int getPrepareIsolation() throws SQLException
0: 	{
0: 		return ((EmbedConnection) conn).getPrepareIsolation();
0: 	}
0: 
0: 	protected String buildRuntimeInfo(String indent, LocalizedResource localLangUtil)
0: 	{	
0: 	  
0: 		String s = indent + 
0: 		localLangUtil.getTextMessage("DRDA_RuntimeInfoDatabase.I") +
0: 			dbName + "\n" +  
0: 		localLangUtil.getTextMessage("DRDA_RuntimeInfoUser.I")  +
0: 			userId +  "\n" +
0: 		localLangUtil.getTextMessage("DRDA_RuntimeInfoNumStatements.I") +
0: 			stmtTable.size() + "\n";
0: 		s += localLangUtil.getTextMessage("DRDA_RuntimeInfoPreparedStatementHeader.I");
0: 		for (Enumeration e = stmtTable.elements() ; e.hasMoreElements() ;) 
0: 				{
0: 					s += ((DRDAStatement) e.nextElement()).toDebugString(indent
0: 																		 +"\t") +"\n";
0: 				}
0: 		return s;
0: 	}
0: 
0: 
0: 	private String getStmtKey(String pkgnamcsn)
0: 	{
0: 		if (pkgnamcsn == null)
0: 			return null;
0: 		return  pkgnamcsn.substring(0,pkgnamcsn.length() - CodePoint.PKGCNSTKN_LEN);
0: 	}
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================