1:89d3ce5: /*
1:d36746b: 
1:768e56f:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.TestDbMetaData
1:e423333: 
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:5d66268: 
1:89d3ce5:       http://www.apache.org/licenses/LICENSE-2.0
1:533d502: 
1:89d3ce5:    Unless required by applicable law or agreed to in writing, software
1:89d3ce5:    distributed under the License is distributed on an "AS IS" BASIS,
1:89d3ce5:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:89d3ce5:    See the License for the specific language governing permissions and
1:89d3ce5:    limitations under the License.
6:d36746b: 
3:89d3ce5:  */
1:63170fc: 
1:89d3ce5: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:d36746b: 
1:89d3ce5: import java.sql.DatabaseMetaData;
1:3bfb5f0: import java.sql.PreparedStatement;
1:89d3ce5: import java.sql.ResultSet;
1:89d3ce5: import java.sql.SQLException;
1:89d3ce5: import java.sql.Statement;
1:768e56f: import java.sql.Types;
1:5d66268: import junit.framework.Test;
1:3bfb5f0: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1:5d66268: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:5d66268: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:5d66268: import org.apache.derbyTesting.junit.JDBC;
1:ec5ae26: import org.apache.derbyTesting.junit.TestConfiguration;
1:5d66268: 
1:d36746b: /**
1:63170fc:  * Test of database metadata for new methods in JDBC 40.
1:d36746b:  */
1:5d66268: public class TestDbMetaData extends BaseJDBCTestCase {
1:768e56f: 
1:39b3237:     private static  final   Integer FUNCTION_NO_TABLE_VALUE = DatabaseMetaData.functionNoTable;
1:63170fc:     
1:5d66268:     private DatabaseMetaData meta;
1:63170fc: 
1:5d66268:     public TestDbMetaData(String name) {
1:5d66268:         super(name);
1:cd90315:     }
1:e423333: 
1:5d66268:     protected void setUp() throws SQLException {
1:5d66268:         meta = getConnection().getMetaData();
1:3bfb5f0:     }
1:e423333: 
1:5d66268:     protected void tearDown() throws Exception {
1:5d66268:         meta = null;
1:5d66268:         super.tearDown();
1:5d66268:     }
1:e423333: 
1:5d66268:     private static void createFunctions(Statement s) throws SQLException {
1:63170fc:         // Create some functions in the default schema (app) to make
1:ebdced0:         // the output from getFunctions() and getFunctionColumns
1:63170fc:         // more interesting
1:502d667:         s.execute("CREATE FUNCTION DUMMY1 ( X SMALLINT ) RETURNS SMALLINT "+
1:502d667:                   "PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA EXTERNAL "+
1:502d667:                   "NAME 'java.some.func'");
1:502d667:         s.execute("CREATE FUNCTION DUMMY2 ( X INTEGER, Y SMALLINT ) RETURNS"+
1:502d667:                   " INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA "+
1:502d667:                   "EXTERNAL NAME 'java.some.func'");
1:502d667:         s.execute("CREATE FUNCTION DUMMY3 ( X VARCHAR(16), Y INTEGER ) "+
1:502d667:                   "RETURNS VARCHAR(16) PARAMETER STYLE JAVA NO SQL LANGUAGE"+
1:502d667:                   " JAVA EXTERNAL NAME 'java.some.func'");
1:502d667:         s.execute("CREATE FUNCTION DUMMY4 ( X VARCHAR(128), Y INTEGER ) "+
1:502d667:                   "RETURNS INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE "+
1:502d667:                   "JAVA EXTERNAL NAME 'java.some.func'");
1:a6b18af:         s.execute("CREATE FUNCTION DUMMY5 ( X BOOLEAN ) "+
1:a6b18af:                   "RETURNS BOOLEAN PARAMETER STYLE JAVA NO SQL LANGUAGE "+
1:a6b18af:                   "JAVA EXTERNAL NAME 'java.some.func'");
1:5d66268:     }
1:3bfb5f0: 
1:ec5ae26:     private static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite testSuite = new BaseTestSuite(name);
1:5d66268:         testSuite.addTestSuite(TestDbMetaData.class);
1:5d66268:         return new CleanDatabaseTestSetup(testSuite) {
1:5d66268:                 protected void decorateSQL(Statement s) throws SQLException {
1:5d66268:                     createFunctions(s);
1:5d66268:                 }
3:5d66268:             };
1:5d66268:     }
1:3bfb5f0: 
1:ec5ae26:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("TestDbMetaData suite");
1:ec5ae26:         suite.addTest(baseSuite("TestDbMetaData:embedded"));
1:ec5ae26:         suite.addTest(TestConfiguration.clientServerDecorator(
1:ec5ae26:             baseSuite("TestDbMetaData:client")));
1:ec5ae26:         return suite;
1:ec5ae26:     }
1:3bfb5f0: 
1:5d66268:     public void testSupportsStoredFunctionsUsingCallSyntax()
1:5d66268:             throws SQLException {
1:5d66268:         assertTrue(meta.supportsStoredFunctionsUsingCallSyntax());
1:5d66268:     }
1:3bfb5f0: 
1:5d66268:     public void testAutoCommitFailureClosesAllResultSets() throws SQLException {
1:cd90315:         if (usingEmbedded()) {
1:cd90315:             assertTrue(meta.autoCommitFailureClosesAllResultSets());
1:cd90315:         } else {
1:cd90315:             assertFalse(meta.autoCommitFailureClosesAllResultSets());
1:cd90315:         }
1:5d66268:     }
1:3bfb5f0: 
1:5d66268:     public void testGetClientInfoProperties() throws SQLException {
1:5d66268:         ResultSet rs = meta.getClientInfoProperties();
1:35bdb15:         JDBC.assertDatabaseMetaDataColumns(rs, null, new String[] {
1:5d66268:             "NAME", "MAX_LEN", "DEFAULT_VALUE", "DESCRIPTION" });
1:3f677d1:         JDBC.assertEmpty(rs);
1:5d66268:     }
1:502d667: 
1:3bfb5f0:     /**
1:5d66268:      * Since JDBC40Translation cannot be accessed in queries in
1:5d66268:      * metadata.properties, the query has to use
1:5d66268:      * DatabaseMetaData.procedureNullable. Hence it is necessary
1:5d66268:      * to verify that that value of
1:5d66268:      * DatabaseMetaData.functionNullable is the same.
1:3bfb5f0:      */
1:5d66268:     public void testFunctionNullable() {
1:5d66268:         assertEquals(DatabaseMetaData.procedureNullable,
1:5d66268:                      DatabaseMetaData.functionNullable);
1:5d66268:     }
1:502d667: 
1:5d66268:     /** Check that the column names are as expected from getFunctions(). */
1:5d66268:     private void assertGetFunctionsRs(ResultSet rs) throws SQLException {
1:35bdb15:         int[] ColTypes = new int[] {
1:768e56f:                 Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR,
1:35bdb15:                 Types.SMALLINT, Types.VARCHAR };
1:35bdb15:         JDBC.assertDatabaseMetaDataColumns(rs, ColTypes, new String[] {
1:5d66268:             "FUNCTION_CAT", "FUNCTION_SCHEM", "FUNCTION_NAME", "REMARKS",
1:768e56f:             "FUNCTION_TYPE", "SPECIFIC_NAME" });
1:5d66268:     }
1:ec5ae26:     
1:d753aef:     private static final JDBC.GeneratedId GENERIC_NAME = new JDBC.GeneratedId();
1:5d66268: 
1:5d66268:     /** Expected rows from getFunctions() when all functions match. */
1:5d66268:     private static final Object[][] ALL_FUNCTIONS = {
1:768e56f:         { null, "APP", "DUMMY1", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:768e56f:         { null, "APP", "DUMMY2", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:768e56f:         { null, "APP", "DUMMY3", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:768e56f:         { null, "APP", "DUMMY4", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:a6b18af:         { null, "APP", "DUMMY5", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
2:5d66268:         { null, "SYSCS_UTIL", "SYSCS_CHECK_TABLE",
2:5d66268:           "org.apache.derby.catalog.SystemProcedures.SYSCS_CHECK_TABLE",
1:768e56f:           FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:314a19a:         { null, "SYSCS_UTIL", "SYSCS_GET_DATABASE_NAME",
1:314a19a:           "org.apache.derby.catalog.SystemProcedures." +
1:314a19a:           "SYSCS_GET_DATABASE_NAME", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
3:5d66268:         { null, "SYSCS_UTIL", "SYSCS_GET_DATABASE_PROPERTY",
5:5d66268:           "org.apache.derby.catalog.SystemProcedures." +
1:768e56f:           "SYSCS_GET_DATABASE_PROPERTY", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
3:5d66268:         { null, "SYSCS_UTIL", "SYSCS_GET_RUNTIMESTATISTICS",
1:5d66268:           "org.apache.derby.catalog.SystemProcedures." +
1:768e56f:           "SYSCS_GET_RUNTIMESTATISTICS", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:d54fabd:         { null, "SYSCS_UTIL", "SYSCS_GET_USER_ACCESS",
1:d54fabd:           "org.apache.derby.catalog.SystemProcedures." +
1:768e56f:           "SYSCS_GET_USER_ACCESS", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:d54fabd:         { null, "SYSCS_UTIL", "SYSCS_GET_XPLAIN_MODE",
1:d54fabd:           "org.apache.derby.catalog.SystemProcedures." +
1:d54fabd:           "SYSCS_GET_XPLAIN_MODE", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:d54fabd:         { null, "SYSCS_UTIL", "SYSCS_GET_XPLAIN_SCHEMA",
1:d54fabd:           "org.apache.derby.catalog.SystemProcedures." +
1:d54fabd:           "SYSCS_GET_XPLAIN_SCHEMA", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:7fd0c6e:         { null, "SYSCS_UTIL", "SYSCS_PEEK_AT_IDENTITY",
1:7fd0c6e:           "org.apache.derby.catalog.SystemProcedures." +
1:7fd0c6e:           "SYSCS_PEEK_AT_IDENTITY", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:8e352d6:         { null, "SYSCS_UTIL", "SYSCS_PEEK_AT_SEQUENCE",
1:8e352d6:           "org.apache.derby.catalog.SystemProcedures." +
1:8e352d6:           "SYSCS_PEEK_AT_SEQUENCE", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "BLOBCREATELOCATOR",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "BLOBCREATELOCATOR", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "BLOBGETBYTES",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "BLOBGETBYTES", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "BLOBGETLENGTH",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "BLOBGETLENGTH", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "BLOBGETPOSITIONFROMBYTES",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "BLOBGETPOSITIONFROMBYTES", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "BLOBGETPOSITIONFROMLOCATOR",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "BLOBGETPOSITIONFROMLOCATOR", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "CLOBCREATELOCATOR",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "CLOBCREATELOCATOR", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "CLOBGETLENGTH",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "CLOBGETLENGTH", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "CLOBGETPOSITIONFROMLOCATOR",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "CLOBGETPOSITIONFROMLOCATOR", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "CLOBGETPOSITIONFROMSTRING",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "CLOBGETPOSITIONFROMSTRING", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:6aa0b12:         { null, "SYSIBM", "CLOBGETSUBSTRING",
1:6aa0b12:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
1:768e56f:           "CLOBGETSUBSTRING", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:5d66268: 
1:5d66268:     };
1:5d66268: 
1:5d66268:     public void testGetFunctionsNullNullNull() throws SQLException {
1:502d667:         // Any function in any schema in any catalog
1:5d66268:         ResultSet rs = meta.getFunctions(null, null, null);
1:5d66268:         assertGetFunctionsRs(rs);
1:5d66268:         JDBC.assertFullResultSet(rs, ALL_FUNCTIONS, false);
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetFunctionsDummySchema() throws SQLException {
1:502d667:         // Any function in any schema in "Dummy
1:502d667:         // Catalog". Same as above since the catalog
1:502d667:         // argument is ignored (is always null)
1:5d66268:         ResultSet rs = meta.getFunctions("Dummy Catalog", null, null);
1:5d66268:         assertGetFunctionsRs(rs);
1:5d66268:         JDBC.assertFullResultSet(rs, ALL_FUNCTIONS, false);
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetFunctionsFromSysSchemas() throws SQLException {
1:63170fc:         
1:d36746b:         getSysFunctions();
1:502d667:         // Any function in a schema starting with "SYS"
1:5d66268:         ResultSet rs = meta.getFunctions(null, "SYS%", null);
1:5d66268:         assertGetFunctionsRs(rs);
1:d36746b:         JDBC.assertFullResultSet(rs, getSysFunctions(), false);
1:5d66268:     }
1:5d66268:     
1:3bfb5f0:     /**
1:d36746b:      * From the list of all functions extract the ones in schemas
1:d36746b:      * starting with SYS.
1:f658f85:       */
1:d36746b:     private static Object[][] getSysFunctions()
1:f658f85:     {
1:d36746b:         int n = 0;
1:d36746b:         for (int i = 0; i < ALL_FUNCTIONS.length; i++)
1:f658f85:         {
1:d36746b:             String schema = (String) ALL_FUNCTIONS[i][1];
1:d36746b:             if (schema.startsWith("SYS"))
1:d36746b:                 n++;
1:5d66268:         }
1:21350fd:         
1:d36746b:         Object[][] sysFunctions = new Object[n][];
1:d36746b:         n = 0;
1:d36746b:         for (int i = 0; i < ALL_FUNCTIONS.length; i++)
1:63170fc:         {
1:d36746b:             String schema = (String) ALL_FUNCTIONS[i][1];
1:d36746b:             if (schema.startsWith("SYS"))
1:d36746b:                 sysFunctions[n++] = ALL_FUNCTIONS[i];
1:5d66268:         }        
1:21350fd:                
1:d36746b:         return sysFunctions;
3:f658f85:     }
1:5d66268:     
1:f658f85:     /**
1:d36746b:      * From the list of all functions extract the ones with GET in the name.
1:d36746b:      * This assumes this test does not create functions with GET.
1:d36746b:       */
1:d36746b:     private static Object[][] getGetFunctions()
4:d36746b:     {
1:d36746b:         int n = 0;
1:d36746b:         for (int i = 0; i < ALL_FUNCTIONS.length; i++)
1:d36746b:         {
1:d36746b:             String name = (String) ALL_FUNCTIONS[i][2];
1:d36746b:             if (name.indexOf("GET") != -1)
1:d36746b:                 n++;
1:f658f85:         }
1:5d66268:         
1:d36746b:         Object[][] getFunctions = new Object[n][];
1:d36746b:         n = 0;
1:d36746b:         for (int i = 0; i < ALL_FUNCTIONS.length; i++)
1:d36746b:         {
1:d36746b:             String name = (String) ALL_FUNCTIONS[i][2];
1:d36746b:             if (name.indexOf("GET") != -1)
1:d36746b:                 getFunctions[n++] = ALL_FUNCTIONS[i];
1:f658f85:         }        
1:63170fc:                
1:d36746b:         return getFunctions;
1:f658f85:     }
1:d36746b:     
1:d36746b: 
1:5d66268:     public void testGetFunctionsContainingGET() throws SQLException {
1:502d667:         // All functions containing "GET" in any schema 
1:502d667:         // (and any catalog)
1:5d66268:         ResultSet rs = meta.getFunctions(null, null, "%GET%");
1:5d66268:         assertGetFunctionsRs(rs);
1:d36746b:         JDBC.assertFullResultSet(rs, getGetFunctions(), false);
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetFunctionsNoSchemaNoCatalog() throws SQLException {
1:502d667:         // Any function that belongs to NO schema and 
1:502d667:         // NO catalog (none)
1:5d66268:         ResultSet rs = meta.getFunctions("", "", null);
1:5d66268:         assertGetFunctionsRs(rs);
1:3f677d1:         JDBC.assertEmpty(rs);
1:5d66268:     }
1:e423333: 
1:5d66268:     /** Check that the column names are as expected from
1:5d66268:      * getFunctionColumns(). */
1:5d66268:     private void assertGetFunctionColumnsRs(ResultSet rs) throws SQLException {
1:35bdb15:         JDBC.assertDatabaseMetaDataColumns(rs, null, new String[] {
1:5d66268:             "FUNCTION_CAT", "FUNCTION_SCHEM", "FUNCTION_NAME", "COLUMN_NAME",
1:5d66268:             "COLUMN_TYPE", "DATA_TYPE", "TYPE_NAME", "PRECISION", "LENGTH",
1:5d66268:             "SCALE", "RADIX", "NULLABLE", "REMARKS", "CHAR_OCTET_LENGTH",
1:5d66268:             "ORDINAL_POSITION", "IS_NULLABLE", "SPECIFIC_NAME",
1:5d66268:             "METHOD_ID", "PARAMETER_ID"
1:5d66268:         });
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetFunctionColumnsStartingWithDUMMY() throws SQLException {
1:ebdced0: 		// Test getFunctionColumns
1:5d66268:         // Dump parameters for all functions beginning with DUMMY
1:5d66268:         ResultSet rs = meta.getFunctionColumns(null, null, "DUMMY%", null);
1:5d66268:         assertGetFunctionColumnsRs(rs);
1:5d66268:         Object[][] expectedRows = {
1:39b3237:             { null, "APP", "DUMMY1", "", 4, 5,
1:39b3237:               "SMALLINT", 5, 2, 0,
1:39b3237:               10, 1, null, null, 0,
1:39b3237:               "YES", GENERIC_NAME, 1, -1 },
1:39b3237:             { null, "APP", "DUMMY1", "X", 1, 5,
1:39b3237:               "SMALLINT", 5, 2, 0,
1:39b3237:               10, 1, null, null, 1,
1:39b3237:               "YES", GENERIC_NAME, 1, 0 },
1:39b3237:             { null, "APP", "DUMMY2", "", 4, 4,
1:39b3237:               "INTEGER", 10, 4, 0,
1:39b3237:               10, 1, null, null, 0,
1:39b3237:               "YES", GENERIC_NAME, 2, -1 },
1:39b3237:             { null, "APP", "DUMMY2", "X", 1, 4,
1:39b3237:               "INTEGER", 10, 4, 0,
1:39b3237:               10, 1, null, null, 1,
1:39b3237:               "YES", GENERIC_NAME, 2, 0 },
1:39b3237:             { null, "APP", "DUMMY2", "Y", 1, 5,
1:39b3237:               "SMALLINT", 5, 2, 0,
1:39b3237:               10, 1, null, null, 2,
1:39b3237:               "YES", GENERIC_NAME, 2, 1 },
1:39b3237:             { null, "APP", "DUMMY3", "", 4, 12,
1:39b3237:               "VARCHAR", 16, 32, null, null,
1:39b3237:               1, null, 32, 0, "YES",
1:39b3237:               GENERIC_NAME, 2, -1 },
1:39b3237:             { null, "APP", "DUMMY3", "X", 1, 12,
1:39b3237:               "VARCHAR", 16, 32, null, null,
1:39b3237:               1, null, 32, 1, "YES",
1:39b3237:               GENERIC_NAME, 2, 0 },
1:39b3237:             { null, "APP", "DUMMY3", "Y", 1, 4,
1:39b3237:               "INTEGER", 10, 4, 0,
1:39b3237:               10, 1, null, null, 2,
1:39b3237:               "YES", GENERIC_NAME, 2, 1 },
1:39b3237:             { null, "APP", "DUMMY4", "", 4, 4,
1:39b3237:               "INTEGER", 10, 4, 0,
1:39b3237:               10, 1, null, null, 0,
1:39b3237:               "YES", GENERIC_NAME, 2, -1 },
1:39b3237:             { null, "APP", "DUMMY4", "X", 1, 12,
1:39b3237:               "VARCHAR", 128, 256,
1:39b3237:               null, null, 1, null, 256, 1, "YES",
1:d36746b:               GENERIC_NAME,
1:39b3237:               2, 0 },
1:39b3237:             { null, "APP", "DUMMY4", "Y", 1, 4,
1:39b3237:               "INTEGER", 10, 4, 0,
1:39b3237:               10, 1, null, null, 2,
1:39b3237:               "YES", GENERIC_NAME, 2, 1 },
1:39b3237:             { null, "APP", "DUMMY5", "", 4, 16,
1:39b3237:               "BOOLEAN", 1, 1, null,
1:39b3237:               null, 1, null, null, 0,
1:39b3237:               "YES", GENERIC_NAME, 1, -1 },
1:39b3237:             { null, "APP", "DUMMY5", "X", 1, 16,
1:39b3237:               "BOOLEAN", 1, 1, null,
1:39b3237:               null, 1, null, null, 1,
1:39b3237:               "YES", GENERIC_NAME, 1, 0 },
1:5d66268:         };
1:5d66268:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetFunctionColumnsForDummyFunctions() throws SQLException {
1:e423333: 		// Dump return value for all DUMMY functions
1:5d66268:         ResultSet rs = meta.getFunctionColumns(null, null, "DUMMY%", "");
1:5d66268:         assertGetFunctionColumnsRs(rs);
1:5d66268:         Object[][] expectedRows = {
1:39b3237:             { null, "APP", "DUMMY1", "", 4, 5,
1:39b3237:               "SMALLINT", 5, 2, 0,
1:39b3237:               10, 1, null, null, 0,
1:39b3237:               "YES", GENERIC_NAME, 1, -1 },
1:39b3237:             { null, "APP", "DUMMY2", "", 4, 4,
1:39b3237:               "INTEGER", 10, 4, 0,
1:39b3237:               10, 1, null, null, 0,
1:39b3237:               "YES", GENERIC_NAME, 2, -1 },
1:39b3237:             { null, "APP", "DUMMY3", "", 4, 12,
1:39b3237:               "VARCHAR", 16, 32,
1:39b3237:               null, null, 1, null, 32, 0, "YES",
1:d36746b:               GENERIC_NAME,
1:39b3237:               2, -1 },
1:39b3237:             { null, "APP", "DUMMY4", "", 4, 4,
1:39b3237:               "INTEGER", 10, 4, 0,
1:39b3237:               10, 1, null, null, 0,
1:39b3237:               "YES", GENERIC_NAME, 2, -1 },
1:39b3237:             { null, "APP", "DUMMY5", "", 4, 16,
1:39b3237:               "BOOLEAN", 1, 1, null,
1:39b3237:               null, 1, null, null, 0,
1:39b3237:               "YES", GENERIC_NAME, 1, -1 },
1:5d66268:         };
1:5d66268:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:5d66268:     }
1:e423333: 
1:5d66268:     /** Check that the column names are as expected from getSchemas(). */
1:5d66268:     private void assertGetSchemasRs(ResultSet rs) throws SQLException {
1:35bdb15:         JDBC.assertDatabaseMetaDataColumns(rs, null, new String[] {
1:5d66268:             "TABLE_SCHEM", "TABLE_CATALOG" });
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetSchemasNullNull() throws SQLException {
1:5d66268:         // Test the new getSchemas() with no schema qualifiers
1:5d66268:         ResultSet rs = meta.getSchemas(null, null);
1:5d66268:         assertGetSchemasRs(rs);
1:5d66268:         Object[][] expectedRows = {
1:5d66268:             { "APP", null },
1:5d66268:             { "NULLID", null },
1:5d66268:             { "SQLJ", null },
1:5d66268:             { "SYS", null },
1:5d66268:             { "SYSCAT", null },
1:5d66268:             { "SYSCS_DIAG", null },
1:5d66268:             { "SYSCS_UTIL", null },
1:5d66268:             { "SYSFUN", null },
1:5d66268:             { "SYSIBM", null },
1:5d66268:             { "SYSPROC", null },
1:5d66268:             { "SYSSTAT", null },
1:5d66268:         };
1:5d66268:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetSchemasStartingWithSYS() throws SQLException {
1:5d66268:         // Test the new getSchemas() with a schema wildcard qualifier
1:5d66268:         ResultSet rs = meta.getSchemas(null, "SYS%");
1:5d66268:         assertGetSchemasRs(rs);
1:5d66268:         Object[][] expectedRows = {
1:5d66268:             { "SYS", null },
1:5d66268:             { "SYSCAT", null },
1:5d66268:             { "SYSCS_DIAG", null },
1:5d66268:             { "SYSCS_UTIL", null },
1:5d66268:             { "SYSFUN", null },
1:5d66268:             { "SYSIBM", null },
1:5d66268:             { "SYSPROC", null },
1:5d66268:             { "SYSSTAT", null },
1:5d66268:         };
1:5d66268:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetSchemasMatchingAPP() throws SQLException {
1:5d66268:         // Test the new getSchemas() with an exact match
1:5d66268:         ResultSet rs = meta.getSchemas(null, "APP");
1:5d66268:         assertGetSchemasRs(rs);
1:5d66268:         Object[][] expectedRows = {
1:5d66268:             { "APP", null },
1:5d66268:         };
1:5d66268:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:5d66268:     }
1:5d66268: 
1:5d66268:     public void testGetSchemasMatchingBLAH() throws SQLException {
1:5d66268:         // Make sure that getSchemas() returns an empty result
1:5d66268:         // set when a schema is passed with no match
1:5d66268:         ResultSet rs = meta.getSchemas(null, "BLAH");
1:5d66268:         assertGetSchemasRs(rs);
1:3f677d1:         JDBC.assertEmpty(rs);
1:5d66268:     }
1:5d66268: 
1:d36746b:     /**
1:f658f85:      * Test supportsStoredFunctionsUsingCallSyntax() by checking
1:f658f85:      * whether calling a stored procedure using the escape syntax
1:f658f85:      * succeeds.
1:3bfb5f0:      *
1:f658f85:      * @exception SQLException if an unexpected database error occurs
1:3bfb5f0:      */
1:5d66268:     public void testStoredProcEscapeSyntax() throws SQLException {
1:5d66268:         getConnection().setAutoCommit(false);
1:f658f85:         String call = "{CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)}";
1:5d66268:         Statement stmt = createStatement();
1:3bfb5f0: 
1:f658f85:         boolean success;
1:3bfb5f0:         try {
1:f658f85:             stmt.execute(call);
1:f658f85:             success = true;
1:f658f85:         } catch (SQLException e) {
1:f658f85:             success = false;
1:3bfb5f0:         }
1:3bfb5f0: 
1:5d66268:         assertEquals("supportsStoredFunctionsUsingCallSyntax() returned " +
1:5d66268:                      "value which doesn't match actual behaviour.",
1:5d66268:                      success, meta.supportsStoredFunctionsUsingCallSyntax());
1:3bfb5f0: 
1:f658f85:         stmt.close();
1:3bfb5f0:     }
1:3bfb5f0: 
1:f658f85:     /**
1:f658f85:      * Test autoCommitFailureClosesAllResultSets() by checking whether
1:f658f85:      * a failure in auto-commit mode will close all result sets, even
1:f658f85:      * holdable ones.
2:f658f85:      *
1:f658f85:      * @exception SQLException if an unexpected database error occurs
1:f658f85:      */
1:5d66268:     public void testAutoCommitFailure() throws SQLException {
1:3bfb5f0: 
1:cd90315:         // IMPORTANT: use auto-commit
1:cd90315:         getConnection().setAutoCommit(true);
1:5d66268: 
1:cd90315:         ResultSet[] rss = new ResultSet[2];
1:cd90315:         // Use different statements so that both result sets are kept open
1:cd90315:         rss[0] = createStatement().executeQuery("VALUES 1, 2, 3, 4");
1:cd90315:         rss[1] = createStatement().executeQuery(
1:cd90315:                 "SELECT * FROM SYSIBM.SYSDUMMY1");
1:cd90315: 
1:cd90315:         // We want to test holdable result sets
1:cd90315:         for (ResultSet rs : rss) {
1:cd90315:             assertEquals("ResultSet should be holdable",
1:cd90315:                          ResultSet.HOLD_CURSORS_OVER_COMMIT,
1:cd90315:                          rs.getHoldability());
1:3bfb5f0:         }
1:cd90315: 
1:3bfb5f0:         try {
1:f658f85:             String query =
1:f658f85:                 "SELECT dummy, nonexistent, phony FROM imaginarytable34521";
1:cd90315:             // Create a new statement so we don't close any of the open result
1:cd90315:             // sets by re-executing a statement.
1:cd90315:             createStatement().execute(query);
1:5d66268:             fail("Query didn't fail.");
1:f658f85:         } catch (SQLException e) {
1:f658f85:             // should fail, but we don't care how
1:3bfb5f0:         }
1:f658f85: 
1:cd90315:         int closedResultSets = 0;
1:cd90315:         for (ResultSet rs : rss) {
1:cd90315:             // check if an operation fails with "ResultSet is closed"
1:cd90315:             try {
1:cd90315:                 rs.next();
1:cd90315:                 // OK, didn't fail, ResultSet wasn't closed
1:cd90315:             } catch (SQLException sqle) {
1:cd90315:                 assertSQLState("XCL16", sqle);
1:c9687fc:                 // DERBY-4767, sample verification test for operation in XCL16 message.
1:c9687fc:                 assertTrue(sqle.getMessage().indexOf("next") > 0);
1:cd90315:                 // OK, ResultSet is closed, increase counter
1:cd90315:                 closedResultSets++;
1:3bfb5f0:             }
1:3bfb5f0:         }
1:cd90315: 
1:cd90315:         boolean allResultSetsWereClosed = (closedResultSets == rss.length);
1:cd90315: 
1:5d66268:         assertEquals("autoCommitFailureClosesAllResultSets() returned value " +
1:5d66268:                      "which doesn't match actual behaviour.",
1:cd90315:                      allResultSetsWereClosed,
1:5d66268:                      meta.autoCommitFailureClosesAllResultSets());
1:5d66268: 
1:cd90315:         for (ResultSet rs : rss) {
1:cd90315:             rs.close();
1:3bfb5f0:         }
1:3bfb5f0:     }
1:f658f85: 
1:5d66268:     public void testIsWrapperForPositive() throws SQLException {
1:5d66268:         assertTrue("DatabaseMetaData should be wrapper for itself.",
1:5d66268:                    meta.isWrapperFor(DatabaseMetaData.class));
1:3bfb5f0:     }
1:f658f85: 
1:5d66268:     public void testIsWrapperForNegative() throws SQLException {
1:5d66268:         assertFalse("DatabaseMetaData should not wrap PreparedStatement.",
1:5d66268:                     meta.isWrapperFor(PreparedStatement.class));
1:3bfb5f0:     }
1:f658f85: 
1:5d66268:     public void testGetWrapperPositive() throws SQLException {
1:5d66268:         DatabaseMetaData dmd = meta.unwrap(DatabaseMetaData.class);
1:5d66268:         assertSame("Unwrap should return same object.", meta, dmd);
1:cd90315:     }
1:f658f85: 
1:5d66268:     public void testGetWrapperNegative() {
1:5d66268:         try {
1:5d66268:             PreparedStatement ps = meta.unwrap(PreparedStatement.class);
1:5d66268:             fail("Unwrap should not return PreparedStatement.");
1:5d66268:         } catch (SQLException e) {
1:5d66268:             assertSQLState(SQLStateConstants.UNABLE_TO_UNWRAP, e);
1:cd90315:         }
1:cd90315:     }
1:f658f85: 
1:5d66268: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:     private static  final   Integer FUNCTION_NO_TABLE_VALUE = DatabaseMetaData.functionNoTable;
/////////////////////////////////////////////////////////////////////////
1:             { null, "APP", "DUMMY1", "", 4, 5,
1:               "SMALLINT", 5, 2, 0,
1:               10, 1, null, null, 0,
1:               "YES", GENERIC_NAME, 1, -1 },
1:             { null, "APP", "DUMMY1", "X", 1, 5,
1:               "SMALLINT", 5, 2, 0,
1:               10, 1, null, null, 1,
1:               "YES", GENERIC_NAME, 1, 0 },
1:             { null, "APP", "DUMMY2", "", 4, 4,
1:               "INTEGER", 10, 4, 0,
1:               10, 1, null, null, 0,
1:               "YES", GENERIC_NAME, 2, -1 },
1:             { null, "APP", "DUMMY2", "X", 1, 4,
1:               "INTEGER", 10, 4, 0,
1:               10, 1, null, null, 1,
1:               "YES", GENERIC_NAME, 2, 0 },
1:             { null, "APP", "DUMMY2", "Y", 1, 5,
1:               "SMALLINT", 5, 2, 0,
1:               10, 1, null, null, 2,
1:               "YES", GENERIC_NAME, 2, 1 },
1:             { null, "APP", "DUMMY3", "", 4, 12,
1:               "VARCHAR", 16, 32, null, null,
1:               1, null, 32, 0, "YES",
1:               GENERIC_NAME, 2, -1 },
1:             { null, "APP", "DUMMY3", "X", 1, 12,
1:               "VARCHAR", 16, 32, null, null,
1:               1, null, 32, 1, "YES",
1:               GENERIC_NAME, 2, 0 },
1:             { null, "APP", "DUMMY3", "Y", 1, 4,
1:               "INTEGER", 10, 4, 0,
1:               10, 1, null, null, 2,
1:               "YES", GENERIC_NAME, 2, 1 },
1:             { null, "APP", "DUMMY4", "", 4, 4,
1:               "INTEGER", 10, 4, 0,
1:               10, 1, null, null, 0,
1:               "YES", GENERIC_NAME, 2, -1 },
1:             { null, "APP", "DUMMY4", "X", 1, 12,
1:               "VARCHAR", 128, 256,
1:               null, null, 1, null, 256, 1, "YES",
1:               2, 0 },
1:             { null, "APP", "DUMMY4", "Y", 1, 4,
1:               "INTEGER", 10, 4, 0,
1:               10, 1, null, null, 2,
1:               "YES", GENERIC_NAME, 2, 1 },
1:             { null, "APP", "DUMMY5", "", 4, 16,
1:               "BOOLEAN", 1, 1, null,
1:               null, 1, null, null, 0,
1:               "YES", GENERIC_NAME, 1, -1 },
1:             { null, "APP", "DUMMY5", "X", 1, 16,
1:               "BOOLEAN", 1, 1, null,
1:               null, 1, null, null, 1,
1:               "YES", GENERIC_NAME, 1, 0 },
/////////////////////////////////////////////////////////////////////////
1:             { null, "APP", "DUMMY1", "", 4, 5,
1:               "SMALLINT", 5, 2, 0,
1:               10, 1, null, null, 0,
1:               "YES", GENERIC_NAME, 1, -1 },
1:             { null, "APP", "DUMMY2", "", 4, 4,
1:               "INTEGER", 10, 4, 0,
1:               10, 1, null, null, 0,
1:               "YES", GENERIC_NAME, 2, -1 },
1:             { null, "APP", "DUMMY3", "", 4, 12,
1:               "VARCHAR", 16, 32,
1:               null, null, 1, null, 32, 0, "YES",
1:               2, -1 },
1:             { null, "APP", "DUMMY4", "", 4, 4,
1:               "INTEGER", 10, 4, 0,
1:               10, 1, null, null, 0,
1:               "YES", GENERIC_NAME, 2, -1 },
1:             { null, "APP", "DUMMY5", "", 4, 16,
1:               "BOOLEAN", 1, 1, null,
1:               null, 1, null, null, 0,
1:               "YES", GENERIC_NAME, 1, -1 },
commit:7fd0c6e
/////////////////////////////////////////////////////////////////////////
1:         { null, "SYSCS_UTIL", "SYSCS_PEEK_AT_IDENTITY",
1:           "org.apache.derby.catalog.SystemProcedures." +
1:           "SYSCS_PEEK_AT_IDENTITY", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
commit:8e352d6
/////////////////////////////////////////////////////////////////////////
1:         { null, "SYSCS_UTIL", "SYSCS_PEEK_AT_SEQUENCE",
1:           "org.apache.derby.catalog.SystemProcedures." +
1:           "SYSCS_PEEK_AT_SEQUENCE", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
commit:a6b18af
/////////////////////////////////////////////////////////////////////////
1:         s.execute("CREATE FUNCTION DUMMY5 ( X BOOLEAN ) "+
1:                   "RETURNS BOOLEAN PARAMETER STYLE JAVA NO SQL LANGUAGE "+
1:                   "JAVA EXTERNAL NAME 'java.some.func'");
/////////////////////////////////////////////////////////////////////////
1:         { null, "APP", "DUMMY5", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
/////////////////////////////////////////////////////////////////////////
0:             { null, "APP", "DUMMY5", "", new Integer(4), new Integer(16),
0:               "BOOLEAN", new Integer(1), new Integer(1), null,
0:               null, new Integer(1), null, null, new Integer(0),
0:               "YES", GENERIC_NAME, new Integer(1), new Integer(-1) },
0:             { null, "APP", "DUMMY5", "X", new Integer(1), new Integer(16),
0:               "BOOLEAN", new Integer(1), new Integer(1), null,
0:               null, new Integer(1), null, null, new Integer(1),
0:               "YES", GENERIC_NAME, new Integer(1), new Integer(0) },
/////////////////////////////////////////////////////////////////////////
0:             { null, "APP", "DUMMY5", "", new Integer(4), new Integer(16),
0:               "BOOLEAN", new Integer(1), new Integer(1), null,
0:               null, new Integer(1), null, null, new Integer(0),
0:               "YES", GENERIC_NAME, new Integer(1), new Integer(-1) },
commit:d753aef
/////////////////////////////////////////////////////////////////////////
1:     private static final JDBC.GeneratedId GENERIC_NAME = new JDBC.GeneratedId();
/////////////////////////////////////////////////////////////////////////
commit:768e56f
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.TestDbMetaData
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
0:     private static  final   Integer FUNCTION_NO_TABLE_VALUE = new Integer( DatabaseMetaData.functionNoTable );
1:     
/////////////////////////////////////////////////////////////////////////
1:             "FUNCTION_TYPE", "SPECIFIC_NAME" });
0:         JDBC.assertColumnTypes(rs, new int[] {
1:             Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR,
0:             Types.SMALLINT, Types.VARCHAR });
1:         { null, "APP", "DUMMY1", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:         { null, "APP", "DUMMY2", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:         { null, "APP", "DUMMY3", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:         { null, "APP", "DUMMY4", "java.some.func", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "SYSCS_GET_DATABASE_PROPERTY", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "SYSCS_GET_RUNTIMESTATISTICS", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:               "SYSCS_GET_USER_ACCESS", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "BLOBCREATELOCATOR", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "BLOBGETBYTES", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "BLOBGETLENGTH", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "BLOBGETPOSITIONFROMBYTES", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "BLOBGETPOSITIONFROMLOCATOR", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "CLOBCREATELOCATOR", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "CLOBGETLENGTH", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "CLOBGETPOSITIONFROMLOCATOR", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "CLOBGETPOSITIONFROMSTRING", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:           "CLOBGETSUBSTRING", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
commit:d6e7d39
/////////////////////////////////////////////////////////////////////////
commit:ebdced0
/////////////////////////////////////////////////////////////////////////
0:  							   DatabaseMetaData.functionColumnUnknown));
0: 							   DatabaseMetaData.functionColumnIn));
0: 							   DatabaseMetaData.functionColumnInOut));
0: 							   DatabaseMetaData.functionColumnOut));
/////////////////////////////////////////////////////////////////////////
1:         // the output from getFunctions() and getFunctionColumns
/////////////////////////////////////////////////////////////////////////
1: 		// Test getFunctionColumns
0: 		dumpRS(met.getFunctionColumns(null,null,"DUMMY%",null));
0: 		dumpRS(met.getFunctionColumns(null,null,"DUMMY%",""));
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:7c3b39d
/////////////////////////////////////////////////////////////////////////
0:   		System.out.println(""+(JDBC40Translation.FUNCTION_PARAMETER_UNKNOWN == 
0:  							   DatabaseMetaData.functionParameterUnknown));
commit:e423333
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0: 		// Make sure the constants provided in JDBC40Translation is correct
1: 
0: 		// Uncomment this when jdk16 contains functionParameterUnknown
0: //  		System.out.println(""+(JDBC40Translation.FUNCTION_PARAMETER_UNKNOWN == 
0: // 							   DatabaseMetaData.functionParameterUnknown));
0: 		System.out.println(""+(JDBC40Translation.FUNCTION_PARAMETER_IN == 
0: 							   DatabaseMetaData.functionParameterIn));
0: 		System.out.println(""+(JDBC40Translation.FUNCTION_PARAMETER_INOUT == 
0: 							   DatabaseMetaData.functionParameterInOut));
0: 		System.out.println(""+(JDBC40Translation.FUNCTION_PARAMETER_OUT == 
0: 							   DatabaseMetaData.functionParameterOut));
0: 		System.out.println(""+(JDBC40Translation.FUNCTION_RETURN == 
0: 							   DatabaseMetaData.functionReturn));
1:     
0: 		System.out.println(""+(JDBC40Translation.FUNCTION_NO_NULLS ==
0: 							   DatabaseMetaData.functionNoNulls));
0: 		System.out.println(""+(JDBC40Translation.FUNCTION_NULLABLE ==
0: 							   DatabaseMetaData.functionNullable));
0: 		System.out.println(""+(JDBC40Translation.FUNCTION_NULLABLE_UNKNOWN ==
0: 							   DatabaseMetaData.functionNullableUnknown));
1: 
0: 		// Since JDBC40Translation cannot be accessed in queries in
0: 		// metadata.properties, the query has to use
0: 		// DatabaseMetaData.procedureNullable. Hence it is necessary
0: 		// to verify that that value of
0: 		// DatabaseMetaData.functionNullable is the same.
0: 		System.out.println(""+(DatabaseMetaData.functionNullable == 
0: 							   DatabaseMetaData.procedureNullable));
1: 		
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		// Test getFunctionParameters
0: 		// Dump parameters for all functions beigging with DUMMY
0: 		dumpRS(met.getFunctionParameters(null,null,"DUMMY%",null));
1: 		
1: 		// Dump return value for all DUMMY functions
0: 		dumpRS(met.getFunctionParameters(null,null,"DUMMY%",""));
1: 	  
commit:2e7a2af
/////////////////////////////////////////////////////////////////////////
0:         t_wrapper(met);
commit:3bfb5f0
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
/////////////////////////////////////////////////////////////////////////
1:         
0:         if(usingEmbeddedClient())
0:             t_wrapper(met);
1:         
0:      * <p>
0:      * Return true if we're running under the embedded client.
0:      * </p>
1:      */
0:     private	static	boolean	usingEmbeddedClient() {
0:         return "embedded".equals( System.getProperty( "framework" ) );
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         
1:         
1:     /**
0:      * Tests the wrapper methods isWrapperFor and unwrap. There are two cases
0:      * to be tested
0:      * Case 1: isWrapperFor returns true and we call unwrap
0:      * Case 2: isWrapperFor returns false and we call unwrap
1:      *
0:      * @param dmd The DatabaseMetaData object on which the wrapper methods are 
0:      *           called
1:      */
1:         
0:     static void t_wrapper(DatabaseMetaData dmd) {
0:         //test for the case when isWrapper returns true
0:         //Begin test for Case 1
0:         Class<DatabaseMetaData> wrap_class = DatabaseMetaData.class;
1:         
0:         //The if succeeds and we call the unwrap method on the conn object        
1:         try {
0:             if(dmd.isWrapperFor(wrap_class)) {
0:                 DatabaseMetaData dmd1 = 
0:                         (DatabaseMetaData)dmd.unwrap(wrap_class);
1:             }
0:             else {
0:                 System.out.println("isWrapperFor wrongly returns false");
1:             }
1:         }
0:         catch(SQLException sqle) {
0:             dumpSQLExceptions(sqle);
1:         }
1:         
0:         //Begin the test for Case 2
0:         //test for the case when isWrapper returns false
0:         //using some class that will return false when 
0:         //passed to isWrapperFor
1:         
0:         Class<PreparedStatement> wrap_class1 = PreparedStatement.class;
1:         
1:         try {
0:             //returning false is the correct behaviour in this case
0:             //Generate a message if it returns true
0:             if(dmd.isWrapperFor(wrap_class1)) {
0:                 System.out.println("isWrapperFor wrongly returns true");
1:             }
0:             else {
0:                 PreparedStatement ps1 = (PreparedStatement)
0:                                            dmd.unwrap(wrap_class1);
0:                 System.out.println("unwrap does not throw the expected " +
0:                                    "exception");
1:             }
1:         }
0:         catch (SQLException sqle) {
0:             //calling unwrap in this case throws an 
0:             //SQLException ensure that the SQLException 
0:             //has the correct SQLState
0:             if(!SQLStateConstants.UNABLE_TO_UNWRAP.equals(sqle.getSQLState())) {
0:                 sqle.printStackTrace();
1:             }
1:         }
1:     }
commit:c0119bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:21350fd
/////////////////////////////////////////////////////////////////////////
0: 			// use the ij utility to read the property file and
0: 			// make the initial connection.
0: 			ij.getPropertyArg(args);
1: 		
0: 			Connection	conn_main = ij.startJBMS();
1: 
0:             runTests( conn_main );
commit:502d667
/////////////////////////////////////////////////////////////////////////
0: 			// Create some functions in the default schema (app) to make the output
0: 			// from getFunctions() and getFunctionParameters more interesting
1: 			s.execute("CREATE FUNCTION DUMMY1 ( X SMALLINT ) RETURNS SMALLINT "+
1: 					  "PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA EXTERNAL "+
1: 					  "NAME 'java.some.func'");
1: 			s.execute("CREATE FUNCTION DUMMY2 ( X INTEGER, Y SMALLINT ) RETURNS"+
1: 					  " INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA "+
1: 					  "EXTERNAL NAME 'java.some.func'");
1: 			s.execute("CREATE FUNCTION DUMMY3 ( X VARCHAR(16), Y INTEGER ) "+
1: 					  "RETURNS VARCHAR(16) PARAMETER STYLE JAVA NO SQL LANGUAGE"+
1: 					  " JAVA EXTERNAL NAME 'java.some.func'");
1: 			s.execute("CREATE FUNCTION DUMMY4 ( X VARCHAR(128), Y INTEGER ) "+
1: 					  "RETURNS INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE "+
1: 					  "JAVA EXTERNAL NAME 'java.some.func'");
1: 
1: 
1: 			// Any function in any schema in any catalog
0: 			dumpRS(met.getFunctions(null, null, null));
1: 			// Any function in any schema in "Dummy
1: 			// Catalog". Same as above since the catalog
1: 			// argument is ignored (is always null)
0: 			dumpRS(met.getFunctions("Dummy Catalog", null, null));
1: 			// Any function in a schema starting with "SYS"
0: 			dumpRS(met.getFunctions(null, "SYS%", null));
1: 			// All functions containing "GET" in any schema 
1: 			// (and any catalog)
0: 			dumpRS(met.getFunctions(null, null, "%GET%"));
1: 			// Any function that belongs to NO schema and 
1: 			// NO catalog (none)
0: 			checkEmptyRS(met.getFunctions("", "", null));
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:314a19a
/////////////////////////////////////////////////////////////////////////
1:         { null, "SYSCS_UTIL", "SYSCS_GET_DATABASE_NAME",
1:           "org.apache.derby.catalog.SystemProcedures." +
1:           "SYSCS_GET_DATABASE_NAME", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:35bdb15
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertDatabaseMetaDataColumns(rs, null, new String[] {
/////////////////////////////////////////////////////////////////////////
1:         int[] ColTypes = new int[] {
0:                 Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR,
1:                 Types.SMALLINT, Types.VARCHAR };
1:         JDBC.assertDatabaseMetaDataColumns(rs, ColTypes, new String[] {
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertDatabaseMetaDataColumns(rs, null, new String[] {
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertDatabaseMetaDataColumns(rs, null, new String[] {
commit:c9687fc
/////////////////////////////////////////////////////////////////////////
1:                 // DERBY-4767, sample verification test for operation in XCL16 message.
1:                 assertTrue(sqle.getMessage().indexOf("next") > 0);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite testSuite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("TestDbMetaData suite");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d54fabd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         { null, "SYSCS_UTIL", "SYSCS_GET_USER_ACCESS",
1:           "org.apache.derby.catalog.SystemProcedures." +
0:           "SYSCS_GET_USER_ACCESS", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:         { null, "SYSCS_UTIL", "SYSCS_GET_XPLAIN_MODE",
1:           "org.apache.derby.catalog.SystemProcedures." +
1:           "SYSCS_GET_XPLAIN_MODE", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
1:         { null, "SYSCS_UTIL", "SYSCS_GET_XPLAIN_SCHEMA",
1:           "org.apache.derby.catalog.SystemProcedures." +
1:           "SYSCS_GET_XPLAIN_SCHEMA", FUNCTION_NO_TABLE_VALUE, GENERIC_NAME },
commit:cd90315
/////////////////////////////////////////////////////////////////////////
1:         if (usingEmbedded()) {
1:             assertTrue(meta.autoCommitFailureClosesAllResultSets());
1:         } else {
1:             assertFalse(meta.autoCommitFailureClosesAllResultSets());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // IMPORTANT: use auto-commit
1:         getConnection().setAutoCommit(true);
1:         ResultSet[] rss = new ResultSet[2];
1:         // Use different statements so that both result sets are kept open
1:         rss[0] = createStatement().executeQuery("VALUES 1, 2, 3, 4");
1:         rss[1] = createStatement().executeQuery(
1:                 "SELECT * FROM SYSIBM.SYSDUMMY1");
1: 
1:         // We want to test holdable result sets
1:         for (ResultSet rs : rss) {
1:             assertEquals("ResultSet should be holdable",
1:                          ResultSet.HOLD_CURSORS_OVER_COMMIT,
1:                          rs.getHoldability());
1:         }
1: 
1:             // Create a new statement so we don't close any of the open result
1:             // sets by re-executing a statement.
1:             createStatement().execute(query);
1:         int closedResultSets = 0;
1:         for (ResultSet rs : rss) {
1:             // check if an operation fails with "ResultSet is closed"
1:             try {
1:                 rs.next();
1:                 // OK, didn't fail, ResultSet wasn't closed
1:             } catch (SQLException sqle) {
1:                 assertSQLState("XCL16", sqle);
1:                 // OK, ResultSet is closed, increase counter
1:                 closedResultSets++;
1:             }
1:         }
1: 
1:         boolean allResultSetsWereClosed = (closedResultSets == rss.length);
1: 
1:                      allResultSetsWereClosed,
1:         for (ResultSet rs : rss) {
1:             rs.close();
1:         }
commit:6aa0b12
/////////////////////////////////////////////////////////////////////////
1:         { null, "SYSIBM", "BLOBCREATELOCATOR",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "BLOBCREATELOCATOR", new GeneratedId() },
1:         { null, "SYSIBM", "BLOBGETBYTES",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "BLOBGETBYTES", new GeneratedId() },
1:         { null, "SYSIBM", "BLOBGETLENGTH",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "BLOBGETLENGTH", new GeneratedId() },
1:         { null, "SYSIBM", "BLOBGETPOSITIONFROMBYTES",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "BLOBGETPOSITIONFROMBYTES", new GeneratedId() },
1:         { null, "SYSIBM", "BLOBGETPOSITIONFROMLOCATOR",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "BLOBGETPOSITIONFROMLOCATOR", new GeneratedId() },
1:         { null, "SYSIBM", "CLOBCREATELOCATOR",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "CLOBCREATELOCATOR", new GeneratedId() },
1:         { null, "SYSIBM", "CLOBGETLENGTH",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "CLOBGETLENGTH", new GeneratedId() },
1:         { null, "SYSIBM", "CLOBGETPOSITIONFROMLOCATOR",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "CLOBGETPOSITIONFROMLOCATOR", new GeneratedId() },
1:         { null, "SYSIBM", "CLOBGETPOSITIONFROMSTRING",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "CLOBGETPOSITIONFROMSTRING", new GeneratedId() },
1:         { null, "SYSIBM", "CLOBGETSUBSTRING",
1:           "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:           "CLOBGETSUBSTRING", new GeneratedId() },
/////////////////////////////////////////////////////////////////////////
0:             { null, "SYSIBM", "BLOBCREATELOCATOR",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBCREATELOCATOR", new GeneratedId() },
0:             { null, "SYSIBM", "BLOBGETBYTES",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBGETBYTES", new GeneratedId() },
0:             { null, "SYSIBM", "BLOBGETLENGTH",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBGETLENGTH", new GeneratedId() },
0:             { null, "SYSIBM", "BLOBGETPOSITIONFROMBYTES",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBGETPOSITIONFROMBYTES", new GeneratedId() },
0:             { null, "SYSIBM", "BLOBGETPOSITIONFROMLOCATOR",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBGETPOSITIONFROMLOCATOR", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBCREATELOCATOR",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBCREATELOCATOR", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBGETLENGTH",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBGETLENGTH", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBGETPOSITIONFROMLOCATOR",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBGETPOSITIONFROMLOCATOR", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBGETPOSITIONFROMSTRING",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBGETPOSITIONFROMSTRING", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBGETSUBSTRING",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBGETSUBSTRING", new GeneratedId() },
/////////////////////////////////////////////////////////////////////////
0:             { null, "SYSIBM", "BLOBGETBYTES",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBGETBYTES", new GeneratedId() },
0:             { null, "SYSIBM", "BLOBGETLENGTH",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBGETLENGTH", new GeneratedId() },
0:             { null, "SYSIBM", "BLOBGETPOSITIONFROMBYTES",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBGETPOSITIONFROMBYTES", new GeneratedId() },
0:             { null, "SYSIBM", "BLOBGETPOSITIONFROMLOCATOR",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "BLOBGETPOSITIONFROMLOCATOR", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBGETLENGTH",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBGETLENGTH", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBGETPOSITIONFROMLOCATOR",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBGETPOSITIONFROMLOCATOR", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBGETPOSITIONFROMSTRING",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBGETPOSITIONFROMSTRING", new GeneratedId() },
0:             { null, "SYSIBM", "CLOBGETSUBSTRING",
0:               "org.apache.derby.impl.jdbc.LOBStoredProcedure." +
0:               "CLOBGETSUBSTRING", new GeneratedId() },
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     private static Test baseSuite(String name) {
0:         TestSuite testSuite = new TestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("TestDbMetaData suite");
1:         suite.addTest(baseSuite("TestDbMetaData:embedded"));
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:             baseSuite("TestDbMetaData:client")));
1:         return suite;
1:     }
1: 
commit:5d66268
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: public class TestDbMetaData extends BaseJDBCTestCase {
1:     private DatabaseMetaData meta;
1:     public TestDbMetaData(String name) {
1:         super(name);
1:     protected void setUp() throws SQLException {
1:         meta = getConnection().getMetaData();
1:     protected void tearDown() throws Exception {
1:         meta = null;
1:         super.tearDown();
1:     }
1:     private static void createFunctions(Statement s) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     }
0:     public static Test suite() {
0:         TestSuite testSuite = new TestSuite();
1:         testSuite.addTestSuite(TestDbMetaData.class);
1:         return new CleanDatabaseTestSetup(testSuite) {
1:                 protected void decorateSQL(Statement s) throws SQLException {
1:                     createFunctions(s);
1:                 }
1:             };
1:     }
1:     public void testSupportsStoredFunctionsUsingCallSyntax()
1:             throws SQLException {
1:         assertTrue(meta.supportsStoredFunctionsUsingCallSyntax());
1:     }
1:     public void testAutoCommitFailureClosesAllResultSets() throws SQLException {
0:         assertFalse(meta.autoCommitFailureClosesAllResultSets());
1:     }
1: 
1:     public void testGetClientInfoProperties() throws SQLException {
1:         ResultSet rs = meta.getClientInfoProperties();
0:         JDBC.assertColumnNames(rs, new String[] {
1:             "NAME", "MAX_LEN", "DEFAULT_VALUE", "DESCRIPTION" });
0:         JDBC.assertDrainResults(rs, 0);
1:      * Since JDBC40Translation cannot be accessed in queries in
1:      * metadata.properties, the query has to use
1:      * DatabaseMetaData.procedureNullable. Hence it is necessary
1:      * to verify that that value of
1:      * DatabaseMetaData.functionNullable is the same.
1:     public void testFunctionNullable() {
1:         assertEquals(DatabaseMetaData.procedureNullable,
1:                      DatabaseMetaData.functionNullable);
1: 
1:     /** Check that the column names are as expected from getFunctions(). */
1:     private void assertGetFunctionsRs(ResultSet rs) throws SQLException {
0:         JDBC.assertColumnNames(rs, new String[] {
1:             "FUNCTION_CAT", "FUNCTION_SCHEM", "FUNCTION_NAME", "REMARKS",
0:             "SPECIFIC_NAME" });
1:     }
1: 
1:     /** Expected rows from getFunctions() when all functions match. */
1:     private static final Object[][] ALL_FUNCTIONS = {
0:         { null, "APP", "DUMMY1", "java.some.func", new GeneratedId() },
0:         { null, "APP", "DUMMY2", "java.some.func", new GeneratedId() },
0:         { null, "APP", "DUMMY3", "java.some.func", new GeneratedId() },
0:         { null, "APP", "DUMMY4", "java.some.func", new GeneratedId() },
1:         { null, "SYSCS_UTIL", "SYSCS_CHECK_TABLE",
1:           "org.apache.derby.catalog.SystemProcedures.SYSCS_CHECK_TABLE",
0:           new GeneratedId() },
1:         { null, "SYSCS_UTIL", "SYSCS_GET_DATABASE_PROPERTY",
1:           "org.apache.derby.catalog.SystemProcedures." +
0:           "SYSCS_GET_DATABASE_PROPERTY", new GeneratedId() },
1:         { null, "SYSCS_UTIL", "SYSCS_GET_RUNTIMESTATISTICS",
1:           "org.apache.derby.catalog.SystemProcedures." +
0:           "SYSCS_GET_RUNTIMESTATISTICS", new GeneratedId() },
1:     };
1: 
1:     public void testGetFunctionsNullNullNull() throws SQLException {
0:         // Any function in any schema in any catalog
1:         ResultSet rs = meta.getFunctions(null, null, null);
1:         assertGetFunctionsRs(rs);
1:         JDBC.assertFullResultSet(rs, ALL_FUNCTIONS, false);
1:     }
1: 
1:     public void testGetFunctionsDummySchema() throws SQLException {
0:         // Any function in any schema in "Dummy
0:         // Catalog". Same as above since the catalog
0:         // argument is ignored (is always null)
1:         ResultSet rs = meta.getFunctions("Dummy Catalog", null, null);
1:         assertGetFunctionsRs(rs);
1:         JDBC.assertFullResultSet(rs, ALL_FUNCTIONS, false);
1:     }
1: 
1:     public void testGetFunctionsFromSysSchemas() throws SQLException {
0:         // Any function in a schema starting with "SYS"
1:         ResultSet rs = meta.getFunctions(null, "SYS%", null);
1:         assertGetFunctionsRs(rs);
0:         Object[][] sysFunctions = {
1:             { null, "SYSCS_UTIL", "SYSCS_CHECK_TABLE",
1:               "org.apache.derby.catalog.SystemProcedures.SYSCS_CHECK_TABLE",
0:               new GeneratedId() },
1:             { null, "SYSCS_UTIL", "SYSCS_GET_DATABASE_PROPERTY",
1:               "org.apache.derby.catalog.SystemProcedures." +
0:               "SYSCS_GET_DATABASE_PROPERTY", new GeneratedId() },
1:             { null, "SYSCS_UTIL", "SYSCS_GET_RUNTIMESTATISTICS",
1:               "org.apache.derby.catalog.SystemProcedures." +
0:               "SYSCS_GET_RUNTIMESTATISTICS", new GeneratedId() },
1:         };
0:         JDBC.assertFullResultSet(rs, sysFunctions, false);
1:     }
1: 
1:     public void testGetFunctionsContainingGET() throws SQLException {
0:         // All functions containing "GET" in any schema 
0:         // (and any catalog)
1:         ResultSet rs = meta.getFunctions(null, null, "%GET%");
1:         assertGetFunctionsRs(rs);
0:         Object[][] getFunctions = {
1:             { null, "SYSCS_UTIL", "SYSCS_GET_DATABASE_PROPERTY",
1:               "org.apache.derby.catalog.SystemProcedures." +
0:               "SYSCS_GET_DATABASE_PROPERTY", new GeneratedId() },
1:             { null, "SYSCS_UTIL", "SYSCS_GET_RUNTIMESTATISTICS",
1:               "org.apache.derby.catalog.SystemProcedures." +
0:               "SYSCS_GET_RUNTIMESTATISTICS", new GeneratedId() },
1:         };
0:         JDBC.assertFullResultSet(rs, getFunctions, false);
1:     }
1: 
1:     public void testGetFunctionsNoSchemaNoCatalog() throws SQLException {
0:         // Any function that belongs to NO schema and 
0:         // NO catalog (none)
1:         ResultSet rs = meta.getFunctions("", "", null);
1:         assertGetFunctionsRs(rs);
0:         JDBC.assertDrainResults(rs, 0);
1:     }
1: 
1:     /** Check that the column names are as expected from
1:      * getFunctionColumns(). */
1:     private void assertGetFunctionColumnsRs(ResultSet rs) throws SQLException {
0:         JDBC.assertColumnNames(rs, new String[] {
1:             "FUNCTION_CAT", "FUNCTION_SCHEM", "FUNCTION_NAME", "COLUMN_NAME",
1:             "COLUMN_TYPE", "DATA_TYPE", "TYPE_NAME", "PRECISION", "LENGTH",
1:             "SCALE", "RADIX", "NULLABLE", "REMARKS", "CHAR_OCTET_LENGTH",
1:             "ORDINAL_POSITION", "IS_NULLABLE", "SPECIFIC_NAME",
1:             "METHOD_ID", "PARAMETER_ID"
1:         });
1:     }
1: 
1:     public void testGetFunctionColumnsStartingWithDUMMY() throws SQLException {
0: 		// Test getFunctionColumns
1:         // Dump parameters for all functions beginning with DUMMY
1:         ResultSet rs = meta.getFunctionColumns(null, null, "DUMMY%", null);
1:         assertGetFunctionColumnsRs(rs);
1:         Object[][] expectedRows = {
0:             { null, "APP", "DUMMY1", "", new Integer(4), new Integer(5),
0:               "SMALLINT", new Integer(5), new Integer(2), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(0),
0:               "YES", new GeneratedId(), new Integer(1), new Integer(-1) },
0:             { null, "APP", "DUMMY1", "X", new Integer(1), new Integer(5),
0:               "SMALLINT", new Integer(5), new Integer(2), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(1),
0:               "YES", new GeneratedId(), new Integer(1), new Integer(0) },
0:             { null, "APP", "DUMMY2", "", new Integer(4), new Integer(4),
0:               "INTEGER", new Integer(10), new Integer(4), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(0),
0:               "YES", new GeneratedId(), new Integer(2), new Integer(-1) },
0:             { null, "APP", "DUMMY2", "X", new Integer(1), new Integer(4),
0:               "INTEGER", new Integer(10), new Integer(4), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(1),
0:               "YES", new GeneratedId(), new Integer(2), new Integer(0) },
0:             { null, "APP", "DUMMY2", "Y", new Integer(1), new Integer(5),
0:               "SMALLINT", new Integer(5), new Integer(2), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(2),
0:               "YES", new GeneratedId(), new Integer(2), new Integer(1) },
0:             { null, "APP", "DUMMY3", "", new Integer(4), new Integer(12),
0:               "VARCHAR", new Integer(16), new Integer(32), null, null,
0:               new Integer(1), null, 32, new Integer(0), "YES",
0:               new GeneratedId(), new Integer(2), new Integer(-1) },
0:             { null, "APP", "DUMMY3", "X", new Integer(1), new Integer(12),
0:               "VARCHAR", new Integer(16), new Integer(32), null, null,
0:               new Integer(1), null, 32, new Integer(1), "YES",
0:               new GeneratedId(), new Integer(2), new Integer(0) },
0:             { null, "APP", "DUMMY3", "Y", new Integer(1), new Integer(4),
0:               "INTEGER", new Integer(10), new Integer(4), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(2),
0:               "YES", new GeneratedId(), new Integer(2), new Integer(1) },
0:             { null, "APP", "DUMMY4", "", new Integer(4), new Integer(4),
0:               "INTEGER", new Integer(10), new Integer(4), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(0),
0:               "YES", new GeneratedId(), new Integer(2), new Integer(-1) },
0:             { null, "APP", "DUMMY4", "X", new Integer(1), new Integer(12),
0:               "VARCHAR", new Integer(128), new Integer(256),
0:               null, null, new Integer(1), null, 256, new Integer(1), "YES",
0:               new GeneratedId(),
0:               new Integer(2), new Integer(0) },
0:             { null, "APP", "DUMMY4", "Y", new Integer(1), new Integer(4),
0:               "INTEGER", new Integer(10), new Integer(4), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(2),
0:               "YES", new GeneratedId(), new Integer(2), new Integer(1) },
1:         };
1:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:     }
1: 
1:     public void testGetFunctionColumnsForDummyFunctions() throws SQLException {
0: 		// Dump return value for all DUMMY functions
1:         ResultSet rs = meta.getFunctionColumns(null, null, "DUMMY%", "");
1:         assertGetFunctionColumnsRs(rs);
1:         Object[][] expectedRows = {
0:             { null, "APP", "DUMMY1", "", new Integer(4), new Integer(5),
0:               "SMALLINT", new Integer(5), new Integer(2), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(0),
0:               "YES", new GeneratedId(), new Integer(1), new Integer(-1) },
0:             { null, "APP", "DUMMY2", "", new Integer(4), new Integer(4),
0:               "INTEGER", new Integer(10), new Integer(4), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(0),
0:               "YES", new GeneratedId(), new Integer(2), new Integer(-1) },
0:             { null, "APP", "DUMMY3", "", new Integer(4), new Integer(12),
0:               "VARCHAR", new Integer(16), new Integer(32),
0:               null, null, new Integer(1), null, 32, new Integer(0), "YES",
0:               new GeneratedId(),
0:               new Integer(2), new Integer(-1) },
0:             { null, "APP", "DUMMY4", "", new Integer(4), new Integer(4),
0:               "INTEGER", new Integer(10), new Integer(4), new Integer(0),
0:               new Integer(10), new Integer(1), null, null, new Integer(0),
0:               "YES", new GeneratedId(), new Integer(2), new Integer(-1) },
1:         };
1:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:     }
1: 
1:     /** Check that the column names are as expected from getSchemas(). */
1:     private void assertGetSchemasRs(ResultSet rs) throws SQLException {
0:         JDBC.assertColumnNames(rs, new String[] {
1:             "TABLE_SCHEM", "TABLE_CATALOG" });
1:     }
1: 
1:     public void testGetSchemasNullNull() throws SQLException {
1:         // Test the new getSchemas() with no schema qualifiers
1:         ResultSet rs = meta.getSchemas(null, null);
1:         assertGetSchemasRs(rs);
1:         Object[][] expectedRows = {
1:             { "APP", null },
1:             { "NULLID", null },
1:             { "SQLJ", null },
1:             { "SYS", null },
1:             { "SYSCAT", null },
1:             { "SYSCS_DIAG", null },
1:             { "SYSCS_UTIL", null },
1:             { "SYSFUN", null },
1:             { "SYSIBM", null },
1:             { "SYSPROC", null },
1:             { "SYSSTAT", null },
1:         };
1:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:     }
1: 
1:     public void testGetSchemasStartingWithSYS() throws SQLException {
1:         // Test the new getSchemas() with a schema wildcard qualifier
1:         ResultSet rs = meta.getSchemas(null, "SYS%");
1:         assertGetSchemasRs(rs);
1:         Object[][] expectedRows = {
1:             { "SYS", null },
1:             { "SYSCAT", null },
1:             { "SYSCS_DIAG", null },
1:             { "SYSCS_UTIL", null },
1:             { "SYSFUN", null },
1:             { "SYSIBM", null },
1:             { "SYSPROC", null },
1:             { "SYSSTAT", null },
1:         };
1:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:     }
1: 
1:     public void testGetSchemasMatchingAPP() throws SQLException {
1:         // Test the new getSchemas() with an exact match
1:         ResultSet rs = meta.getSchemas(null, "APP");
1:         assertGetSchemasRs(rs);
1:         Object[][] expectedRows = {
1:             { "APP", null },
1:         };
1:         JDBC.assertFullResultSet(rs, expectedRows, false);
1:     }
1: 
1:     public void testGetSchemasMatchingBLAH() throws SQLException {
1:         // Make sure that getSchemas() returns an empty result
1:         // set when a schema is passed with no match
1:         ResultSet rs = meta.getSchemas(null, "BLAH");
1:         assertGetSchemasRs(rs);
0:         JDBC.assertDrainResults(rs, 0);
1:     }
1: 
1:     public void testStoredProcEscapeSyntax() throws SQLException {
1:         getConnection().setAutoCommit(false);
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("supportsStoredFunctionsUsingCallSyntax() returned " +
1:                      "value which doesn't match actual behaviour.",
1:                      success, meta.supportsStoredFunctionsUsingCallSyntax());
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testAutoCommitFailure() throws SQLException {
0:         Connection con = getConnection();
/////////////////////////////////////////////////////////////////////////
1:             fail("Query didn't fail.");
1:         assertEquals("autoCommitFailureClosesAllResultSets() returned value " +
1:                      "which doesn't match actual behaviour.",
0:                      resultSet.isClosed(),
1:                      meta.autoCommitFailureClosesAllResultSets());
1: 
1:     public void testIsWrapperForPositive() throws SQLException {
1:         assertTrue("DatabaseMetaData should be wrapper for itself.",
1:                    meta.isWrapperFor(DatabaseMetaData.class));
1:     }
1:     public void testIsWrapperForNegative() throws SQLException {
1:         assertFalse("DatabaseMetaData should not wrap PreparedStatement.",
1:                     meta.isWrapperFor(PreparedStatement.class));
1:     }
1:     public void testGetWrapperPositive() throws SQLException {
1:         DatabaseMetaData dmd = meta.unwrap(DatabaseMetaData.class);
1:         assertSame("Unwrap should return same object.", meta, dmd);
1:     }
1:     public void testGetWrapperNegative() {
1:         try {
1:             PreparedStatement ps = meta.unwrap(PreparedStatement.class);
1:             fail("Unwrap should not return PreparedStatement.");
1:         } catch (SQLException e) {
1:             assertSQLState(SQLStateConstants.UNABLE_TO_UNWRAP, e);
1:         }
1:     }
0:      * Helper class whose <code>equals()</code> method returns
0:      * <code>true</code> for all strings on this format: SQL061021105830900
0:     private static class GeneratedId {
0:         public boolean equals(Object o) {
0:             return o instanceof String &&
0:                 ((String) o).matches("SQL[0-9]{15}");
0:         public String toString() {
0:             return "xxxxGENERATED-IDxxxx";
commit:533d502
/////////////////////////////////////////////////////////////////////////
0:         checkEmptyRS(met.getClientInfoProperties());
/////////////////////////////////////////////////////////////////////////
1: 
0:         // Test the new getSchemas() with no schema qualifiers
0:         dumpRS(met.getSchemas(null, null));
0:         // Test the new getSchemas() with a schema wildcard qualifier
0:         dumpRS(met.getSchemas(null, "SYS%"));
0:         // Test the new getSchemas() with an exact match
0:         dumpRS(met.getSchemas(null, "APP"));
0:         // Make sure that getSchemas() returns an empty result
0:         // set when a schema is passed with no match
0:         checkEmptyRS(met.getSchemas(null, "BLAH"));
commit:0223b95
/////////////////////////////////////////////////////////////////////////
0:         // Any function in any schema in any catalog
0:         dumpRS(met.getFunctions(null, null, null));
0:         // Any function in any schema in "Dummy
0:         // Catalog". Same as above since the catalog
0:         // argument is ignored (is always null)
0:         dumpRS(met.getFunctions("Dummy Catalog", null, null));
0:         // Any function in a schema starting with "SYS"
0:         dumpRS(met.getFunctions(null, "SYS%", null));
0:         // All functions containing "GET" in any schema 
0:         // (and any catalog)
0:         dumpRS(met.getFunctions(null, null, "%GET%"));
0:         // Any function that belongs to NO schema and 
0:         // NO catalog (none)
0:         checkEmptyRS(met.getFunctions("", "", null));
commit:f658f85
/////////////////////////////////////////////////////////////////////////
0:         testStoredProcEscapeSyntax(con);
0:         testAutoCommitFailure(con);
0:         con.close();
/////////////////////////////////////////////////////////////////////////
0:         if (!met.supportsStoredFunctionsUsingCallSyntax()) {
0:             System.out.println
0:                 ("FAIL: supportsStoredFunctionsUsingCallSyntax() " +
0:                  "should return true");
0:         if (met.autoCommitFailureClosesAllResultSets()) {
0:             System.out.println
0:                 ("FAIL: autoCommitFailureClosesAllResultSets() " +
0:                  "should return false");
0:         if (met.providesQueryObjectGenerator()) {
0:             System.out.println
0:                 ("FAIL: providesQueryObjectGenerator() should " +
0:                  "return false");
0:         RowIdLifetime lifetime = met.getRowIdLifetime();
0:         if (lifetime != RowIdLifetime.ROWID_UNSUPPORTED) {
0:             System.out.println("FAIL: getRowIdLifetime() should return " +
0:                                "ROWID_UNSUPPORTED, but got " + lifetime);
/////////////////////////////////////////////////////////////////////////
1:     }
1:     /**
1:      * Test supportsStoredFunctionsUsingCallSyntax() by checking
1:      * whether calling a stored procedure using the escape syntax
1:      * succeeds.
1:      *
0:      * @param con <code>Connection</code> object used in test
1:      * @exception SQLException if an unexpected database error occurs
1:      */
0:     private static void testStoredProcEscapeSyntax(Connection con)
0:         throws SQLException
1:     {
0:         con.setAutoCommit(false);
1:         String call = "{CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)}";
0:         Statement stmt = con.createStatement();
1:         boolean success;
0:         try {
1:             stmt.execute(call);
1:             success = true;
1:         } catch (SQLException e) {
1:             success = false;
1:         }
1: 
0:         DatabaseMetaData dmd = con.getMetaData();
0:         boolean supported = dmd.supportsStoredFunctionsUsingCallSyntax();
0:         if (success != supported) {
0:             System.out.println("supportsStoredFunctionsUsingCallSyntax() " +
0:                                "returned " + supported + ", but executing " +
0:                                call + (success ? " succeeded." : " failed."));
1:         }
1:         stmt.close();
0:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test autoCommitFailureClosesAllResultSets() by checking whether
1:      * a failure in auto-commit mode will close all result sets, even
1:      * holdable ones.
1:      *
0:      * @param con <code>Connection</code> object used in test
1:      * @exception SQLException if an unexpected database error occurs
1:      */
0:     private static void testAutoCommitFailure(Connection con)
0:         throws SQLException
1:     {
0:         DatabaseMetaData dmd = con.getMetaData();
0:         boolean shouldBeClosed = dmd.autoCommitFailureClosesAllResultSets();
1: 
0:         con.setAutoCommit(true);
1: 
0:         Statement s1 =
0:             con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
0:                                 ResultSet.CONCUR_READ_ONLY,
0:                                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:         ResultSet resultSet = s1.executeQuery("VALUES (1, 2), (3, 4)");
1: 
0:         Statement s2 = con.createStatement();
0:         try {
1:             String query =
1:                 "SELECT dummy, nonexistent, phony FROM imaginarytable34521";
0:             s2.execute(query);
0:             System.out.println("\"" + query + "\" is expected to fail, " +
0:                                "but it didn't.");
1:         } catch (SQLException e) {
1:             // should fail, but we don't care how
1:         }
1: 
0:         boolean isClosed = resultSet.isClosed();
0:         if (isClosed != shouldBeClosed) {
0:             System.out.println("autoCommitFailureClosesAllResultSets() " +
0:                                "returned " + shouldBeClosed +
0:                                ", but ResultSet is " +
0:                                (isClosed ? "closed." : "not closed."));
1:         }
0:         resultSet.close();
0:         s1.close();
0:         s2.close();
commit:63170fc
/////////////////////////////////////////////////////////////////////////
1:  * Test of database metadata for new methods in JDBC 40.
0:             // Using TestConnection for now instead of ij because
0:             // ij.startJBMS() returns null for classes built against
0:             // JDK 1.6
0:             runTests(new TestConnection().createEmbeddedConnection());
0:             runTests(new TestConnection().createClientConnection());
0:         }
0:         catch (SQLException e) {
0:             dumpSQLExceptions(e);
0:         }
0:         catch (Throwable e) {
0:             System.out.println("FAIL -- unexpected exception:");
0:             e.printStackTrace(System.out);
0:         }
0:     }
0:     // Run all the tests.
0:     private static void runTests(Connection con) throws Exception {
0:         testDatabaseMetaDataMethods(con);
0:     }
0:     // Simply call each new metadata method and print the result.
0:     private static void testDatabaseMetaDataMethods(Connection con)
0:         throws Exception
1:     {
0:         con.setAutoCommit(true); // make sure it is true
0:         Statement s = con.createStatement();
0:         DatabaseMetaData met = con.getMetaData();
0:         try {
0:             if (!met.supportsStoredFunctionsUsingCallSyntax()) {
0:                 System.out.println
0:                     ("FAIL: supportsStoredFunctionsUsingCallSyntax() " +
0:                      "should return true");
0:         } catch (SQLException e) {
0:             // TODO: remove try/catch once method is implemented!
0:             System.out.println("supportsStoredFunctionsUsingCallSyntax():");
0:             dumpSQLExceptions(e);
0:         }
1: 
0:         try {
0:             if (met.autoCommitFailureClosesAllResultSets()) {
0:                 System.out.println
0:                     ("FAIL: autoCommitFailureClosesAllResultSets() " +
0:                      "should return false");
0:         } catch (SQLException e) {
0:             // TODO: remove try/catch once method is implemented!
0:             System.out.println("autoCommitFailureClosesAllResultSets():");
0:             dumpSQLExceptions(e);
0:         }
1: 
0:         try {
0:             if (met.providesQueryObjectGenerator()) {
0:                 System.out.println
0:                     ("FAIL: providesQueryObjectGenerator() should " +
0:                      "return false");
0:         } catch (SQLException e) {
0:             // TODO: remove try/catch once method is implemented!
0:             System.out.println("providesQueryObjectGenerator():");
0:             dumpSQLExceptions(e);
0:         }
1: 
0:         try {
0:             if (lifetime != RowIdLifetime.ROWID_UNSUPPORTED) {
0:                 System.out.println("FAIL: getRowIdLifetime() should return " +
0:                                    "ROWID_UNSUPPORTED, but got " + lifetime);
0:         } catch (SQLException e) {
0:             // TODO: remove try/catch once method is implemented!
0:             System.out.println("getRowIdLifetime():");
0:             dumpSQLExceptions(e);
0:         }
0:         try {
0:         } catch (SQLException e) {
0:             // TODO: remove try/catch once method is implemented!
0:             System.out.println("getClientInfoProperties():");
0:             dumpSQLExceptions(e);
0:         }
1:         // Create some functions in the default schema (app) to make
0:         // the output from getFunctions() and getFunctionParameters
1:         // more interesting
0:         s.execute("CREATE FUNCTION DUMMY1 ( X SMALLINT ) RETURNS SMALLINT "+
0:                   "PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA EXTERNAL "+
0:                   "NAME 'java.some.func'");
0:         s.execute("CREATE FUNCTION DUMMY2 ( X INTEGER, Y SMALLINT ) RETURNS"+
0:                   " INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA "+
0:                   "EXTERNAL NAME 'java.some.func'");
0:         s.execute("CREATE FUNCTION DUMMY3 ( X VARCHAR(16), Y INTEGER ) "+
0:                   "RETURNS VARCHAR(16) PARAMETER STYLE JAVA NO SQL LANGUAGE"+
0:                   " JAVA EXTERNAL NAME 'java.some.func'");
0:         s.execute("CREATE FUNCTION DUMMY4 ( X VARCHAR(128), Y INTEGER ) "+
0:                   "RETURNS INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE "+
0:                   "JAVA EXTERNAL NAME 'java.some.func'");
0:         try {
0:         } catch (SQLException e) {
0:             // TODO: remove try/catch once method is implemented!
0:             System.out.println("getFunctionParameters():");
0:             dumpSQLExceptions(e);
0:         } catch (AbstractMethodError ame) {
0:             // TODO: No implementation on client yet, so catch
0:             // AbstractMethodError for now. Remove when implemented.
0:             System.out.println("getFunctionParameters():");
0:             ame.printStackTrace(System.out);
0:         }
0:         try {
/////////////////////////////////////////////////////////////////////////
0:         } catch (SQLException e) {
0:             // TODO: remove try/catch once method is implemented!
0:             System.out.println("getFunctions():");
0:             dumpSQLExceptions(e);
0:         } catch (AbstractMethodError ame) {
0:             // TODO: No implementation on client yet, so catch
0:             // AbstractMethodError for now. Remove when implemented.
0:             System.out.println("getClientInfoProperties():");
0:             ame.printStackTrace(System.out);
0:         }
1: 
0:         try {
/////////////////////////////////////////////////////////////////////////
0:         } catch (SQLException e) {
0:             // TODO: remove try/catch once method is implemented!
0:             System.out.println("getSchemas():");
0:             dumpSQLExceptions(e);
0:         }
0:         s.close();
0:         con.close();
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:3f677d1
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertEmpty(rs);
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertEmpty(rs);
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertEmpty(rs);
commit:d36746b
/////////////////////////////////////////////////////////////////////////
1:     
0:     private static final GeneratedId GENERIC_NAME = new GeneratedId();
0:         { null, "APP", "DUMMY1", "java.some.func", GENERIC_NAME },
0:         { null, "APP", "DUMMY2", "java.some.func", GENERIC_NAME },
0:         { null, "APP", "DUMMY3", "java.some.func", GENERIC_NAME },
0:         { null, "APP", "DUMMY4", "java.some.func", GENERIC_NAME },
0:           GENERIC_NAME },
0:           "SYSCS_GET_DATABASE_PROPERTY", GENERIC_NAME },
0:           "SYSCS_GET_RUNTIMESTATISTICS", GENERIC_NAME },
0:           { null, "SYSCS_UTIL", "SYSCS_GET_USER_ACCESS",
0:               "org.apache.derby.catalog.SystemProcedures." +
0:               "SYSCS_GET_USER_ACCESS", GENERIC_NAME },
0:           "BLOBCREATELOCATOR", GENERIC_NAME },
0:           "BLOBGETBYTES", GENERIC_NAME },
0:           "BLOBGETLENGTH", GENERIC_NAME },
0:           "BLOBGETPOSITIONFROMBYTES", GENERIC_NAME },
0:           "BLOBGETPOSITIONFROMLOCATOR", GENERIC_NAME },
0:           "CLOBCREATELOCATOR", GENERIC_NAME },
0:           "CLOBGETLENGTH", GENERIC_NAME },
0:           "CLOBGETPOSITIONFROMLOCATOR", GENERIC_NAME },
0:           "CLOBGETPOSITIONFROMSTRING", GENERIC_NAME },
0:           "CLOBGETSUBSTRING", GENERIC_NAME },
1: 
/////////////////////////////////////////////////////////////////////////
1:         
1:         getSysFunctions();
1:         JDBC.assertFullResultSet(rs, getSysFunctions(), false);
1:     
1:     /**
1:      * From the list of all functions extract the ones in schemas
1:      * starting with SYS.
1:       */
1:     private static Object[][] getSysFunctions()
1:     {
1:         int n = 0;
1:         for (int i = 0; i < ALL_FUNCTIONS.length; i++)
1:         {
1:             String schema = (String) ALL_FUNCTIONS[i][1];
1:             if (schema.startsWith("SYS"))
1:                 n++;
0:         }
1:         
1:         Object[][] sysFunctions = new Object[n][];
1:         n = 0;
1:         for (int i = 0; i < ALL_FUNCTIONS.length; i++)
1:         {
1:             String schema = (String) ALL_FUNCTIONS[i][1];
1:             if (schema.startsWith("SYS"))
1:                 sysFunctions[n++] = ALL_FUNCTIONS[i];
0:         }        
1:                
1:         return sysFunctions;
0:     }
1:     
1:     /**
1:      * From the list of all functions extract the ones with GET in the name.
1:      * This assumes this test does not create functions with GET.
1:       */
1:     private static Object[][] getGetFunctions()
1:     {
1:         int n = 0;
1:         for (int i = 0; i < ALL_FUNCTIONS.length; i++)
1:         {
1:             String name = (String) ALL_FUNCTIONS[i][2];
1:             if (name.indexOf("GET") != -1)
1:                 n++;
0:         }
1:         
1:         Object[][] getFunctions = new Object[n][];
1:         n = 0;
1:         for (int i = 0; i < ALL_FUNCTIONS.length; i++)
1:         {
1:             String name = (String) ALL_FUNCTIONS[i][2];
1:             if (name.indexOf("GET") != -1)
1:                 getFunctions[n++] = ALL_FUNCTIONS[i];
0:         }        
1:                
1:         return getFunctions;
0:     }
1:     
1:         JDBC.assertFullResultSet(rs, getGetFunctions(), false);
/////////////////////////////////////////////////////////////////////////
0:               "YES", GENERIC_NAME, new Integer(1), new Integer(-1) },
0:               "YES", GENERIC_NAME, new Integer(1), new Integer(0) },
0:               "YES", GENERIC_NAME, new Integer(2), new Integer(-1) },
0:               "YES", GENERIC_NAME, new Integer(2), new Integer(0) },
0:               "YES", GENERIC_NAME, new Integer(2), new Integer(1) },
0:               GENERIC_NAME, new Integer(2), new Integer(-1) },
0:               GENERIC_NAME, new Integer(2), new Integer(0) },
0:               "YES", GENERIC_NAME, new Integer(2), new Integer(1) },
0:               "YES", GENERIC_NAME, new Integer(2), new Integer(-1) },
1:               GENERIC_NAME,
0:               "YES", GENERIC_NAME, new Integer(2), new Integer(1) },
/////////////////////////////////////////////////////////////////////////
0:               "YES", GENERIC_NAME, new Integer(1), new Integer(-1) },
0:               "YES", GENERIC_NAME, new Integer(2), new Integer(-1) },
1:               GENERIC_NAME,
0:               "YES", GENERIC_NAME, new Integer(2), new Integer(-1) },
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite testSuite = new TestSuite("TestDbMetaData suite");
author:David Van Couvering
-------------------------------------------------------------------------------
commit:89d3ce5
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc.TestDbMetaData
0: 
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
1:  */
0: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
0: 
0: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.sql.RowIdLifetime;
0: 
0: import org.apache.derby.tools.ij;
0: 
0: /**
0:  * Test of database meta-data for new methods in jdbc 30. This program simply calls
0:  * each of the new meta-data methods in jdbc30, one by one, and prints the results.
0:  *
0:  * @author mamta
1:  */
0: 
0: public class TestDbMetaData { 
0: 
0: 	public static void main(String[] args) {
0: 		DatabaseMetaData met;
0: 		Connection con;
0: 		Statement  s;
0:     
0: 		try
0: 		{
0:             // Using this for now instead of ij because ij.startJBMS()
0:             // returns null for classes built against JDK 1.6
0:             con = new TestConnection().createEmbeddedConnection();
0: 
0: 			con.setAutoCommit(true); // make sure it is true
0: 
0: 			s = con.createStatement();
0:             
0: 			met = con.getMetaData();
0: 
0:             if ( ! met.supportsStoredFunctionsUsingCallSyntax() ) {
0:                 throw new Exception("FAIL: supportsStoredFunctionsUsingCallSyntax() " +
0:                     "should return true");
0:             }
0:             
0:             if ( met.autoCommitFailureClosesAllResultSets() ) {
0:                 throw new Exception("FAIL: autoCommitFailureClosesAllResultSets() " +
0:                     "should return false");
0:             }
0:             
0:             if ( met.providesQueryObjectGenerator() ) {
0:                 throw new Exception("FAIL: providesQueryObjectGenerator() should " +
0:                     "return false");
0:             }
0:             
0:             RowIdLifetime lifetime = met.getRowIdLifetime();
0:             if ( lifetime != RowIdLifetime.ROWID_UNSUPPORTED ) {
0:                 throw new Exception("FAIL: getRowIdLifetime() should return " +
0:                     "ROWID_UNSUPPORTED, but got " + lifetime );
0:             }
0: 
0: 			checkEmptyRS(met.getClientInfoProperties());
0: 
0: 			checkEmptyRS(met.getFunctions(null,null,null));
0:         
0: 			checkEmptyRS(met.getFunctionParameters(null,null,null,null));
0:             
0:             // 
0:             // Test the new getSchemas() with no schema qualifiers
0:             //
0:             dumpRS(met.getSchemas(null, null));
0:             
0:             //
0:             // Test the new getSchemas() with a schema wildcard qualifier
0:             // 
0:             dumpRS(met.getSchemas(null, "SYS%"));
0:             
0:             // 
0:             // Test the new getSchemas() with an exact match
0:             //
0:             dumpRS(met.getSchemas(null, "APP"));
0:             
0:             //
0:             // Make sure that getSchemas() returns an empty result
0:             // set when a schema is passed with no match
0:             //
0:             checkEmptyRS(met.getSchemas(null, "BLAH"));
0:         
0: 			s.close();
0: 
0: 			con.close();
0: 
0: 		}
0: 		catch (SQLException e) {
0: 			dumpSQLExceptions(e);
0: 		}
0: 		catch (Throwable e) {
0: 			System.out.println("FAIL -- unexpected exception:");
0: 			e.printStackTrace(System.out);
0: 		}
0:     }
0: 
0: 	static private void dumpSQLExceptions (SQLException se) {
0: 		System.out.println("FAIL -- unexpected exception");
0: 		while (se != null) {
0: 			System.out.print("SQLSTATE("+se.getSQLState()+"):");
0: 			se.printStackTrace(System.out);
0: 			se = se.getNextException();
0: 		}
0: 	}
0: 
0: 	static void dumpRS(ResultSet s) throws SQLException {
0: 		ResultSetMetaData rsmd = s.getMetaData ();
0: 
0: 		// Get the number of columns in the result set
0: 		int numCols = rsmd.getColumnCount ();
0: 
0: 		if (numCols <= 0) {
0: 			System.out.println("(no columns!)");
0: 			return;
0: 		}
0: 		
0: 		// Display column headings
0: 		for (int i=1; i<=numCols; i++) {
0: 			if (i > 1) System.out.print(",");
0: 			System.out.print(rsmd.getColumnLabel(i));
0: 		}
0: 		System.out.println();
0: 	
0: 		// Display data, fetching until end of the result set
0: 		while (s.next()) {
0: 			// Loop through each column, getting the
0: 			// column data and displaying
0: 			for (int i=1; i<=numCols; i++) {
0: 				if (i > 1) System.out.print(",");
0: 				System.out.print(s.getString(i));
0: 			}
0: 			System.out.println();
0: 		}
0: 		s.close();
0: 	}
0: 
0: 	/**
0: 	 * Checks for a ResultSet with no rows.
0: 	 *
1: 	 */
0: 	static void checkEmptyRS(ResultSet rs) throws Exception
0: 	{		
0: 		boolean passed = false;
0: 
0: 		try {
0: 			if ( rs == null )
0:             {
0:                 throw new Exception("Metadata result set can not be null");
0:             }
0:             int numrows = 0;
0:             while (rs.next())
0:                 numrows++;
0:             // Zero rows is what we want.
0:             if (numrows != 0) {
0:                 throw new Exception("Result set is not empty");
0:             }
0: 		}
0: 		catch (SQLException e)
0: 		{
0: 			throw new Exception("Unexpected SQL Exception: " + e.getMessage(), e);
0: 		}
0: 	}
0: }
============================================================================