1:eac0369: /*
7:eac0369: 
1:345de35:    Derby - Class org.apache.derby.jdbc.EmbedPooledConnection
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:99ae840: 
1:eac0369: package org.apache.derby.jdbc;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.error.ExceptionSeverity;
1:cccf5dd: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: 
1:eac0369: /* import impl class */
1:eac0369: import org.apache.derby.impl.jdbc.Util;
1:63d26f5: import org.apache.derby.impl.jdbc.EmbedConnection;
1:eac0369: import org.apache.derby.iapi.jdbc.BrokeredConnection;
1:eac0369: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
1:da847a2: import org.apache.derby.iapi.jdbc.EngineConnection;
1:448ecb0: import org.apache.derby.impl.jdbc.EmbedPreparedStatement;
1:448ecb0: import org.apache.derby.impl.jdbc.EmbedCallableStatement;
1:eac0369: 
1:eac0369: 
1:eac0369: import java.sql.Connection;
1:1ae0d7d: import java.security.AccessController;
1:1ae0d7d: import java.security.PrivilegedAction;
1:1e8a20f: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Statement;
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.CallableStatement;
1:eac0369: 
1:af3cf0c: import java.util.ArrayList;
1:99ae840: import java.util.concurrent.CopyOnWriteArrayList;
1:eac0369: 
1:eac0369: /* -- New jdbc 20 extension types --- */
1:eac0369: import javax.sql.ConnectionEventListener;
1:eac0369: import javax.sql.ConnectionEvent;
1:99ae840: import javax.sql.StatementEvent;
1:99ae840: import javax.sql.StatementEventListener;
1:eac0369: 
2:eac0369: /** 
1:eac0369: 	A PooledConnection object is a connection object that provides hooks for
1:eac0369: 	connection pool management.
1:eac0369: 
1:b33b410: 	<P>This is Derby's implementation of a PooledConnection for use in
1:b33b410: 	the following environments:
1:b33b410: 	<UL>
1:99ae840:     <LI> JDBC 4.2 - Java SE 8 </LI>
1:99ae840:     <LI> JDBC 4.1 - Java SE 7 </LI>
1:99ae840:     <LI> JDBC 4.0 - Java SE 6 </LI>
1:b33b410: 	</UL>
1:eac0369: 
1:eac0369:  */
1:99ae840: class EmbedPooledConnection implements javax.sql.PooledConnection, BrokeredConnectionControl
4:eac0369: {
1:e214c07:     /** the connection string */
1:e214c07:     private String connString;
1:af3cf0c: 
1:af3cf0c:     /**
1:af3cf0c:      * The list of {@code ConnectionEventListener}s. It is initially {@code
1:af3cf0c:      * null} and will be initialized lazily when the first listener is added.
1:af3cf0c:      */
1:850aba4:     private ArrayList<ConnectionEventListener> eventListener;
1:af3cf0c: 
1:af3cf0c:     /**
1:99ae840:      * List of statement event listeners. The list is copied on each write,
1:99ae840:      * ensuring that it can be safely iterated over even if other threads or
1:99ae840:      * the listeners fired in the same thread add or remove listeners.
1:99ae840:      */
1:99ae840:     private final CopyOnWriteArrayList<StatementEventListener>
1:99ae840:             statementEventListeners =
1:99ae840:                     new CopyOnWriteArrayList<StatementEventListener>();
1:99ae840: 
1:99ae840:     /**
1:af3cf0c:      * The number of iterators going through the list of connection event
1:af3cf0c:      * listeners at the current time. Only one thread may be iterating over the
1:af3cf0c:      * list at any time (because of synchronization), but a single thread may
1:af3cf0c:      * have multiple iterators if for instance an event listener performs
1:af3cf0c:      * database calls that trigger a new event.
1:af3cf0c:      */
1:af3cf0c:     private int eventIterators;
1:eac0369: 
1:5b2f5de: 	EmbedConnection realConnection;
1:5b2f5de: 	int defaultIsolationLevel;
1:eac0369: 	private boolean defaultReadOnly;
1:5b2f5de: 	BrokeredConnection currentConnectionHandle;
1:eac0369: 
1:eac0369: 	// set up once by the data source
1:a086620:     final BasicEmbeddedDataSource40 dataSource;
1:eac0369: 	private final String username;
1:eac0369: 	private final String password;
1:eac0369: 	/**
1:eac0369: 		True if the password was passed in on the connection request, false if it came from the data source property.
1:eac0369: 	*/
1:eac0369: 	private final boolean requestPassword;
1:eac0369: 
1:448ecb0: 	protected boolean isActive;
1:eac0369:     
1:4c5c16b:     /**
1:4c5c16b:      * getter function for isActive
1:4c5c16b:      * @return boolean is isActive is true
1:4c5c16b:      **/
1:4c5c16b:     public boolean isActive() {
1:4c5c16b:         return isActive;
1:4c5c16b:     }
1:4c5c16b:     
1:a086620:     EmbedPooledConnection(BasicEmbeddedDataSource40 ds, String u, String p,
1:4c5c16b:             boolean requestPassword) throws SQLException
1:eac0369: 	{
1:eac0369: 		dataSource = ds;
1:eac0369: 		username = u;
1:eac0369: 		password = p;
1:eac0369: 		this.requestPassword = requestPassword;
1:eac0369: 		isActive = true;
1:eac0369: 
1:eac0369: 		// open the connection up front in order to do authentication
1:eac0369: 		openRealConnection();
1:eac0369: 
4:eac0369: 	}
1:eac0369: 
1:eac0369: 	String getUsername()
1:eac0369: 	{
1:eac0369: 		if (username == null || username.equals(""))
1:eac0369: 			return Property.DEFAULT_USER_NAME;
1:eac0369: 		else
1:eac0369: 			return username;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	String getPassword()
1:eac0369: 	{
1:eac0369: 		if (password == null)
1:eac0369: 			return "";
1:eac0369: 		else
1:eac0369: 			return password;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 		Create an object handle for a database connection.
1:eac0369: 
1:eac0369: 		@return a Connection object
1:eac0369: 
1:eac0369: 		@exception SQLException - if a database-access error occurs.
1:eac0369: 	*/
1:eac0369: 	public synchronized Connection getConnection() throws SQLException
1:eac0369: 	{
1:eac0369: 		checkActive();
1:eac0369: 
1:eac0369: 		// RealConnection is not null if the app server yanks a local
1:eac0369: 		// connection from one client and give it to another.  In this case,
1:eac0369: 		// the real connection is ready to be used.  Otherwise, set it up
1:eac0369: 		if (realConnection == null)
1:eac0369: 		{
1:eac0369: 			// first time we establish a connection
1:eac0369: 			openRealConnection();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			resetRealConnection();
1:eac0369: 		}
1:eac0369: 
1:902041a:         // Need to do this in case the connection is forcibly removed without
1:902041a:         // first being closed. Must be performed after resetRealConnection(),
1:902041a:         // otherwise closing the logical connection may fail if the transaction
1:902041a:         // is not idle.
1:902041a:         closeCurrentConnectionHandle();
1:902041a: 
1:eac0369: 		// now make a brokered connection wrapper and give this to the user
1:eac0369: 		// we reuse the EmbedConnection(ie realConnection).
1:eac0369: 		Connection c = getNewCurrentConnectionHandle();		
1:eac0369: 		return c;
1:eac0369: 	}
1:eac0369: 
1:5b2f5de: 	final void openRealConnection() throws SQLException {
1:eac0369: 		// first time we establish a connection
1:eac0369: 		Connection rc = dataSource.getConnection(username, password, requestPassword);
1:eac0369: 
1:63d26f5: 		this.realConnection = (EmbedConnection) rc;
1:eac0369: 		defaultIsolationLevel = rc.getTransactionIsolation();
1:eac0369: 		defaultReadOnly = rc.isReadOnly();
1:eac0369: 		if (currentConnectionHandle != null)
1:eac0369: 			realConnection.setApplicationConnection(currentConnectionHandle);
1:eac0369: 	}
1:eac0369: 
1:ec60014: 	final Connection getNewCurrentConnectionHandle() throws SQLException {
1:217667e: 		Connection applicationConnection = currentConnectionHandle =
1:595307e:             realConnection.getLocalDriver().newBrokeredConnection(this);
1:eac0369: 		realConnection.setApplicationConnection(applicationConnection);
1:eac0369: 		return applicationConnection;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		In this case the Listeners are *not* notified. JDBC 3.0 spec section 11.4
1:eac0369: 	*/
1:5b2f5de: 	private void closeCurrentConnectionHandle() throws SQLException {
1:eac0369: 		if (currentConnectionHandle != null)
1:eac0369: 		{
1:850aba4:             ArrayList<ConnectionEventListener> tmpEventListener = eventListener;
1:eac0369: 			eventListener = null;
1:eac0369: 
1:eac0369: 			try {
1:eac0369: 				currentConnectionHandle.close();
1:eac0369: 			} finally {
1:eac0369: 				eventListener = tmpEventListener;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			currentConnectionHandle = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:5b2f5de: 	void resetRealConnection() throws SQLException {
1:eac0369: 
1:eac0369: 		// ensure any outstanding changes from the previous
1:eac0369: 		// user are rolledback.
1:eac0369: 		realConnection.rollback();
1:eac0369: 
1:eac0369: 		// clear any warnings that are left over
1:eac0369: 		realConnection.clearWarnings();
1:eac0369: 
1:eac0369: 		// need to reset transaction isolation, autocommit, readonly, holdability states
1:eac0369: 		if (realConnection.getTransactionIsolation() != defaultIsolationLevel) {
1:eac0369: 
1:eac0369: 			realConnection.setTransactionIsolation(defaultIsolationLevel);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (!realConnection.getAutoCommit())
1:eac0369: 			realConnection.setAutoCommit(true);
1:eac0369: 
1:eac0369: 		if (realConnection.isReadOnly() != defaultReadOnly)
1:eac0369: 			realConnection.setReadOnly(defaultReadOnly);
1:eac0369: 
1:1e8a20f: 		if (realConnection.getHoldability() != ResultSet.HOLD_CURSORS_OVER_COMMIT)
1:1e8a20f: 			realConnection.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:eac0369: 
1:588f766: 		// reset any remaining state of the connection
1:588f766: 		realConnection.resetFromPool();
1:9897546: 		if (SanityManager.DEBUG)
1:9897546: 		{
1:9897546: 			SanityManager.ASSERT(realConnection.transactionIsIdle(),
1:9897546: 			"real connection should have been idle at this point"); 			
1:9897546: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Close the Pooled connection.
1:eac0369: 
1:eac0369: 		@exception SQLException - if a database-access error occurs.
1:eac0369: 	 */
1:eac0369: 	public synchronized void close() throws SQLException
1:eac0369: 	{
1:eac0369: 		if (!isActive)
1:eac0369: 			return;
1:eac0369: 
2:eac0369: 		closeCurrentConnectionHandle();
1:eac0369: 		try {
1:eac0369: 			if (realConnection != null) {
1:eac0369: 				if (!realConnection.isClosed())
1:eac0369: 					realConnection.close();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		} finally {
1:eac0369: 
1:eac0369: 			realConnection = null;	// make sure I am not accessed again.
1:eac0369: 			isActive = false;
1:eac0369: 			eventListener = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add an event listener.
1:eac0369: 	 */
1:eac0369: 	public final synchronized void addConnectionEventListener(ConnectionEventListener listener) 
1:eac0369: 	{
1:eac0369: 		if (!isActive)
1:eac0369: 			return;
2:eac0369: 		if (listener == null)
1:eac0369: 			return;
1:af3cf0c:         if (eventListener == null) {
1:850aba4:             eventListener = new ArrayList<ConnectionEventListener>();
1:af3cf0c:         } else if (eventIterators > 0) {
1:af3cf0c:             // DERBY-3401: Someone is iterating over the ArrayList, and since
1:af3cf0c:             // we were able to synchronize on this, that someone is us. Clone
1:af3cf0c:             // the list of listeners in order to prevent invalidation of the
1:af3cf0c:             // iterator.
1:850aba4:             eventListener =
1:850aba4:                 new ArrayList<ConnectionEventListener>(eventListener);
1:af3cf0c:         }
1:af3cf0c:         eventListener.add(listener);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove an event listener.
1:eac0369: 	 */
1:eac0369: 	public final synchronized void removeConnectionEventListener(ConnectionEventListener listener)
1:eac0369: 	{
1:af3cf0c:         if (listener == null || eventListener == null) {
1:eac0369: 			return;
1:af3cf0c:         }
1:af3cf0c:         if (eventIterators > 0) {
1:af3cf0c:             // DERBY-3401: Someone is iterating over the ArrayList, and since
1:af3cf0c:             // we were able to synchronize on this, that someone is us. Clone
1:af3cf0c:             // the list of listeners in order to prevent invalidation of the
1:af3cf0c:             // iterator.
1:850aba4:             eventListener =
1:850aba4:                 new ArrayList<ConnectionEventListener>(eventListener);
1:af3cf0c:         }
1:af3cf0c:         eventListener.remove(listener);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * class specific method
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	// called by ConnectionHandle when it needs to forward things to the
1:eac0369: 	// underlying connection
1:da847a2: 	public synchronized EngineConnection getRealConnection()
1:da847a2:        throws SQLException
1:eac0369: 	{
1:eac0369: 		checkActive();
1:eac0369: 
1:eac0369: 		return realConnection;
1:eac0369: 	}
1:eac0369: 
1:cccf5dd:     /**
1:cccf5dd:      * @return The underlying language connection.
1:cccf5dd:      */
1:cccf5dd: 	public synchronized LanguageConnectionContext getLanguageConnection()
1:cccf5dd:        throws SQLException
1:cccf5dd: 	{
1:cccf5dd: 		checkActive();
1:cccf5dd: 
1:cccf5dd: 		return realConnection.getLanguageConnection();
1:cccf5dd: 	}
1:cccf5dd: 
1:eac0369: 
1:eac0369: 	// my conneciton handle has caught an error (actually, the real connection
1:eac0369: 	// has already handled the error, we just need to nofity the listener an
1:eac0369: 	// error is about to be thrown to the app).
1:eac0369: 	public synchronized void notifyError(SQLException exception)
1:eac0369: 	{
1:eac0369: 		// only report fatal error to the connection pool manager 
1:eac0369: 		if (exception.getErrorCode() < ExceptionSeverity.SESSION_SEVERITY)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		// tell my listeners an exception is about to be thrown
1:af3cf0c:         fireConnectionEventListeners(exception);
1:eac0369: 	}
1:eac0369: 
1:af3cf0c:     /**
1:af3cf0c:      * Fire all the {@code ConnectionEventListener}s registered. Callers must
1:af3cf0c:      * synchronize on {@code this} to prevent others from modifying the list of
1:af3cf0c:      * listeners.
1:af3cf0c:      *
1:af3cf0c:      * @param exception the exception that caused the event, or {@code null} if
1:af3cf0c:      * it is a close event
1:af3cf0c:      */
1:af3cf0c:     private void fireConnectionEventListeners(SQLException exception) {
1:af3cf0c:         if (eventListener != null && !eventListener.isEmpty()) {
1:af3cf0c:             ConnectionEvent event = new ConnectionEvent(this, exception);
1:af3cf0c:             eventIterators++;
1:af3cf0c:             try {
1:850aba4:                 for (ConnectionEventListener l : eventListener) {
1:af3cf0c:                     if (exception == null) {
1:af3cf0c:                         l.connectionClosed(event);
1:af3cf0c:                     } else {
1:af3cf0c:                         l.connectionErrorOccurred(event);
1:99ae840:                     }
1:af3cf0c:                 }
1:af3cf0c:             } finally {
1:af3cf0c:                 eventIterators--;
1:af3cf0c:             }
1:af3cf0c:         }
1:af3cf0c:     }
1:99ae840: 
1:5b2f5de: 	final void checkActive() throws SQLException {
1:eac0369: 		if (!isActive)
1:eac0369: 			throw Util.noCurrentConnection();
1:af3cf0c: 	}
1:99ae840: 
1:99ae840: 
1:eac0369: 	/*
1:eac0369: 	** BrokeredConnectionControl api
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:08cd3aa: 		Returns true if isolation level has been set using either JDBC api or SQL
1:08cd3aa: 	 */
1:08cd3aa: 	public boolean isIsolationLevelSetUsingSQLorJDBC() throws SQLException {
1:08cd3aa: 		if (realConnection != null)
1:1ae0d7d: 			return getLanguageConnectionContext( realConnection ).isIsolationLevelSetUsingSQLorJDBC();
1:08cd3aa: 		else
1:08cd3aa: 			return false;
1:08cd3aa: 	}
1:08cd3aa: 
1:08cd3aa: 	/**
1:08cd3aa: 		Reset the isolation level flag used to keep state in 
1:08cd3aa: 		BrokeredConnection. It will get set to true when isolation level 
1:08cd3aa: 		is set using JDBC/SQL. It will get reset to false at the start
1:08cd3aa: 		and the end of a global transaction.
1:08cd3aa: 	*/
1:08cd3aa: 	public void resetIsolationLevelFlag() throws SQLException {
1:1ae0d7d: 		getLanguageConnectionContext( realConnection ).resetIsolationLevelFlagUsedForSQLandJDBC();
1:08cd3aa: 	}
1:ad40eda: 
1:ad40eda:     /** @see BrokeredConnectionControl#isInGlobalTransaction() */
1:ad40eda:     public boolean isInGlobalTransaction() {
1:ad40eda:     	return false;
1:ad40eda:     }	
1:08cd3aa: 	
1:08cd3aa: 	/**
1:eac0369: 		Notify the control class that a SQLException was thrown
1:eac0369: 		during a call on one of the brokered connection's methods.
1:eac0369: 	*/
1:eac0369: 	public void notifyException(SQLException sqle) {
1:eac0369: 		this.notifyError(sqle);
1:eac0369: 	}
1:08cd3aa: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Allow control over setting auto commit mode.
1:eac0369: 	*/
1:eac0369: 	public void checkAutoCommit(boolean autoCommit) throws SQLException {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Are held cursors allowed.
1:eac0369: 	*/
1:ce9d214: 	public int checkHoldCursors(int holdability, boolean downgrade)
1:ce9d214:         throws SQLException
1:ce9d214:     {
1:ce9d214:         return holdability;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Allow control over creating a Savepoint (JDBC 3.0)
1:eac0369: 	*/
1:eac0369: 	public void checkSavepoint() throws SQLException {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Allow control over calling rollback.
1:eac0369: 	*/
1:eac0369: 	public void checkRollback() throws SQLException {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Allow control over calling commit.
1:eac0369: 	*/
1:eac0369: 	public void checkCommit() throws SQLException {
1:eac0369: 	}
1:eac0369: 
1:902041a:     /** @see BrokeredConnectionControl#checkClose() */
1:902041a:     public void checkClose() throws SQLException {
1:902041a:         if (realConnection != null) {
1:902041a:             realConnection.checkForTransactionInProgress();
1:902041a:         }
1:902041a:     }
1:902041a: 
1:eac0369: 	/**
1:eac0369: 		Close called on BrokeredConnection. If this call
1:eac0369: 		returns true then getRealConnection().close() will be called.
1:eac0369: 		
1:eac0369: 	
1:7106c74: 	Notify listners that connection is closed.
1:eac0369: 		Don't close the underlying real connection as
1:eac0369: 		it is pooled.
1:eac0369: 	*/
1:e57849f: 	public synchronized boolean closingConnection() throws SQLException {	    
1:7106c74: 		//DERBY-2142-Null out the connection handle BEFORE notifying listeners.
1:7106c74: 		//At time of the callback the PooledConnection must be 
1:7106c74: 		//disassociated from its previous logical connection.
1:7106c74: 		//If not there is a risk that the Pooled
1:7106c74: 		//Connection could be returned to the pool, ready for pickup by a 
1:7106c74: 		//new thread. This new thread then might obtain a java.sql.Connection 
1:7106c74: 		//whose reference might get assigned to the currentConnectionHandle 
1:7106c74: 		//field, meanwhile the previous thread completes the close making 
1:7106c74: 		//the newly assigned currentConnectionHandle null, resulting in an NPE.
1:eac0369: 		currentConnectionHandle = null;
1:eac0369: 		// tell my listeners I am closed 
1:af3cf0c:         fireConnectionEventListeners(null);
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
3:eac0369: 		No need to wrap statements for PooledConnections.
1:eac0369: 	*/
1:eac0369: 	public Statement wrapStatement(Statement s) throws SQLException {
1:eac0369: 		return s;
1:eac0369: 	}
1:eac0369: 	/**
1:448ecb0:          * Call the setBrokeredConnectionControl method inside the 
1:448ecb0:          * EmbedPreparedStatement class to set the BrokeredConnectionControl 
1:448ecb0:          * variable to this instance of EmbedPooledConnection
1:448ecb0:          * This will then be used to call the onStatementErrorOccurred
1:448ecb0:          * and onStatementClose events when the corresponding events
1:448ecb0:          * occur on the PreparedStatement
1:448ecb0:          *
1:448ecb0:          * @param  ps            PreparedStatment to be wrapped
1:448ecb0:          * @param  sql           String
1:448ecb0:          * @param  generatedKeys Object
1:448ecb0:          * @return returns the wrapped PreparedStatement
1:448ecb0:          * @throws java.sql.SQLException
1:448ecb0: 	 */
1:eac0369: 	public PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {
1:448ecb0:                /*
1:448ecb0:                     
1:448ecb0:                 */
1:448ecb0:                 EmbedPreparedStatement ps_ = (EmbedPreparedStatement)ps;
1:448ecb0:                 ps_.setBrokeredConnectionControl(this);
1:448ecb0: 		return (PreparedStatement)ps_;
1:eac0369: 	}
1:448ecb0:         
1:448ecb0:         /**
1:448ecb0:          * Call the setBrokeredConnectionControl method inside the 
1:448ecb0:          * EmbedCallableStatement class to set the BrokeredConnectionControl 
1:448ecb0:          * variable to this instance of EmbedPooledConnection
1:448ecb0:          * This will then be used to call the onStatementErrorOccurred
1:448ecb0:          * and onStatementClose events when the corresponding events
1:448ecb0:          * occur on the CallableStatement
1:448ecb0:          *
1:448ecb0:          * @param  cs            CallableStatment to be wrapped
1:448ecb0:          * @param  sql           String
1:448ecb0:          * @return returns the wrapped CallableStatement
1:448ecb0:          * @throws java.sql.SQLException
1:448ecb0: 	 */
1:eac0369: 	public CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {
1:448ecb0:                 EmbedCallableStatement cs_ = (EmbedCallableStatement)cs;
1:448ecb0:                 cs_.setBrokeredConnectionControl(this);
1:448ecb0: 		return (CallableStatement)cs_;
1:eac0369: 	}
1:eac0369:     
1:eac0369:     /** 
1:1d2a569:      * Get the string representation of this pooled connection.
1:1d2a569:      *
1:1d2a569:      * A pooled connection is assigned a separate id from a physical 
1:1d2a569:      * connection. When a container calls PooledConnection.toString(), 
1:1d2a569:      * it gets the string representation of this id. This is useful for 
1:1d2a569:      * developers implementing connection pools when they are trying to
1:1d2a569:      * debug pooled connections. 
1:1d2a569:      *
1:1d2a569:      * @return a string representation of the uniquie id for this pooled
1:1d2a569:      *    connection.
1:1d2a569:      *
1:eac0369:      */
1:1d2a569:     public String toString()
1:eac0369:     {
1:e214c07:         if ( connString == null )
1:eac0369:         {
1:e214c07:             String physicalConnString = isActive ?
1:e214c07:                 realConnection.toString() : "<none>";
1:eac0369:             
1:e214c07:             connString = 
1:e214c07:               this.getClass().getName() + "@" + this.hashCode() + " " +
1:e214c07:                 "Physical Connection = " + physicalConnString;
1:eac0369:         }    
1:eac0369:         
1:e214c07:         return connString;
1:eac0369:     }
1:448ecb0:     
1:448ecb0:     /*-----------------------------------------------------------------*/
1:448ecb0:     /*
1:448ecb0:      * These methods are from the BrokeredConnectionControl interface.
1:448ecb0:      * These methods are needed to provide StatementEvent support for
1:448ecb0:      * derby.
1:448ecb0:      */
1:448ecb0: 
1:448ecb0:     /**
1:99ae840:      * Raise the statementClosed event for all the listeners when the
1:99ae840:      * corresponding events occurs
1:99ae840:      *
1:99ae840:      * @param statement the {@code PreparedStatement} that was closed
1:448ecb0:      */
1:448ecb0:     public void onStatementClose(PreparedStatement statement) {
1:99ae840:         if (!statementEventListeners.isEmpty()) {
1:99ae840:             StatementEvent event = new StatementEvent(this, statement);
1:99ae840:             for (StatementEventListener l : statementEventListeners) {
1:99ae840:                 l.statementClosed(event);
1:448ecb0:             }
1:99ae840:         }
1:99ae840:     }
1:448ecb0: 
1:448ecb0:     /**
1:99ae840:      * Raise the statementErrorOccurred event for all the listeners when the
1:99ae840:      * corresponding events occurs
1:99ae840:      *
1:99ae840:      * @param statement the {@code PreparedStatement} in which the
1:99ae840:      *                  error occurred
1:99ae840:      * @param sqle the {@code SQLException} that was thrown
1:448ecb0:      */
1:448ecb0:     public void onStatementErrorOccurred(PreparedStatement statement,
1:448ecb0:             SQLException sqle) {
1:99ae840:         if (!statementEventListeners.isEmpty()) {
1:99ae840:             StatementEvent event = new StatementEvent(this, statement, sqle);
1:99ae840:             for (StatementEventListener l : statementEventListeners) {
1:99ae840:                 l.statementErrorOccurred(event);
1:448ecb0:             }
1:99ae840:         }
1:99ae840:     }
1:448ecb0: 
1:99ae840:     // JDBC 4.0 methods
1:448ecb0: 
1:99ae840:     /**
1:99ae840:      * Removes the specified {@code StatementEventListener} from the list of
1:99ae840:      * components that will be notified when the driver detects that a
1:99ae840:      * {@code PreparedStatement} has been closed or is invalid.
1:99ae840:      *
1:99ae840:      * @param listener the component which implements the
1:99ae840:      * {@code StatementEventListener} interface that was previously registered
1:99ae840:      * with this {@code PooledConnection} object
1:99ae840:      */
1:99ae840:     public void removeStatementEventListener(StatementEventListener listener) {
1:99ae840:         if (listener != null) {
1:99ae840:             statementEventListeners.remove(listener);
1:99ae840:         }
1:99ae840:     }
1:99ae840: 
1:99ae840:     /**
1:99ae840:      * Registers a {@code StatementEventListener} with this
1:99ae840:      * {@code PooledConnection} object. Components that wish to be notified when
1:99ae840:      * {@code PreparedStatement}s created by the connection are closed or are
1:99ae840:      * detected to be invalid may use this method to register a
1:99ae840:      * {@code StatementEventListener} with this {@code PooledConnection} object.
1:99ae840:      *
1:99ae840:      * @param listener an component which implements the
1:99ae840:      * {@code StatementEventListener} interface that is to be registered with
1:99ae840:      * this {@code PooledConnection} object
1:99ae840:      */
1:99ae840:     public void addStatementEventListener(StatementEventListener listener) {
1:99ae840:         if (isActive && listener != null) {
1:99ae840:             statementEventListeners.add(listener);
1:99ae840:         }
1:eac0369:     }
1:1ae0d7d:     
1:1ae0d7d: 	/**
1:1ae0d7d: 	  *	Gets the LanguageConnectionContext for this connection.
1:1ae0d7d: 	  */
1:1ae0d7d: 	private static LanguageConnectionContext	getLanguageConnectionContext( final EmbedConnection conn )
1:1ae0d7d: 	{
1:1ae0d7d:         return AccessController.doPrivileged
1:1ae0d7d:             (
1:1ae0d7d:              new PrivilegedAction<LanguageConnectionContext>()
1:1ae0d7d:              {
1:1ae0d7d:                  public LanguageConnectionContext run()
1:1ae0d7d:                  {
1:1ae0d7d:                      return conn.getLanguageConnection();
1:1ae0d7d:                  }
1:1ae0d7d:              }
1:1ae0d7d:              );
1:1ae0d7d: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:1ae0d7d
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 			return getLanguageConnectionContext( realConnection ).isIsolationLevelSetUsingSQLorJDBC();
/////////////////////////////////////////////////////////////////////////
1: 		getLanguageConnectionContext( realConnection ).resetIsolationLevelFlagUsedForSQLandJDBC();
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/**
1: 	  *	Gets the LanguageConnectionContext for this connection.
1: 	  */
1: 	private static LanguageConnectionContext	getLanguageConnectionContext( final EmbedConnection conn )
1: 	{
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<LanguageConnectionContext>()
1:              {
1:                  public LanguageConnectionContext run()
1:                  {
1:                      return conn.getLanguageConnection();
1:                  }
1:              }
1:              );
1: 	}
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: abstract class EmbedPooledConnection implements javax.sql.PooledConnection, BrokeredConnectionControl
commit:448ecb0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.jdbc.EmbedPreparedStatement;
1: import org.apache.derby.impl.jdbc.EmbedCallableStatement;
/////////////////////////////////////////////////////////////////////////
1: 	protected boolean isActive;
/////////////////////////////////////////////////////////////////////////
1:          * Call the setBrokeredConnectionControl method inside the 
1:          * EmbedPreparedStatement class to set the BrokeredConnectionControl 
1:          * variable to this instance of EmbedPooledConnection
1:          * This will then be used to call the onStatementErrorOccurred
1:          * and onStatementClose events when the corresponding events
1:          * occur on the PreparedStatement
1:          *
1:          * @param  ps            PreparedStatment to be wrapped
1:          * @param  sql           String
1:          * @param  generatedKeys Object
1:          * @return returns the wrapped PreparedStatement
1:          * @throws java.sql.SQLException
1: 	 */
1:                /*
1:                     
1:                 */
1:                 EmbedPreparedStatement ps_ = (EmbedPreparedStatement)ps;
1:                 ps_.setBrokeredConnectionControl(this);
1: 		return (PreparedStatement)ps_;
1:         
1:         /**
1:          * Call the setBrokeredConnectionControl method inside the 
1:          * EmbedCallableStatement class to set the BrokeredConnectionControl 
1:          * variable to this instance of EmbedPooledConnection
1:          * This will then be used to call the onStatementErrorOccurred
1:          * and onStatementClose events when the corresponding events
1:          * occur on the CallableStatement
1:          *
1:          * @param  cs            CallableStatment to be wrapped
1:          * @param  sql           String
1:          * @return returns the wrapped CallableStatement
1:          * @throws java.sql.SQLException
1: 	 */
1:                 EmbedCallableStatement cs_ = (EmbedCallableStatement)cs;
1:                 cs_.setBrokeredConnectionControl(this);
1: 		return (CallableStatement)cs_;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*-----------------------------------------------------------------*/
1:     /*
1:      * These methods are from the BrokeredConnectionControl interface. 
1:      * These methods are needed to provide StatementEvent support for 
1:      * derby. 
0:      * They are actually implemented in EmbedPooledConnection40 but have
0:      * a dummy implementation here so that the compilation wont fail when they
0:      * are compiled with jdk1.4
1:      */
1:     
1:     /**
0:      * Dummy implementation for the actual methods found in 
0:      * org.apache.derby.jdbc.EmbedPooledConnection40
0:      * @param statement PreparedStatement
1:      */
1:     public void onStatementClose(PreparedStatement statement) {
1:         
1:     }
1:     
1:     /**
0:      * Dummy implementation for the actual methods found in 
0:      * org.apache.derby.jdbc.EmbedPooledConnection40
0:      * @param statement PreparedStatement
0:      * @param sqle      SQLException 
1:      */
1:     public void onStatementErrorOccurred(PreparedStatement statement,
1:             SQLException sqle) {
1:         
1:     }
commit:b33b410
/////////////////////////////////////////////////////////////////////////
1: 	<P>This is Derby's implementation of a PooledConnection for use in
1: 	the following environments:
1: 	<UL>
0: 	<LI> JDBC 3.0 - Java 2 - JDK 1.4, J2SE 5.0
0: 	<LI> JDBC 2.0 - Java 2 - JDK 1.2,1.3
1: 	</UL>
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a086620
/////////////////////////////////////////////////////////////////////////
1:     final BasicEmbeddedDataSource40 dataSource;
/////////////////////////////////////////////////////////////////////////
1:     EmbedPooledConnection(BasicEmbeddedDataSource40 ds, String u, String p,
commit:eea0d50
/////////////////////////////////////////////////////////////////////////
0:     final EmbeddedBaseDataSource dataSource;
commit:58bf06e
/////////////////////////////////////////////////////////////////////////
0:    final EmbeddedBaseDataSource dataSource;
/////////////////////////////////////////////////////////////////////////
0:     EmbedPooledConnection(EmbeddedBaseDataSource ds, String u, String p,
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:99ae840
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import javax.sql.StatementEvent;
1: import javax.sql.StatementEventListener;
/////////////////////////////////////////////////////////////////////////
1:     <LI> JDBC 4.2 - Java SE 8 </LI>
1:     <LI> JDBC 4.1 - Java SE 7 </LI>
1:     <LI> JDBC 4.0 - Java SE 6 </LI>
1: class EmbedPooledConnection implements javax.sql.PooledConnection, BrokeredConnectionControl
/////////////////////////////////////////////////////////////////////////
1:      * List of statement event listeners. The list is copied on each write,
1:      * ensuring that it can be safely iterated over even if other threads or
1:      * the listeners fired in the same thread add or remove listeners.
1:      */
1:     private final CopyOnWriteArrayList<StatementEventListener>
1:             statementEventListeners =
1:                     new CopyOnWriteArrayList<StatementEventListener>();
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:      * These methods are from the BrokeredConnectionControl interface.
0:      * These methods are needed to provide StatementEvent support for
0:      * derby.
1: 
1:      * Raise the statementClosed event for all the listeners when the
1:      * corresponding events occurs
1:      *
1:      * @param statement the {@code PreparedStatement} that was closed
1:         if (!statementEventListeners.isEmpty()) {
1:             StatementEvent event = new StatementEvent(this, statement);
1:             for (StatementEventListener l : statementEventListeners) {
1:                 l.statementClosed(event);
1:             }
1:         }
1: 
1:      * Raise the statementErrorOccurred event for all the listeners when the
1:      * corresponding events occurs
1:      *
1:      * @param statement the {@code PreparedStatement} in which the
1:      *                  error occurred
1:      * @param sqle the {@code SQLException} that was thrown
1:         if (!statementEventListeners.isEmpty()) {
1:             StatementEvent event = new StatementEvent(this, statement, sqle);
1:             for (StatementEventListener l : statementEventListeners) {
1:                 l.statementErrorOccurred(event);
1:             }
1:         }
1:     }
1: 
1:     // JDBC 4.0 methods
1: 
1:     /**
1:      * Removes the specified {@code StatementEventListener} from the list of
1:      * components that will be notified when the driver detects that a
1:      * {@code PreparedStatement} has been closed or is invalid.
1:      *
1:      * @param listener the component which implements the
1:      * {@code StatementEventListener} interface that was previously registered
1:      * with this {@code PooledConnection} object
1:      */
1:     public void removeStatementEventListener(StatementEventListener listener) {
1:         if (listener != null) {
1:             statementEventListeners.remove(listener);
1:         }
1:     }
1: 
1:     /**
1:      * Registers a {@code StatementEventListener} with this
1:      * {@code PooledConnection} object. Components that wish to be notified when
1:      * {@code PreparedStatement}s created by the connection are closed or are
1:      * detected to be invalid may use this method to register a
1:      * {@code StatementEventListener} with this {@code PooledConnection} object.
1:      *
1:      * @param listener an component which implements the
1:      * {@code StatementEventListener} interface that is to be registered with
1:      * this {@code PooledConnection} object
1:      */
1:     public void addStatementEventListener(StatementEventListener listener) {
1:         if (isActive && listener != null) {
1:             statementEventListeners.add(listener);
1:         }
commit:595307e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             realConnection.getLocalDriver().newBrokeredConnection(this);
commit:850aba4
/////////////////////////////////////////////////////////////////////////
1:     private ArrayList<ConnectionEventListener> eventListener;
/////////////////////////////////////////////////////////////////////////
1:             ArrayList<ConnectionEventListener> tmpEventListener = eventListener;
/////////////////////////////////////////////////////////////////////////
1:             eventListener = new ArrayList<ConnectionEventListener>();
1:             eventListener =
1:                 new ArrayList<ConnectionEventListener>(eventListener);
/////////////////////////////////////////////////////////////////////////
1:             eventListener =
1:                 new ArrayList<ConnectionEventListener>(eventListener);
/////////////////////////////////////////////////////////////////////////
1:                 for (ConnectionEventListener l : eventListener) {
commit:ec60014
/////////////////////////////////////////////////////////////////////////
1: 	final Connection getNewCurrentConnectionHandle() throws SQLException {
commit:902041a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Need to do this in case the connection is forcibly removed without
1:         // first being closed. Must be performed after resetRealConnection(),
1:         // otherwise closing the logical connection may fail if the transaction
1:         // is not idle.
1:         closeCurrentConnectionHandle();
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** @see BrokeredConnectionControl#checkClose() */
1:     public void checkClose() throws SQLException {
1:         if (realConnection != null) {
1:             realConnection.checkForTransactionInProgress();
1:         }
1:     }
1: 
commit:af3cf0c
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * The list of {@code ConnectionEventListener}s. It is initially {@code
1:      * null} and will be initialized lazily when the first listener is added.
1:      */
0:     private ArrayList eventListener;
1: 
1:     /**
1:      * The number of iterators going through the list of connection event
1:      * listeners at the current time. Only one thread may be iterating over the
1:      * list at any time (because of synchronization), but a single thread may
1:      * have multiple iterators if for instance an event listener performs
1:      * database calls that trigger a new event.
1:      */
1:     private int eventIterators;
/////////////////////////////////////////////////////////////////////////
0: 			ArrayList tmpEventListener = eventListener;
/////////////////////////////////////////////////////////////////////////
1:         if (eventListener == null) {
0:             eventListener = new ArrayList();
1:         } else if (eventIterators > 0) {
1:             // DERBY-3401: Someone is iterating over the ArrayList, and since
1:             // we were able to synchronize on this, that someone is us. Clone
1:             // the list of listeners in order to prevent invalidation of the
1:             // iterator.
0:             eventListener = (ArrayList) eventListener.clone();
1:         }
1:         eventListener.add(listener);
/////////////////////////////////////////////////////////////////////////
1:         if (listener == null || eventListener == null) {
1:         }
1:         if (eventIterators > 0) {
1:             // DERBY-3401: Someone is iterating over the ArrayList, and since
1:             // we were able to synchronize on this, that someone is us. Clone
1:             // the list of listeners in order to prevent invalidation of the
1:             // iterator.
0:             eventListener = (ArrayList) eventListener.clone();
1:         }
1:         eventListener.remove(listener);
/////////////////////////////////////////////////////////////////////////
1:         fireConnectionEventListeners(exception);
1:     /**
1:      * Fire all the {@code ConnectionEventListener}s registered. Callers must
1:      * synchronize on {@code this} to prevent others from modifying the list of
1:      * listeners.
1:      *
1:      * @param exception the exception that caused the event, or {@code null} if
1:      * it is a close event
1:      */
1:     private void fireConnectionEventListeners(SQLException exception) {
1:         if (eventListener != null && !eventListener.isEmpty()) {
1:             ConnectionEvent event = new ConnectionEvent(this, exception);
1:             eventIterators++;
1:             try {
0:                 for (Iterator it = eventListener.iterator(); it.hasNext();) {
0:                     ConnectionEventListener l =
0:                             (ConnectionEventListener) it.next();
1:                     if (exception == null) {
1:                         l.connectionClosed(event);
1:                     } else {
1:                         l.connectionErrorOccurred(event);
1:                     }
1:                 }
1:             } finally {
1:                 eventIterators--;
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         fireConnectionEventListeners(null);
commit:cccf5dd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return The underlying language connection.
1:      */
1: 	public synchronized LanguageConnectionContext getLanguageConnection()
1:        throws SQLException
1: 	{
1: 		checkActive();
1: 
1: 		return realConnection.getLanguageConnection();
1: 	}
1: 
author:Lily Wei
-------------------------------------------------------------------------------
commit:4c5c16b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * getter function for isActive
1:      * @return boolean is isActive is true
1:      **/
1:     public boolean isActive() {
1:         return isActive;
1:     }
1:     
0:     EmbedPooledConnection(ReferenceableDataSource ds, String u, String p,
1:             boolean requestPassword) throws SQLException
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:1931160
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:ad40eda
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** @see BrokeredConnectionControl#isInGlobalTransaction() */
1:     public boolean isInGlobalTransaction() {
1:     	return false;
1:     }	
commit:9897546
/////////////////////////////////////////////////////////////////////////
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(realConnection.transactionIsIdle(),
1: 			"real connection should have been idle at this point"); 			
1: 		}
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1: 		if (realConnection.getHoldability() != ResultSet.HOLD_CURSORS_OVER_COMMIT)
1: 			realConnection.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
commit:ce9d214
/////////////////////////////////////////////////////////////////////////
1: 	public int checkHoldCursors(int holdability, boolean downgrade)
1:         throws SQLException
1:     {
1:         return holdability;
commit:da847a2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineConnection;
/////////////////////////////////////////////////////////////////////////
1: 	public synchronized EngineConnection getRealConnection()
1:        throws SQLException
/////////////////////////////////////////////////////////////////////////
commit:5b2f5de
/////////////////////////////////////////////////////////////////////////
1: 	EmbedConnection realConnection;
1: 	int defaultIsolationLevel;
1: 	BrokeredConnection currentConnectionHandle;
0: 	final ReferenceableDataSource dataSource;
/////////////////////////////////////////////////////////////////////////
1: 	final void openRealConnection() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0: 	final Connection getNewCurrentConnectionHandle() {
/////////////////////////////////////////////////////////////////////////
1: 	private void closeCurrentConnectionHandle() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	void resetRealConnection() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	final void checkActive() throws SQLException {
commit:08cd3aa
/////////////////////////////////////////////////////////////////////////
1: 		Returns true if isolation level has been set using either JDBC api or SQL
1: 	 */
1: 	public boolean isIsolationLevelSetUsingSQLorJDBC() throws SQLException {
1: 		if (realConnection != null)
0: 			return realConnection.getLanguageConnection().isIsolationLevelSetUsingSQLorJDBC();
1: 		else
1: 			return false;
1: 	}
1: 
1: 	/**
1: 		Reset the isolation level flag used to keep state in 
1: 		BrokeredConnection. It will get set to true when isolation level 
1: 		is set using JDBC/SQL. It will get reset to false at the start
1: 		and the end of a global transaction.
1: 	*/
1: 	public void resetIsolationLevelFlag() throws SQLException {
0: 		realConnection.getLanguageConnection().resetIsolationLevelFlagUsedForSQLandJDBC();
1: 	}
1: 	
1: 	
1: 	/**
commit:63d26f5
/////////////////////////////////////////////////////////////////////////
0:    Copyright 2001, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.jdbc.EmbedConnection;
/////////////////////////////////////////////////////////////////////////
0: 	protected EmbedConnection realConnection;
/////////////////////////////////////////////////////////////////////////
1: 		this.realConnection = (EmbedConnection) rc;
commit:588f766
/////////////////////////////////////////////////////////////////////////
1: 		// reset any remaining state of the connection
1: 		realConnection.resetFromPool();
commit:df9af89
/////////////////////////////////////////////////////////////////////////
0: 			for (Enumeration e = eventListener.elements();
0: 				 e.hasMoreElements(); )
0: 					(ConnectionEventListener)e.nextElement();
/////////////////////////////////////////////////////////////////////////
0: 			for (Enumeration e = eventListener.elements();
0: 				 e.hasMoreElements(); )
0: 					(ConnectionEventListener)e.nextElement();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.jdbc.EmbedPooledConnection
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:217667e
/////////////////////////////////////////////////////////////////////////
1: 		Connection applicationConnection = currentConnectionHandle =
0: 			((org.apache.derby.jdbc.Driver20) (realConnection.getLocalDriver())).newBrokeredConnection(this);
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.jdbc
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.jdbc;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
1: /* import impl class */
1: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.EmbedConnection20;
1: import org.apache.derby.iapi.jdbc.BrokeredConnection;
1: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
1: 
1: 
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.CallableStatement;
1: 
0: import java.util.Vector;
0: import java.util.Enumeration;
1: 
1: /* -- New jdbc 20 extension types --- */
0: import javax.sql.DataSource;
0: import javax.sql.PooledConnection;
1: import javax.sql.ConnectionEventListener;
1: import javax.sql.ConnectionEvent;
1: 
1: /** 
1: 	A PooledConnection object is a connection object that provides hooks for
1: 	connection pool management.
1: 
0: 	<P>This is Cloudscape's implementation of a PooledConnection.  
1: 
1:  */
0: class EmbedPooledConnection implements javax.sql.PooledConnection, BrokeredConnectionControl
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
1: 
0: 	private Vector eventListener; // who wants to know I am closed or error
1: 
0: 	protected EmbedConnection20 realConnection;
0: 	protected int defaultIsolationLevel;
1: 	private boolean defaultReadOnly;
0: 	protected BrokeredConnection currentConnectionHandle;
1: 
1: 	// set up once by the data source
0: 	protected final ReferenceableDataSource dataSource;
1: 	private final String username;
1: 	private final String password;
1: 	/**
1: 		True if the password was passed in on the connection request, false if it came from the data source property.
1: 	*/
1: 	private final boolean requestPassword;
1: 
0: 	private boolean isActive;
1: 
0: 	EmbedPooledConnection(ReferenceableDataSource ds, String u, String p, boolean requestPassword) throws SQLException
1: 	{
1: 		dataSource = ds;
1: 		username = u;
1: 		password = p;
1: 		this.requestPassword = requestPassword;
1: 		isActive = true;
1: 
1: 		// open the connection up front in order to do authentication
1: 		openRealConnection();
1: 
1: 	}
1: 
1: 	String getUsername()
1: 	{
1: 		if (username == null || username.equals(""))
1: 			return Property.DEFAULT_USER_NAME;
1: 		else
1: 			return username;
1: 	}
1: 
1: 	String getPassword()
1: 	{
1: 		if (password == null)
1: 			return "";
1: 		else
1: 			return password;
1: 	}
1: 
1: 
1: 	/** 
1: 		Create an object handle for a database connection.
1: 
1: 		@return a Connection object
1: 
1: 		@exception SQLException - if a database-access error occurs.
1: 	*/
1: 	public synchronized Connection getConnection() throws SQLException
1: 	{
1: 		checkActive();
1: 
0: 		// need to do this in case the connection is forcibly removed without
0: 		// first being closed.
1: 		closeCurrentConnectionHandle();
1: 
1: 
1: 		// RealConnection is not null if the app server yanks a local
1: 		// connection from one client and give it to another.  In this case,
1: 		// the real connection is ready to be used.  Otherwise, set it up
1: 		if (realConnection == null)
1: 		{
1: 			// first time we establish a connection
1: 			openRealConnection();
1: 		}
1: 		else
1: 		{
1: 			resetRealConnection();
1: 		}
1: 
1: 		// now make a brokered connection wrapper and give this to the user
1: 		// we reuse the EmbedConnection(ie realConnection).
1: 		Connection c = getNewCurrentConnectionHandle();		
1: 		return c;
1: 	}
1: 
0: 	protected final void openRealConnection() throws SQLException {
1: 		// first time we establish a connection
1: 		Connection rc = dataSource.getConnection(username, password, requestPassword);
1: 
0: 		this.realConnection = (EmbedConnection20) rc;
1: 		defaultIsolationLevel = rc.getTransactionIsolation();
1: 		defaultReadOnly = rc.isReadOnly();
1: 		if (currentConnectionHandle != null)
1: 			realConnection.setApplicationConnection(currentConnectionHandle);
1: 	}
1: 
0: 	protected final Connection getNewCurrentConnectionHandle() {
0: 		Connection applicationConnection = currentConnectionHandle =  realConnection.getLocalDriver().newBrokeredConnection(this);
1: 		realConnection.setApplicationConnection(applicationConnection);
1: 		return applicationConnection;
1: 
1: 	}
1: 
1: 	/**
1: 		In this case the Listeners are *not* notified. JDBC 3.0 spec section 11.4
1: 	*/
0: 	protected void closeCurrentConnectionHandle() throws SQLException {
1: 		if (currentConnectionHandle != null)
1: 		{
0: 			Vector tmpEventListener = eventListener;
1: 			eventListener = null;
1: 
1: 			try {
1: 				currentConnectionHandle.close();
1: 			} finally {
1: 				eventListener = tmpEventListener;
1: 			}
1: 
1: 			currentConnectionHandle = null;
1: 		}
1: 	}
1: 
0: 	protected void resetRealConnection() throws SQLException {
1: 
1: 		// ensure any outstanding changes from the previous
1: 		// user are rolledback.
1: 		realConnection.rollback();
1: 
1: 		// clear any warnings that are left over
1: 		realConnection.clearWarnings();
1: 
1: 		// need to reset transaction isolation, autocommit, readonly, holdability states
1: 		if (realConnection.getTransactionIsolation() != defaultIsolationLevel) {
1: 
1: 			realConnection.setTransactionIsolation(defaultIsolationLevel);
1: 		}
1: 
1: 		if (!realConnection.getAutoCommit())
1: 			realConnection.setAutoCommit(true);
1: 
1: 		if (realConnection.isReadOnly() != defaultReadOnly)
1: 			realConnection.setReadOnly(defaultReadOnly);
1: 
0: 		if (realConnection.getHoldability() != JDBC30Translation.HOLD_CURSORS_OVER_COMMIT)
0: 			realConnection.setHoldability(JDBC30Translation.HOLD_CURSORS_OVER_COMMIT);
1: 
0: 		// drop any temporary tables that may have been declared by the previous user
0: 		realConnection.dropAllDeclaredGlobalTempTables();
1: 	}
1: 
1: 	/**
1: 		Close the Pooled connection.
1: 
1: 		@exception SQLException - if a database-access error occurs.
1: 	 */
1: 	public synchronized void close() throws SQLException
1: 	{
1: 		if (!isActive)
1: 			return;
1: 
1: 		closeCurrentConnectionHandle();
1: 		try {
1: 			if (realConnection != null) {
1: 				if (!realConnection.isClosed())
1: 					realConnection.close();
1: 			}
1: 
1: 		} finally {
1: 
1: 			realConnection = null;	// make sure I am not accessed again.
1: 			isActive = false;
1: 			eventListener = null;
1: 		}
1: 	}
1: 
1: 	/**
1: 		Add an event listener.
1: 	 */
1: 	public final synchronized void addConnectionEventListener(ConnectionEventListener listener) 
1: 	{
1: 		if (!isActive)
1: 			return;
1: 		if (listener == null)
1: 			return;
0: 		if (eventListener == null)
0: 			eventListener = new Vector();
0: 		eventListener.addElement(listener);
1: 	}
1: 
1: 	/**
1: 		Remove an event listener.
1: 	 */
1: 	public final synchronized void removeConnectionEventListener(ConnectionEventListener listener)
1: 	{
1: 		if (listener == null)
1: 			return;
0: 		if (eventListener != null)
0: 			eventListener.removeElement(listener);
1: 	}
1: 
1: 	/*
1: 	 * class specific method
1: 	 */
1: 
1: 	// called by ConnectionHandle when it needs to forward things to the
1: 	// underlying connection
0: 	public synchronized Connection getRealConnection() throws SQLException
1: 	{
1: 		checkActive();
1: 
1: 		return realConnection;
1: 	}
1: 
1: 
1: 	// my conneciton handle has caught an error (actually, the real connection
1: 	// has already handled the error, we just need to nofity the listener an
1: 	// error is about to be thrown to the app).
1: 	public synchronized void notifyError(SQLException exception)
1: 	{
1: 		// only report fatal error to the connection pool manager 
1: 		if (exception.getErrorCode() < ExceptionSeverity.SESSION_SEVERITY)
1: 			return;
1: 
1: 		// tell my listeners an exception is about to be thrown
0: 		if (eventListener != null && eventListener.size() > 0)
1: 		{
0: 			ConnectionEvent errorEvent = new ConnectionEvent(this, exception);
1: 
0: 			for (Enumeration enum = eventListener.elements();
0: 				 enum.hasMoreElements(); )
1: 			{
0: 				ConnectionEventListener l =
0: 					(ConnectionEventListener)enum.nextElement(); 
0: 				l.connectionErrorOccurred(errorEvent);
1: 			}
1: 		}
1: 	}
1: 
0: 	// my conneciton handle is being closed
0: 	public synchronized void notifyClose()
1: 	{
1: 		// tell my listeners I am closed 
0: 		if (eventListener != null && eventListener.size() > 0)
1: 		{
0: 			ConnectionEvent closeEvent = new ConnectionEvent(this);
1: 
0: 			for (Enumeration enum = eventListener.elements();
0: 				 enum.hasMoreElements(); )
1: 			{
0: 				ConnectionEventListener l =
0: 					(ConnectionEventListener)enum.nextElement(); 
0: 				l.connectionClosed(closeEvent);
1: 			}
1: 		}
1: 	}
1: 
0: 	protected final void checkActive() throws SQLException {
1: 		if (!isActive)
1: 			throw Util.noCurrentConnection();
1: 	}
1: 
1: 
1: 	/*
1: 	** BrokeredConnectionControl api
1: 	*/
1: 
1: 	/**
1: 		Notify the control class that a SQLException was thrown
1: 		during a call on one of the brokered connection's methods.
1: 	*/
1: 	public void notifyException(SQLException sqle) {
1: 		this.notifyError(sqle);
1: 	}
1: 
1: 
1: 	/**
1: 		Allow control over setting auto commit mode.
1: 	*/
1: 	public void checkAutoCommit(boolean autoCommit) throws SQLException {
1: 	}
1: 
1: 	/**
1: 		Are held cursors allowed.
1: 	*/
0: 	public void checkHoldCursors(int holdability) throws SQLException {
1: 	}
1: 
1: 	/**
1: 		Allow control over creating a Savepoint (JDBC 3.0)
1: 	*/
1: 	public void checkSavepoint() throws SQLException {
1: 	}
1: 
1: 	/**
1: 		Allow control over calling rollback.
1: 	*/
1: 	public void checkRollback() throws SQLException {
1: 	}
1: 
1: 	/**
1: 		Allow control over calling commit.
1: 	*/
1: 	public void checkCommit() throws SQLException {
1: 	}
1: 
1: 	/**
1: 		Close called on BrokeredConnection. If this call
1: 		returns true then getRealConnection().close() will be called.
1: 
1: 		Don't close the underlying real connection as
1: 		it is pooled.
1: 	*/
0: 	public boolean closingConnection() throws SQLException {
0: 		notifyClose();
1: 		currentConnectionHandle = null;
1: 		return false;
1: 	}
1: 
1: 	/**
1: 		No need to wrap statements for PooledConnections.
1: 	*/
1: 	public Statement wrapStatement(Statement s) throws SQLException {
1: 		return s;
1: 	}
1: 	/**
1: 		No need to wrap statements for PooledConnections.
1: 	*/
1: 	public PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {
0: 		return ps;
1: 	}
1: 	/**
1: 		No need to wrap statements for PooledConnections.
1: 	*/
1: 	public CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {
0: 		return cs;
1: 	}
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:7106c74
/////////////////////////////////////////////////////////////////////////
0: 	
1: 	Notify listners that connection is closed.
1: 		//DERBY-2142-Null out the connection handle BEFORE notifying listeners.
1: 		//At time of the callback the PooledConnection must be 
1: 		//disassociated from its previous logical connection.
1: 		//If not there is a risk that the Pooled
1: 		//Connection could be returned to the pool, ready for pickup by a 
1: 		//new thread. This new thread then might obtain a java.sql.Connection 
1: 		//whose reference might get assigned to the currentConnectionHandle 
1: 		//field, meanwhile the previous thread completes the close making 
1: 		//the newly assigned currentConnectionHandle null, resulting in an NPE.
commit:e57849f
/////////////////////////////////////////////////////////////////////////
0:        
/////////////////////////////////////////////////////////////////////////
0: 		
0: 		Notify listners that connection is closed.
1: 	public synchronized boolean closingConnection() throws SQLException {	    
0: 		//DERBY-2142 - Null out the connection handle BEFORE notifying listeners.
0: 		// tell my listeners I am closed 
0: 		if (eventListener != null && eventListener.size() > 0)
0: 		{
0: 			ConnectionEvent closeEvent = new ConnectionEvent(this);
0: 
0: 			for (Enumeration e = eventListener.elements();
0: 				 e.hasMoreElements(); )
0: 			{
0: 				ConnectionEventListener l =
0: 					(ConnectionEventListener)e.nextElement();
0: 				l.connectionClosed(closeEvent);
0: 			}
0: 		}
0: 
commit:1d2a569
/////////////////////////////////////////////////////////////////////////
0:     /** Static counter for connection ids */
0:     private static int idCounter = 0;
0:     
0:     /** The id for this connection.  */
0:     private int connectionId;
0:     
0:     /** String representation of id */
0:     private String idString;
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     private synchronized int nextId()
0:     {
0:         return idCounter++;
0:     }
0:         connectionId = nextId();
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     /** 
1:      * Get the string representation of this pooled connection.
1:      *
1:      * A pooled connection is assigned a separate id from a physical 
1:      * connection. When a container calls PooledConnection.toString(), 
1:      * it gets the string representation of this id. This is useful for 
1:      * developers implementing connection pools when they are trying to
1:      * debug pooled connections. 
1:      *
1:      * @return a string representation of the uniquie id for this pooled
1:      *    connection.
1:      *
0:      */
1:     public String toString()
0:     {
0:         if ( idString == null )
0:         {
0:             idString = Integer.toString(connectionId);
0:         }
0:         
0:         return idString;
0:     }
commit:4383496
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * set DrdaId for this connection. 
0: 	 * Used by network server to identify connection.
0: 	 * @param  drdaID drda connection identifier
0: 	 */
0: 	public   void setDrdaID(String drdaID)
0: 	{
0: 		realConnection.setDrdaID(drdaID);
0: 	}
0: 
0: 	/**
0: 	 *  Set the internal isolation level to use for preparing statements.
0: 	 *  Subsequent prepares will use this isoalation level
0: 	 * @param level internal isolation level 
0: 	 *
0: 	 * @throws SQLException
0: 	 * @see BrokeredConnection#setPrepareIsolation
0: 	 * 
0: 	 */
0: 	public  void setPrepareIsolation(int level) throws SQLException
0: 	{
0: 		realConnection.setPrepareIsolation(level);
0: 	}
0: 	
0: 	/** 
0: 	 * Get prepare isolation level.
0: 	 * For network server this will be the isolation level at which statements
0: 	 * will be prepared.
0: 	 * @return isolation level
0: 	 */
0: 	public  int getPrepareIsolation() throws SQLException
0: 	{
0: 		return realConnection.getPrepareIsolation();
0: 	}
0: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:e214c07
/////////////////////////////////////////////////////////////////////////
1:     /** the connection string */
1:     private String connString;
/////////////////////////////////////////////////////////////////////////
1:         if ( connString == null )
1:             String physicalConnString = isActive ?
1:                 realConnection.toString() : "<none>";
0:             
1:             connString = 
1:               this.getClass().getName() + "@" + this.hashCode() + " " +
0:                 "(ID = " + connectionId + "), " +
1:                 "Physical Connection = " + physicalConnString;
0:         }    
1:         return connString;
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.jdbc
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.jdbc;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: /* import impl class */
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.EmbedConnection20;
0: import org.apache.derby.iapi.jdbc.BrokeredConnection;
0: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
0: 
0: 
0: import java.sql.Connection;
0: import java.sql.SQLException;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.CallableStatement;
0: 
0: import java.util.Vector;
0: import java.util.Enumeration;
0: 
0: /* -- New jdbc 20 extension types --- */
0: import javax.sql.DataSource;
0: import javax.sql.PooledConnection;
0: import javax.sql.ConnectionEventListener;
0: import javax.sql.ConnectionEvent;
0: 
0: /** 
0: 	A PooledConnection object is a connection object that provides hooks for
0: 	connection pool management.
0: 
0: 	<P>This is Cloudscape's implementation of a PooledConnection.  
0: 
0:  */
0: class EmbedPooledConnection implements javax.sql.PooledConnection, BrokeredConnectionControl
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 
0: 	private Vector eventListener; // who wants to know I am closed or error
0: 
0: 	protected EmbedConnection20 realConnection;
0: 	protected int defaultIsolationLevel;
0: 	private boolean defaultReadOnly;
0: 	protected BrokeredConnection currentConnectionHandle;
0: 
0: 	// set up once by the data source
0: 	protected final ReferenceableDataSource dataSource;
0: 	private final String username;
0: 	private final String password;
0: 	/**
0: 		True if the password was passed in on the connection request, false if it came from the data source property.
0: 	*/
0: 	private final boolean requestPassword;
0: 
0: 	private boolean isActive;
0: 
0: 	EmbedPooledConnection(ReferenceableDataSource ds, String u, String p, boolean requestPassword) throws SQLException
0: 	{
0: 		dataSource = ds;
0: 		username = u;
0: 		password = p;
0: 		this.requestPassword = requestPassword;
0: 		isActive = true;
0: 
0: 		// open the connection up front in order to do authentication
0: 		openRealConnection();
0: 
0: 	}
0: 
0: 	String getUsername()
0: 	{
0: 		if (username == null || username.equals(""))
0: 			return Property.DEFAULT_USER_NAME;
0: 		else
0: 			return username;
0: 	}
0: 
0: 	String getPassword()
0: 	{
0: 		if (password == null)
0: 			return "";
0: 		else
0: 			return password;
0: 	}
0: 
0: 
0: 	/** 
0: 		Create an object handle for a database connection.
0: 
0: 		@return a Connection object
0: 
0: 		@exception SQLException - if a database-access error occurs.
0: 	*/
0: 	public synchronized Connection getConnection() throws SQLException
0: 	{
0: 		checkActive();
0: 
0: 		// need to do this in case the connection is forcibly removed without
0: 		// first being closed.
0: 		closeCurrentConnectionHandle();
0: 
0: 
0: 		// RealConnection is not null if the app server yanks a local
0: 		// connection from one client and give it to another.  In this case,
0: 		// the real connection is ready to be used.  Otherwise, set it up
0: 		if (realConnection == null)
0: 		{
0: 			// first time we establish a connection
0: 			openRealConnection();
0: 		}
0: 		else
0: 		{
0: 			resetRealConnection();
0: 		}
0: 
0: 		// now make a brokered connection wrapper and give this to the user
0: 		// we reuse the EmbedConnection(ie realConnection).
0: 		Connection c = getNewCurrentConnectionHandle();		
0: 		return c;
0: 	}
0: 
0: 	protected final void openRealConnection() throws SQLException {
0: 		// first time we establish a connection
0: 		Connection rc = dataSource.getConnection(username, password, requestPassword);
0: 
0: 		this.realConnection = (EmbedConnection20) rc;
0: 		defaultIsolationLevel = rc.getTransactionIsolation();
0: 		defaultReadOnly = rc.isReadOnly();
0: 		if (currentConnectionHandle != null)
0: 			realConnection.setApplicationConnection(currentConnectionHandle);
0: 	}
0: 
0: 	protected final Connection getNewCurrentConnectionHandle() {
0: 		Connection applicationConnection = currentConnectionHandle =  realConnection.getLocalDriver().newBrokeredConnection(this);
0: 		realConnection.setApplicationConnection(applicationConnection);
0: 		return applicationConnection;
0: 
0: 	}
0: 
0: 	/**
0: 		In this case the Listeners are *not* notified. JDBC 3.0 spec section 11.4
0: 	*/
0: 	protected void closeCurrentConnectionHandle() throws SQLException {
0: 		if (currentConnectionHandle != null)
0: 		{
0: 			Vector tmpEventListener = eventListener;
0: 			eventListener = null;
0: 
0: 			try {
0: 				currentConnectionHandle.close();
0: 			} finally {
0: 				eventListener = tmpEventListener;
0: 			}
0: 
0: 			currentConnectionHandle = null;
0: 		}
0: 	}
0: 
0: 	protected void resetRealConnection() throws SQLException {
0: 
0: 		// ensure any outstanding changes from the previous
0: 		// user are rolledback.
0: 		realConnection.rollback();
0: 
0: 		// clear any warnings that are left over
0: 		realConnection.clearWarnings();
0: 
0: 		// need to reset transaction isolation, autocommit, readonly, holdability states
0: 		if (realConnection.getTransactionIsolation() != defaultIsolationLevel) {
0: 
0: 			realConnection.setTransactionIsolation(defaultIsolationLevel);
0: 		}
0: 
0: 		if (!realConnection.getAutoCommit())
0: 			realConnection.setAutoCommit(true);
0: 
0: 		if (realConnection.isReadOnly() != defaultReadOnly)
0: 			realConnection.setReadOnly(defaultReadOnly);
0: 
0: 		if (realConnection.getHoldability() != JDBC30Translation.HOLD_CURSORS_OVER_COMMIT)
0: 			realConnection.setHoldability(JDBC30Translation.HOLD_CURSORS_OVER_COMMIT);
0: 
0: 		// drop any temporary tables that may have been declared by the previous user
0: 		realConnection.dropAllDeclaredGlobalTempTables();
0: 	}
0: 
0: 	/**
0: 		Close the Pooled connection.
0: 
0: 		@exception SQLException - if a database-access error occurs.
0: 	 */
0: 	public synchronized void close() throws SQLException
0: 	{
0: 		if (!isActive)
0: 			return;
0: 
0: 		closeCurrentConnectionHandle();
0: 		try {
0: 			if (realConnection != null) {
0: 				if (!realConnection.isClosed())
0: 					realConnection.close();
0: 			}
0: 
0: 		} finally {
0: 
0: 			realConnection = null;	// make sure I am not accessed again.
0: 			isActive = false;
0: 			eventListener = null;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Add an event listener.
0: 	 */
0: 	public final synchronized void addConnectionEventListener(ConnectionEventListener listener) 
0: 	{
0: 		if (!isActive)
0: 			return;
0: 		if (listener == null)
0: 			return;
0: 		if (eventListener == null)
0: 			eventListener = new Vector();
0: 		eventListener.addElement(listener);
0: 	}
0: 
0: 	/**
0: 		Remove an event listener.
0: 	 */
0: 	public final synchronized void removeConnectionEventListener(ConnectionEventListener listener)
0: 	{
0: 		if (listener == null)
0: 			return;
0: 		if (eventListener != null)
0: 			eventListener.removeElement(listener);
0: 	}
0: 
0: 	/*
0: 	 * class specific method
0: 	 */
0: 
0: 	// called by ConnectionHandle when it needs to forward things to the
0: 	// underlying connection
0: 	public synchronized Connection getRealConnection() throws SQLException
0: 	{
0: 		checkActive();
0: 
0: 		return realConnection;
0: 	}
0: 
0: 
0: 	// my conneciton handle has caught an error (actually, the real connection
0: 	// has already handled the error, we just need to nofity the listener an
0: 	// error is about to be thrown to the app).
0: 	public synchronized void notifyError(SQLException exception)
0: 	{
0: 		// only report fatal error to the connection pool manager 
0: 		if (exception.getErrorCode() < ExceptionSeverity.SESSION_SEVERITY)
0: 			return;
0: 
0: 		// tell my listeners an exception is about to be thrown
0: 		if (eventListener != null && eventListener.size() > 0)
0: 		{
0: 			ConnectionEvent errorEvent = new ConnectionEvent(this, exception);
0: 
0: 			for (Enumeration enum = eventListener.elements();
0: 				 enum.hasMoreElements(); )
0: 			{
0: 				ConnectionEventListener l =
0: 					(ConnectionEventListener)enum.nextElement(); 
0: 				l.connectionErrorOccurred(errorEvent);
0: 			}
0: 		}
0: 	}
0: 
0: 	// my conneciton handle is being closed
0: 	public synchronized void notifyClose()
0: 	{
0: 		// tell my listeners I am closed 
0: 		if (eventListener != null && eventListener.size() > 0)
0: 		{
0: 			ConnectionEvent closeEvent = new ConnectionEvent(this);
0: 
0: 			for (Enumeration enum = eventListener.elements();
0: 				 enum.hasMoreElements(); )
0: 			{
0: 				ConnectionEventListener l =
0: 					(ConnectionEventListener)enum.nextElement(); 
0: 				l.connectionClosed(closeEvent);
0: 			}
0: 		}
0: 	}
0: 
0: 	protected final void checkActive() throws SQLException {
0: 		if (!isActive)
0: 			throw Util.noCurrentConnection();
0: 	}
0: 
0: 
0: 	/*
0: 	** BrokeredConnectionControl api
0: 	*/
0: 
0: 	/**
0: 		Notify the control class that a SQLException was thrown
0: 		during a call on one of the brokered connection's methods.
0: 	*/
0: 	public void notifyException(SQLException sqle) {
0: 		this.notifyError(sqle);
0: 	}
0: 
0: 
0: 	/**
0: 		Allow control over setting auto commit mode.
0: 	*/
0: 	public void checkAutoCommit(boolean autoCommit) throws SQLException {
0: 	}
0: 
0: 	/**
0: 		Are held cursors allowed.
0: 	*/
0: 	public void checkHoldCursors(int holdability) throws SQLException {
0: 	}
0: 
0: 	/**
0: 		Allow control over creating a Savepoint (JDBC 3.0)
0: 	*/
0: 	public void checkSavepoint() throws SQLException {
0: 	}
0: 
0: 	/**
0: 		Allow control over calling rollback.
0: 	*/
0: 	public void checkRollback() throws SQLException {
0: 	}
0: 
0: 	/**
0: 		Allow control over calling commit.
0: 	*/
0: 	public void checkCommit() throws SQLException {
0: 	}
0: 
0: 	/**
0: 		Close called on BrokeredConnection. If this call
0: 		returns true then getRealConnection().close() will be called.
0: 
0: 		Don't close the underlying real connection as
0: 		it is pooled.
0: 	*/
0: 	public boolean closingConnection() throws SQLException {
0: 		notifyClose();
0: 		currentConnectionHandle = null;
0: 		return false;
0: 	}
0: 
0: 	/**
0: 		No need to wrap statements for PooledConnections.
0: 	*/
0: 	public Statement wrapStatement(Statement s) throws SQLException {
0: 		return s;
0: 	}
0: 	/**
0: 		No need to wrap statements for PooledConnections.
0: 	*/
0: 	public PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {
0: 		return ps;
0: 	}
0: 	/**
0: 		No need to wrap statements for PooledConnections.
0: 	*/
0: 	public CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {
0: 		return cs;
0: 	}
0: }
============================================================================