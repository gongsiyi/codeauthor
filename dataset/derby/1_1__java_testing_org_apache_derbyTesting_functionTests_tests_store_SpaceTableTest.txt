1:8566ca3: /*
12:8566ca3: 
1:8566ca3:  Derby - Class org.apache.derbyTesting.functionTests.tests.store.SpaceTableTest
1:8566ca3: 
1:8566ca3:  Licensed to the Apache Software Foundation (ASF) under one or more
1:8566ca3:  contributor license agreements.  See the NOTICE file distributed with
1:8566ca3:  this work for additional information regarding copyright ownership.
1:8566ca3:  The ASF licenses this file to You under the Apache License, Version 2.0
1:8566ca3:  (the "License"); you may not use this file except in compliance with
1:8566ca3:  the License.  You may obtain a copy of the License at
1:8566ca3: 
1:8566ca3:  http://www.apache.org/licenses/LICENSE-2.0
1:8566ca3: 
1:8566ca3:  Unless required by applicable law or agreed to in writing, software
1:8566ca3:  distributed under the License is distributed on an "AS IS" BASIS,
1:8566ca3:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8566ca3:  See the License for the specific language governing permissions and
1:8566ca3:  limitations under the License.
1:8566ca3: 
2:8566ca3:  */
1:8566ca3: package org.apache.derbyTesting.functionTests.tests.store;
1:8566ca3: 
1:8566ca3: import java.sql.PreparedStatement;
1:8566ca3: import java.sql.ResultSet;
1:8566ca3: import java.sql.SQLException;
1:8566ca3: import java.sql.Statement;
1:8566ca3: import java.sql.Connection;
1:8566ca3: 
1:8709c8a: import junit.framework.AssertionFailedError;
1:8566ca3: import junit.framework.Test;
1:8566ca3: 
1:8566ca3: import org.apache.derbyTesting.functionTests.util.Formatters;
1:8566ca3: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:8566ca3: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:8566ca3: import org.apache.derbyTesting.junit.JDBC;
1:8566ca3: import org.apache.derbyTesting.junit.TestConfiguration;
1:8566ca3: 
1:8566ca3: /**
1:8566ca3:  * Tests the printing of the WAIT state in the LOCK TABLE.
1:8566ca3:  */
1:8566ca3: public class SpaceTableTest extends BaseJDBCTestCase {
1:8566ca3: 
1:8566ca3:     public SpaceTableTest(String name) {
1:8566ca3:         super(name);
8:8566ca3:     }
1:8566ca3: 
1:8566ca3:     /**
1:8566ca3:      * Construct top level suite in this JUnit test
1:8566ca3:      * The suite is wrapped in a DatabasePropertyTestSetup to set
1:8566ca3:      * the lock wait timeout.
1:8566ca3:      *
1:8566ca3:      * @return A suite containing embedded fixtures
1:8566ca3:      */
1:8566ca3:     public static Test suite() {
1:8566ca3: 
1:8566ca3:         Test suite = TestConfiguration.embeddedSuite (SpaceTableTest.class);
1:8566ca3:         return new CleanDatabaseTestSetup(suite) {
1:8566ca3:             /**
1:8566ca3:              * Creates the schemas and table used in the test cases.
1:8566ca3:              *
1:8566ca3:              * @throws SQLException
1:8566ca3:              */
1:8566ca3:             protected void decorateSQL(Statement s) throws SQLException {
1:8566ca3:                 Connection conn = getConnection();
1:8566ca3:                 conn.setAutoCommit(false);
1:8566ca3:                 String createWaitForPostCommit=
1:8566ca3:                     "CREATE PROCEDURE WAIT_FOR_POST_COMMIT() " +
1:8566ca3:                         "DYNAMIC RESULT SETS 0 " +
1:8566ca3:                         "LANGUAGE JAVA EXTERNAL NAME " +
1:8566ca3:                         "'org.apache.derbyTesting.functionTests.util.T_Access." +
1:8566ca3:                             "waitForPostCommitToFinish' " +
1:8566ca3:                         "PARAMETER STYLE JAVA";
1:8566ca3:                 s.executeUpdate(createWaitForPostCommit);
1:8566ca3:                 conn.commit();
1:8566ca3:                 conn.setAutoCommit(true);
1:8566ca3:             }
1:8566ca3:         };
1:8566ca3:     }
1:8566ca3: 
1:8566ca3:     
1:8566ca3:     protected void setUp() throws Exception {
1:8566ca3:         super.setUp();
1:8566ca3:     }
1:8566ca3: 
1:8566ca3:     /**
1:8566ca3:      * Tear-down the fixture by removing the tables and schemas
1:8566ca3:      * @throws Exception
1:8566ca3:      */
1:8566ca3:     protected void tearDown() throws Exception {
1:8566ca3:         Statement stmt = createStatement();
1:8566ca3:         // cannot drop wait_for_post_commit or it will not exist in
1:8566ca3:         // all test methods. CleanDatabaseSetup should take care of it.
1:8566ca3:         // stmt.executeUpdate("drop procedure WAIT_FOR_POST_COMMIT");
1:8709c8a:         dropTable("IDELETEU");
1:8709c8a:         dropTable("PLATYPUS");
1:8709c8a:         dropTable("\"platypus2\"");
1:8566ca3:         dropFooTables(stmt);
1:8566ca3:         // force pagesize back to default
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', NULL)");
1:8709c8a:         commit();
1:8566ca3:         super.tearDown();
1:8566ca3:     }
1:8566ca3: 
1:8566ca3:     public void testIDeleteu() throws SQLException, InterruptedException {
1:8566ca3:         Statement stmt = createStatement();
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', '4096')");
1:8566ca3:         stmt.executeUpdate("create table ideleteu " +
1:8566ca3:                 "(a varchar(2000), b varchar(2000))");
1:8566ca3:         String insertString = "insert into ideleteu values ('" +
1:8566ca3:                 Formatters.padString("rrrrrrrrrr",2000) + "', '" +
1:8566ca3:                 Formatters.padString("ssssssssssssssss",2000) + "')";
1:8566ca3:         for (int i=0; i<5; i++)
1:8566ca3:         stmt.executeUpdate(insertString);
1:8566ca3:         
1:8566ca3:         assertSpaceTableOK("IDELETEU", 
1:8566ca3:                 new String[][]{{"IDELETEU","0","6","0","4096","0"}}, false);
1:8566ca3:         
1:8566ca3:         stmt.executeUpdate("delete from ideleteu");
1:8566ca3:         // explicit commit, superfluous, as autocommit set in decorateSQL
1:8566ca3:         commit();
1:8566ca3:         stmt.execute("call WAIT_FOR_POST_COMMIT()");
1:8566ca3:         // this is one of 2 places where in the sql version of this test we
1:8566ca3:         // still saw highly intermittent diffs even with the wait for post commit
1:8566ca3:         // see DERBY-5133. So call to local check.
1:8566ca3:         assertSpaceTableOK("IDELETEU", 
1:8566ca3:                 new String[][]{{"IDELETEU","0","1","5","4096","20480"}}, true);
1:8566ca3:         stmt.executeUpdate("drop table ideleteu");
1:8566ca3:         commit();
1:8566ca3:         // the default is 4096 (with short columns), so no need to set to storage page size back.
1:8566ca3:     }
1:8566ca3:     
1:8566ca3:     public void testPlatypi() throws SQLException, InterruptedException
8:8566ca3:     {
1:8566ca3:         // check results when inserting data after creating indexes
1:8566ca3:         Statement stmt = createStatement();
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', '4096')");
1:8566ca3:         JDBC.assertEmpty(doSpaceTableSelect("PLATYPUS"));
1:8566ca3:         stmt.executeUpdate("create table platypus " +
1:8566ca3:                 "(a varchar(1000), b varchar(3500), " +
1:8566ca3:                 "c varchar(400), d varchar(100))");
1:8566ca3:         stmt.executeUpdate("create index kookaburra on platypus (a)");
1:8566ca3:         stmt.executeUpdate("create index echidna on platypus (c)");
1:8566ca3:         stmt.executeUpdate("create index wallaby on platypus (a,c,d)");
1:8566ca3:         assertSpaceTableOK("PLATYPUS", new String[][]{
1:8566ca3:                 {"ECHIDNA","1","1","0","4096","0"},
1:8566ca3:                 {"KOOKABURRA","1","1","0","4096","0"},
1:8566ca3:                 {"PLATYPUS","0","1","0","4096","0"},
1:8566ca3:                 {"WALLABY","1","1","0","4096","0"},
1:8566ca3:                 }, false);
1:8566ca3:         String insertString = "insert into platypus values ('" +
1:8566ca3:                 Formatters.padString("wwwwwww",1000) + "', '" +
1:8566ca3:                 Formatters.padString("xxx",3500) + "', '" +
1:8566ca3:                 Formatters.padString("yy",400) + "', '" +
1:8566ca3:                 Formatters.padString("zzz",100) + "')";
1:8566ca3:         for (int i=0; i<6; i++)
1:8566ca3:         stmt.executeUpdate(insertString);
1:8566ca3:         assertSpaceTableOK("PLATYPUS", new String[][]{
1:8566ca3:                 {"ECHIDNA","1","1","0","4096","0"},
1:8566ca3:                 {"KOOKABURRA","1","4","0","4096","0"},
1:8566ca3:                 {"PLATYPUS","0","13","0","4096","0"},
1:8566ca3:                 {"WALLABY","1","8","0","4096","0"},
1:8566ca3:                 }, false);
1:8566ca3:         for (int i=0; i<4; i++)
1:8566ca3:         stmt.executeUpdate(insertString);
1:8566ca3:         assertSpaceTableOK("PLATYPUS", new String[][]{
1:8566ca3:                 {"ECHIDNA","1","3","0","4096","0"},
1:8566ca3:                 {"KOOKABURRA","1","8","0","4096","0"},
1:8566ca3:                 {"PLATYPUS","0","21","0","4096","0"},
1:8566ca3:                 {"WALLABY","1","16","0","4096","0"},
1:8566ca3:                 }, false);
1:8566ca3:         stmt.executeUpdate("delete from platypus");
1:8566ca3:         // we've got autocommit on, so there was a commit...
1:8566ca3:         stmt.execute("call WAIT_FOR_POST_COMMIT()");
1:8566ca3:         assertSpaceTableOK("PLATYPUS", new String[][]{
1:8566ca3:                 {"ECHIDNA","1","1","2","4096","8192"},
1:8566ca3:                 {"KOOKABURRA","1","1","7","4096","28672"},
1:8566ca3:                 {"PLATYPUS","0","1","20","4096","81920"},
1:8566ca3:                 {"WALLABY","1","15","1","4096","4096"},
1:8566ca3:                 }, true);
1:8566ca3:         
1:8566ca3:         // check the results when we create indexes after inserting data
1:8566ca3:         // also note this table has lower case name
1:8566ca3:         stmt.executeUpdate("create table \"platypus2\" " +
1:8566ca3:                 "(a varchar(10), b varchar(1500), " +
1:8566ca3:                 "c varchar(400), d varchar(100))");
1:8566ca3:         insertString = "insert into \"platypus2\" values ('" +
1:8566ca3:                 Formatters.padString("wwwwwww",10) + "', '" +
1:8566ca3:                 Formatters.padString("xxx",1500) + "', '" +
1:8566ca3:                 Formatters.padString("yy",400) + "', '" +
1:8566ca3:                 Formatters.padString("zzz",100) + "')";
1:8566ca3:         for (int i=0; i<6; i++)
1:8566ca3:         stmt.executeUpdate(insertString);
1:8566ca3:         stmt.executeUpdate("create index kookaburra2 on \"platypus2\" (a)");
1:8566ca3:         stmt.executeUpdate("create index echidna2 on \"platypus2\" (c)");
1:8566ca3:         stmt.executeUpdate("create index wallaby2 on \"platypus2\" (a,c,d)");
1:8566ca3:         assertSpaceTableOK("platypus2", new String[][]{
1:8566ca3:                 {"ECHIDNA2","1","1","0","4096","0"},
1:8566ca3:                 {"KOOKABURRA2","1","1","0","4096","0"},
1:8566ca3:                 {"WALLABY2","1","1","0","4096","0"},
1:8566ca3:                 {"platypus2","0","6","0","4096","0"},
1:8566ca3:                 }, false);
1:8566ca3: 
1:8566ca3:         ResultSet rs = stmt.executeQuery(
1:8566ca3:                 "select conglomeratename, isindex, numallocatedpages, " +
1:8566ca3:                 "numfreepages, pagesize, estimspacesaving " +
1:8566ca3:                 "from SYS.SYSSCHEMAS s, " +
1:8566ca3:                 "SYS.SYSTABLES t, " +
1:8566ca3:                 "new org.apache.derby.diag.SpaceTable(SCHEMANAME,TABLENAME) v " +
1:8566ca3:                 "where s.SCHEMAID = t.SCHEMAID " +
1:8566ca3:                 "and s.SCHEMANAME = 'APP' " +
1:8566ca3:                 "order by conglomeratename");
1:8566ca3:         JDBC.assertFullResultSet(rs, new String [][] {
1:8566ca3:                 {"ECHIDNA","1","1","2","4096","8192"},
1:8566ca3:                 {"ECHIDNA2","1","1","0","4096","0"},
1:8566ca3:                 {"KOOKABURRA","1","1","7","4096","28672"},
1:8566ca3:                 {"KOOKABURRA2","1","1","0","4096","0"},
1:8566ca3:                 {"PLATYPUS","0","1","20","4096","81920"},
1:8566ca3:                 {"WALLABY","1","15","1","4096","4096"},
1:8566ca3:                 {"WALLABY2","1","1","0","4096","0"},
1:8566ca3:                 {"platypus2","0","6","0","4096","0"},
1:8566ca3:                 });
2:8566ca3:         stmt.executeUpdate("drop table platypus");
1:8566ca3:         stmt.executeUpdate("drop table \"platypus2\"");
1:8566ca3:     }
1:8566ca3:     
1:8566ca3:     public void testReservedSpace() throws SQLException, InterruptedException
1:8566ca3:     {
1:8566ca3:         Statement stmt = createStatement();
1:8566ca3:         // first ensure we're using the default.
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', '4096')");
1:8566ca3:         setAutoCommit(false);
1:8566ca3:         
1:8566ca3:         // no reserved space set - default
1:8566ca3:         stmt.executeUpdate("create table foo_int (a int)");
1:8566ca3:         stmt.executeUpdate("create table foo_char (a char(100))");
1:8566ca3:         stmt.executeUpdate("create table foo_varchar (a varchar(32000))");
1:8566ca3:         // let the foo_longxxx get created at 32K (the default for long types)
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', NULL)");
1:8566ca3:         stmt.executeUpdate("create table foo_longvarchar (a long varchar)");
1:8566ca3:         stmt.executeUpdate("create table foo_longvarbinary " +
1:8566ca3:                 "(a long varchar for bit data)");
1:8566ca3:         // Back to 4K
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', '4096')");
1:8566ca3:         stmt.executeUpdate("create table foo_bit (a char(100) for bit data)");
1:8566ca3:         stmt.executeUpdate("create table foo_varbinary " +
1:8566ca3:                 "(a varchar(1000) for bit data)");
1:8566ca3:         
1:8566ca3:         JDBC.assertFullResultSet(doSpaceTableSelect2(), new String [][] {
1:8566ca3:                 {"FOO_BIT","4096"},
1:8566ca3:                 {"FOO_CHAR","4096"},
1:8566ca3:                 {"FOO_INT","4096"},
1:8566ca3:                 {"FOO_LONGVARBINARY","32768"},
1:8566ca3:                 {"FOO_LONGVARCHAR","32768"},
1:8566ca3:                 {"FOO_VARBINARY","4096"},
1:8566ca3:                 {"FOO_VARCHAR","4096"},
1:8566ca3:                 });
1:8566ca3:         
1:8709c8a:         dropFooTables(stmt);
1:8566ca3:         
1:8566ca3:         // test with 65K reserved space
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.ReservedSpace', '65')");
1:8566ca3:         stmt.executeUpdate("create table foo_int (a int)");
1:8566ca3:         stmt.executeUpdate("create table foo_char (a char(100))");
1:8566ca3:         stmt.executeUpdate("create table foo_varchar (a varchar(32000))");
1:8566ca3:         // let the foo_longxxx get created at 32K (the default for long types)
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', NULL)");
1:8566ca3:         stmt.executeUpdate("create table foo_longvarchar (a long varchar)");
1:8566ca3:         stmt.executeUpdate("create table foo_longvarbinary " +
1:8566ca3:                 "(a long varchar for bit data)");
1:8566ca3:         // Back to 4K
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', '4096')");
1:8566ca3:         stmt.executeUpdate("create table foo_bit (a char(100) for bit data)");
1:8566ca3:         stmt.executeUpdate("create table foo_varbinary " +
1:8566ca3:                 "(a varchar(1000) for bit data)");
1:8566ca3:         
1:8566ca3:         // reset the reserved space to default (by setting property to NULL)
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.ReservedSpace', NULL)");
1:8566ca3:         
1:8566ca3:         JDBC.assertFullResultSet(doSpaceTableSelect2(), new String [][] {
1:8566ca3:             {"FOO_BIT","4096"},
1:8566ca3:             {"FOO_CHAR","4096"},
1:8566ca3:             {"FOO_INT","4096"},
1:8566ca3:             {"FOO_LONGVARBINARY","32768"},
1:8566ca3:             {"FOO_LONGVARCHAR","32768"},
1:8566ca3:             {"FOO_VARBINARY","4096"},
1:8566ca3:             {"FOO_VARCHAR","4096"},
1:8566ca3:             });
1:8566ca3:         
1:8566ca3:         dropFooTables(stmt);
1:8566ca3:         
1:8566ca3:         // 8K pagesize
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', '8192')");
1:8566ca3:         stmt.executeUpdate("create table foo_int (a int)");
1:8566ca3:         stmt.executeUpdate("create table foo_char (a char(100))");
1:8566ca3:         stmt.executeUpdate("create table foo_varchar (a varchar(32000))");
1:8566ca3:         stmt.executeUpdate("create table foo_longvarchar (a long varchar)");
1:8566ca3:         stmt.executeUpdate("create table foo_longvarbinary " +
1:8566ca3:                 "(a long varchar for bit data)");
1:8566ca3:         stmt.executeUpdate("create table foo_bit (a char(100) for bit data)");
1:8566ca3:         stmt.executeUpdate("create table foo_varbinary " +
1:8566ca3:                 "(a varchar(1000) for bit data)");
1:8566ca3:         
1:8566ca3:         JDBC.assertFullResultSet(doSpaceTableSelect2(), new String [][] {
1:8566ca3:             {"FOO_BIT","8192"},
1:8566ca3:             {"FOO_CHAR","8192"},
1:8566ca3:             {"FOO_INT","8192"},
1:8566ca3:             {"FOO_LONGVARBINARY","8192"},
1:8566ca3:             {"FOO_LONGVARCHAR","8192"},
1:8566ca3:             {"FOO_VARBINARY","8192"},
1:8566ca3:             {"FOO_VARCHAR","8192"},
1:8566ca3:             });
1:8566ca3:         
1:8566ca3:         dropFooTables(stmt);
1:8566ca3:         
1:8566ca3:         // test with commit after setting pageSize at 4096
1:8566ca3:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:8566ca3:                 "'derby.storage.pageSize', '4096')");
1:8709c8a:         commit();
1:8566ca3:         stmt.executeUpdate("create table foo_int (a int)");
1:8566ca3:         stmt.executeUpdate("create table foo_char (a char(100))");
1:8566ca3:         stmt.executeUpdate("create table foo_varchar (a varchar(32000))");
1:8566ca3:         stmt.executeUpdate("create table foo_longvarchar (a long varchar)");
1:8566ca3:         stmt.executeUpdate("create table foo_longvarbinary " +
1:8566ca3:                 "(a long varchar for bit data)");
1:8566ca3:         stmt.executeUpdate("create table foo_bit (a char(100) for bit data)");
1:8566ca3:         stmt.executeUpdate("create table foo_varbinary " +
1:8566ca3:                 "(a varchar(1000) for bit data)");
1:8566ca3:         
1:8566ca3:         JDBC.assertFullResultSet(doSpaceTableSelect2(), new String [][] {
1:8566ca3:             {"FOO_BIT","4096"},
1:8566ca3:             {"FOO_CHAR","4096"},
1:8566ca3:             {"FOO_INT","4096"},
1:8566ca3:             {"FOO_LONGVARBINARY","4096"},
1:8566ca3:             {"FOO_LONGVARCHAR","4096"},
1:8566ca3:             {"FOO_VARBINARY","4096"},
1:8566ca3:             {"FOO_VARCHAR","4096"},
1:8566ca3:             });
1:8566ca3:         
1:8566ca3:         commit();
1:8566ca3:         dropFooTables(stmt);
1:8566ca3:         commit();
1:8566ca3:     }
1:8566ca3:     
1:8566ca3:     private ResultSet doSpaceTableSelect(String tableName) throws SQLException
1:8566ca3:     {
1:8566ca3:         ResultSet rs = null;
1:8566ca3:         String stmt_str = 
1:8566ca3:                 "select " + 
1:8566ca3:                         "conglomeratename, " +
1:8566ca3:                         "isindex, "           + 
1:8566ca3:                         "numallocatedpages, " + 
1:8566ca3:                         "numfreepages, "      + 
1:8566ca3:                         "pagesize, "          + 
1:8566ca3:                         "estimspacesaving "   + 
1:8566ca3:                         "from new org.apache.derby.diag.SpaceTable('" +
1:8566ca3:                         tableName + "') t order by conglomeratename";
1:8566ca3: 
1:8566ca3:         PreparedStatement space_stmt = prepareStatement(stmt_str);
1:8566ca3:         rs = space_stmt.executeQuery();
1:8566ca3:         return rs;
1:8566ca3:     }
1:8566ca3:     
1:8566ca3:     private ResultSet doSpaceTableSelect2() throws SQLException
1:8566ca3:     {
1:8566ca3:         ResultSet rs = null;
1:8566ca3:         String stmt_str = 
1:8566ca3:                 "select " + 
1:8566ca3:                         "v.conglomeratename, pagesize " +
1:8566ca3:                         "from SYS.SYSSCHEMAS s, SYS.SYSTABLES t, " +
1:8566ca3:                         "new org.apache.derby.diag.SpaceTable(" +
1:8566ca3:                         "schemaname, tablename) v " +
1:8566ca3:                         "where s.schemaid=t.schemaid and " +
1:8566ca3:                         "conglomeratename in (" +
1:8566ca3:                         "'FOO_INT', 'FOO_VARCHAR', 'FOO_CHAR', 'FOO_LONGVARCHAR'," +
1:8566ca3:                         "'FOO_VARBINARY', 'FOO_LONGVARBINARY', 'FOO_BIT') " +
1:8566ca3:                         "order by 1";
1:8566ca3: 
1:8566ca3:         PreparedStatement space_stmt = prepareStatement(stmt_str);
1:8566ca3:         rs = space_stmt.executeQuery();
1:8566ca3:         return rs;
1:8566ca3:     }
1:8566ca3:     
1:8566ca3:     private void assertSpaceTableOK(String tableName, String[][] expRS, 
1:8566ca3:             boolean trytwice)
1:8566ca3:             throws SQLException, InterruptedException {
1:8566ca3:         ResultSet rs = doSpaceTableSelect(tableName);
1:8709c8a:         try {
1:8709c8a:             JDBC.assertFullResultSet(rs, expRS );
1:8709c8a:         } catch (AssertionFailedError e) {
1:8709c8a:             if (trytwice) {
1:8566ca3:                 assertSpaceTableOK(tableName, expRS, false);
1:8709c8a:             } else {
1:8709c8a:                 throw e;
1:8566ca3:             }
1:8566ca3:         }
1:8566ca3:     }
1:8566ca3:     
1:8566ca3:     public void dropFooTables(Statement stmt) throws SQLException {
1:8709c8a:         dropTable("FOO_INT");
1:8709c8a:         dropTable("FOO_CHAR");
1:8709c8a:         dropTable("FOO_VARCHAR");
1:8709c8a:         dropTable("FOO_LONGVARCHAR");
1:8709c8a:         dropTable("FOO_LONGVARBINARY");
1:8709c8a:         dropTable("FOO_BIT");
1:8709c8a:         dropTable("FOO_VARBINARY");
1:8566ca3:     }
1:8566ca3: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:8709c8a
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.AssertionFailedError;
/////////////////////////////////////////////////////////////////////////
1:         dropTable("IDELETEU");
1:         dropTable("PLATYPUS");
1:         dropTable("\"platypus2\"");
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         dropFooTables(stmt);
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             JDBC.assertFullResultSet(rs, expRS );
1:         } catch (AssertionFailedError e) {
1:             if (trytwice) {
1:             } else {
1:                 throw e;
1:         dropTable("FOO_INT");
1:         dropTable("FOO_CHAR");
1:         dropTable("FOO_VARCHAR");
1:         dropTable("FOO_LONGVARCHAR");
1:         dropTable("FOO_LONGVARBINARY");
1:         dropTable("FOO_BIT");
1:         dropTable("FOO_VARBINARY");
commit:8566ca3
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:  Derby - Class org.apache.derbyTesting.functionTests.tests.store.SpaceTableTest
1: 
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1: 
1:  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Connection;
0: import java.util.Arrays;
0: import java.util.Properties;
1: 
0: import junit.framework.Assert;
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.functionTests.util.Formatters;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Tests the printing of the WAIT state in the LOCK TABLE.
1:  */
1: public class SpaceTableTest extends BaseJDBCTestCase {
1: 
1:     public SpaceTableTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      * The suite is wrapped in a DatabasePropertyTestSetup to set
1:      * the lock wait timeout.
1:      *
1:      * @return A suite containing embedded fixtures
1:      */
1:     public static Test suite() {
1: 
1:         Test suite = TestConfiguration.embeddedSuite (SpaceTableTest.class);
1:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:              * Creates the schemas and table used in the test cases.
1:              *
1:              * @throws SQLException
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 Connection conn = getConnection();
1:                 conn.setAutoCommit(false);
1:                 String createWaitForPostCommit=
1:                     "CREATE PROCEDURE WAIT_FOR_POST_COMMIT() " +
1:                         "DYNAMIC RESULT SETS 0 " +
1:                         "LANGUAGE JAVA EXTERNAL NAME " +
1:                         "'org.apache.derbyTesting.functionTests.util.T_Access." +
1:                             "waitForPostCommitToFinish' " +
1:                         "PARAMETER STYLE JAVA";
1:                 s.executeUpdate(createWaitForPostCommit);
1:                 conn.commit();
1:                 conn.setAutoCommit(true);
1:             }
1:         };
1:     }
1: 
1:     
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:     }
1: 
1:     /**
1:      * Tear-down the fixture by removing the tables and schemas
1:      * @throws Exception
1:      */
1:     protected void tearDown() throws Exception {
0:         try {
1:         Statement stmt = createStatement();
1:         // cannot drop wait_for_post_commit or it will not exist in
1:         // all test methods. CleanDatabaseSetup should take care of it.
1:         // stmt.executeUpdate("drop procedure WAIT_FOR_POST_COMMIT");
0:         stmt.executeUpdate("drop table IDELETEU");
1:         stmt.executeUpdate("drop table platypus");
0:         stmt.executeUpdate("drop table 'platypus2'");
1:         dropFooTables(stmt);
1:         // force pagesize back to default
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', NULL)");
0:         } catch (SQLException sqe) {
0:             assertSQLState("42Y55", sqe);
1:         }
1:         super.tearDown();
1:     }
1: 
1:     public void testIDeleteu() throws SQLException, InterruptedException {
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', '4096')");
1:         stmt.executeUpdate("create table ideleteu " +
1:                 "(a varchar(2000), b varchar(2000))");
1:         String insertString = "insert into ideleteu values ('" +
1:                 Formatters.padString("rrrrrrrrrr",2000) + "', '" +
1:                 Formatters.padString("ssssssssssssssss",2000) + "')";
1:         for (int i=0; i<5; i++)
1:         stmt.executeUpdate(insertString);
1:         
1:         assertSpaceTableOK("IDELETEU", 
1:                 new String[][]{{"IDELETEU","0","6","0","4096","0"}}, false);
1:         
1:         stmt.executeUpdate("delete from ideleteu");
1:         // explicit commit, superfluous, as autocommit set in decorateSQL
1:         commit();
1:         stmt.execute("call WAIT_FOR_POST_COMMIT()");
1:         // this is one of 2 places where in the sql version of this test we
1:         // still saw highly intermittent diffs even with the wait for post commit
1:         // see DERBY-5133. So call to local check.
1:         assertSpaceTableOK("IDELETEU", 
1:                 new String[][]{{"IDELETEU","0","1","5","4096","20480"}}, true);
1:         stmt.executeUpdate("drop table ideleteu");
1:         commit();
1:         // the default is 4096 (with short columns), so no need to set to storage page size back.
1:     }
1:     
1:     public void testPlatypi() throws SQLException, InterruptedException
1:     {
1:         // check results when inserting data after creating indexes
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', '4096')");
1:         JDBC.assertEmpty(doSpaceTableSelect("PLATYPUS"));
1:         stmt.executeUpdate("create table platypus " +
1:                 "(a varchar(1000), b varchar(3500), " +
1:                 "c varchar(400), d varchar(100))");
1:         stmt.executeUpdate("create index kookaburra on platypus (a)");
1:         stmt.executeUpdate("create index echidna on platypus (c)");
1:         stmt.executeUpdate("create index wallaby on platypus (a,c,d)");
1:         assertSpaceTableOK("PLATYPUS", new String[][]{
1:                 {"ECHIDNA","1","1","0","4096","0"},
1:                 {"KOOKABURRA","1","1","0","4096","0"},
1:                 {"PLATYPUS","0","1","0","4096","0"},
1:                 {"WALLABY","1","1","0","4096","0"},
1:                 }, false);
1:         String insertString = "insert into platypus values ('" +
1:                 Formatters.padString("wwwwwww",1000) + "', '" +
1:                 Formatters.padString("xxx",3500) + "', '" +
1:                 Formatters.padString("yy",400) + "', '" +
1:                 Formatters.padString("zzz",100) + "')";
1:         for (int i=0; i<6; i++)
1:         stmt.executeUpdate(insertString);
1:         assertSpaceTableOK("PLATYPUS", new String[][]{
1:                 {"ECHIDNA","1","1","0","4096","0"},
1:                 {"KOOKABURRA","1","4","0","4096","0"},
1:                 {"PLATYPUS","0","13","0","4096","0"},
1:                 {"WALLABY","1","8","0","4096","0"},
1:                 }, false);
1:         for (int i=0; i<4; i++)
1:         stmt.executeUpdate(insertString);
1:         assertSpaceTableOK("PLATYPUS", new String[][]{
1:                 {"ECHIDNA","1","3","0","4096","0"},
1:                 {"KOOKABURRA","1","8","0","4096","0"},
1:                 {"PLATYPUS","0","21","0","4096","0"},
1:                 {"WALLABY","1","16","0","4096","0"},
1:                 }, false);
1:         stmt.executeUpdate("delete from platypus");
1:         // we've got autocommit on, so there was a commit...
1:         stmt.execute("call WAIT_FOR_POST_COMMIT()");
1:         assertSpaceTableOK("PLATYPUS", new String[][]{
1:                 {"ECHIDNA","1","1","2","4096","8192"},
1:                 {"KOOKABURRA","1","1","7","4096","28672"},
1:                 {"PLATYPUS","0","1","20","4096","81920"},
1:                 {"WALLABY","1","15","1","4096","4096"},
1:                 }, true);
1:         
1:         // check the results when we create indexes after inserting data
1:         // also note this table has lower case name
1:         stmt.executeUpdate("create table \"platypus2\" " +
1:                 "(a varchar(10), b varchar(1500), " +
1:                 "c varchar(400), d varchar(100))");
1:         insertString = "insert into \"platypus2\" values ('" +
1:                 Formatters.padString("wwwwwww",10) + "', '" +
1:                 Formatters.padString("xxx",1500) + "', '" +
1:                 Formatters.padString("yy",400) + "', '" +
1:                 Formatters.padString("zzz",100) + "')";
1:         for (int i=0; i<6; i++)
1:         stmt.executeUpdate(insertString);
1:         stmt.executeUpdate("create index kookaburra2 on \"platypus2\" (a)");
1:         stmt.executeUpdate("create index echidna2 on \"platypus2\" (c)");
1:         stmt.executeUpdate("create index wallaby2 on \"platypus2\" (a,c,d)");
1:         assertSpaceTableOK("platypus2", new String[][]{
1:                 {"ECHIDNA2","1","1","0","4096","0"},
1:                 {"KOOKABURRA2","1","1","0","4096","0"},
1:                 {"WALLABY2","1","1","0","4096","0"},
1:                 {"platypus2","0","6","0","4096","0"},
1:                 }, false);
1: 
1:         ResultSet rs = stmt.executeQuery(
1:                 "select conglomeratename, isindex, numallocatedpages, " +
1:                 "numfreepages, pagesize, estimspacesaving " +
1:                 "from SYS.SYSSCHEMAS s, " +
1:                 "SYS.SYSTABLES t, " +
1:                 "new org.apache.derby.diag.SpaceTable(SCHEMANAME,TABLENAME) v " +
1:                 "where s.SCHEMAID = t.SCHEMAID " +
1:                 "and s.SCHEMANAME = 'APP' " +
1:                 "order by conglomeratename");
1:         JDBC.assertFullResultSet(rs, new String [][] {
1:                 {"ECHIDNA","1","1","2","4096","8192"},
1:                 {"ECHIDNA2","1","1","0","4096","0"},
1:                 {"KOOKABURRA","1","1","7","4096","28672"},
1:                 {"KOOKABURRA2","1","1","0","4096","0"},
1:                 {"PLATYPUS","0","1","20","4096","81920"},
1:                 {"WALLABY","1","15","1","4096","4096"},
1:                 {"WALLABY2","1","1","0","4096","0"},
1:                 {"platypus2","0","6","0","4096","0"},
1:                 });
1:         stmt.executeUpdate("drop table platypus");
1:         stmt.executeUpdate("drop table \"platypus2\"");
1:     }
1:     
1:     public void testReservedSpace() throws SQLException, InterruptedException
1:     {
1:         Statement stmt = createStatement();
1:         // first ensure we're using the default.
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', '4096')");
1:         setAutoCommit(false);
1:         
1:         // no reserved space set - default
1:         stmt.executeUpdate("create table foo_int (a int)");
1:         stmt.executeUpdate("create table foo_char (a char(100))");
1:         stmt.executeUpdate("create table foo_varchar (a varchar(32000))");
1:         // let the foo_longxxx get created at 32K (the default for long types)
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', NULL)");
1:         stmt.executeUpdate("create table foo_longvarchar (a long varchar)");
1:         stmt.executeUpdate("create table foo_longvarbinary " +
1:                 "(a long varchar for bit data)");
1:         // Back to 4K
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', '4096')");
1:         stmt.executeUpdate("create table foo_bit (a char(100) for bit data)");
1:         stmt.executeUpdate("create table foo_varbinary " +
1:                 "(a varchar(1000) for bit data)");
1:         
1:         JDBC.assertFullResultSet(doSpaceTableSelect2(), new String [][] {
1:                 {"FOO_BIT","4096"},
1:                 {"FOO_CHAR","4096"},
1:                 {"FOO_INT","4096"},
1:                 {"FOO_LONGVARBINARY","32768"},
1:                 {"FOO_LONGVARCHAR","32768"},
1:                 {"FOO_VARBINARY","4096"},
1:                 {"FOO_VARCHAR","4096"},
1:                 });
1:         
1:         dropFooTables(stmt);
1:         
1:         // test with 65K reserved space
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.ReservedSpace', '65')");
1:         stmt.executeUpdate("create table foo_int (a int)");
1:         stmt.executeUpdate("create table foo_char (a char(100))");
1:         stmt.executeUpdate("create table foo_varchar (a varchar(32000))");
1:         // let the foo_longxxx get created at 32K (the default for long types)
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', NULL)");
1:         stmt.executeUpdate("create table foo_longvarchar (a long varchar)");
1:         stmt.executeUpdate("create table foo_longvarbinary " +
1:                 "(a long varchar for bit data)");
1:         // Back to 4K
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', '4096')");
1:         stmt.executeUpdate("create table foo_bit (a char(100) for bit data)");
1:         stmt.executeUpdate("create table foo_varbinary " +
1:                 "(a varchar(1000) for bit data)");
1:         
1:         // reset the reserved space to default (by setting property to NULL)
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.ReservedSpace', NULL)");
1:         
1:         JDBC.assertFullResultSet(doSpaceTableSelect2(), new String [][] {
1:             {"FOO_BIT","4096"},
1:             {"FOO_CHAR","4096"},
1:             {"FOO_INT","4096"},
1:             {"FOO_LONGVARBINARY","32768"},
1:             {"FOO_LONGVARCHAR","32768"},
1:             {"FOO_VARBINARY","4096"},
1:             {"FOO_VARCHAR","4096"},
1:             });
1:         
1:         dropFooTables(stmt);
1:         
1:         // 8K pagesize
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', '8192')");
1:         stmt.executeUpdate("create table foo_int (a int)");
1:         stmt.executeUpdate("create table foo_char (a char(100))");
1:         stmt.executeUpdate("create table foo_varchar (a varchar(32000))");
1:         stmt.executeUpdate("create table foo_longvarchar (a long varchar)");
1:         stmt.executeUpdate("create table foo_longvarbinary " +
1:                 "(a long varchar for bit data)");
1:         stmt.executeUpdate("create table foo_bit (a char(100) for bit data)");
1:         stmt.executeUpdate("create table foo_varbinary " +
1:                 "(a varchar(1000) for bit data)");
1:         
1:         JDBC.assertFullResultSet(doSpaceTableSelect2(), new String [][] {
1:             {"FOO_BIT","8192"},
1:             {"FOO_CHAR","8192"},
1:             {"FOO_INT","8192"},
1:             {"FOO_LONGVARBINARY","8192"},
1:             {"FOO_LONGVARCHAR","8192"},
1:             {"FOO_VARBINARY","8192"},
1:             {"FOO_VARCHAR","8192"},
1:             });
1:         
1:         dropFooTables(stmt);
1:         
1:         // test with commit after setting pageSize at 4096
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                 "'derby.storage.pageSize', '4096')");
1:         commit();
1:         stmt.executeUpdate("create table foo_int (a int)");
1:         stmt.executeUpdate("create table foo_char (a char(100))");
1:         stmt.executeUpdate("create table foo_varchar (a varchar(32000))");
1:         stmt.executeUpdate("create table foo_longvarchar (a long varchar)");
1:         stmt.executeUpdate("create table foo_longvarbinary " +
1:                 "(a long varchar for bit data)");
1:         stmt.executeUpdate("create table foo_bit (a char(100) for bit data)");
1:         stmt.executeUpdate("create table foo_varbinary " +
1:                 "(a varchar(1000) for bit data)");
1:         
1:         JDBC.assertFullResultSet(doSpaceTableSelect2(), new String [][] {
1:             {"FOO_BIT","4096"},
1:             {"FOO_CHAR","4096"},
1:             {"FOO_INT","4096"},
1:             {"FOO_LONGVARBINARY","4096"},
1:             {"FOO_LONGVARCHAR","4096"},
1:             {"FOO_VARBINARY","4096"},
1:             {"FOO_VARCHAR","4096"},
1:             });
1:         
1:         commit();
1:     }
1:     
1:     private ResultSet doSpaceTableSelect(String tableName) throws SQLException
1:     {
1:         ResultSet rs = null;
1:         String stmt_str = 
1:                 "select " + 
1:                         "conglomeratename, " +
1:                         "isindex, "           + 
1:                         "numallocatedpages, " + 
1:                         "numfreepages, "      + 
1:                         "pagesize, "          + 
1:                         "estimspacesaving "   + 
1:                         "from new org.apache.derby.diag.SpaceTable('" +
1:                         tableName + "') t order by conglomeratename";
1: 
1:         PreparedStatement space_stmt = prepareStatement(stmt_str);
1:         rs = space_stmt.executeQuery();
1:         return rs;
1:     }
1:     
1:     private ResultSet doSpaceTableSelect2() throws SQLException
1:     {
1:         ResultSet rs = null;
1:         String stmt_str = 
1:                 "select " + 
1:                         "v.conglomeratename, pagesize " +
1:                         "from SYS.SYSSCHEMAS s, SYS.SYSTABLES t, " +
1:                         "new org.apache.derby.diag.SpaceTable(" +
1:                         "schemaname, tablename) v " +
1:                         "where s.schemaid=t.schemaid and " +
1:                         "conglomeratename in (" +
1:                         "'FOO_INT', 'FOO_VARCHAR', 'FOO_CHAR', 'FOO_LONGVARCHAR'," +
1:                         "'FOO_VARBINARY', 'FOO_LONGVARBINARY', 'FOO_BIT') " +
1:                         "order by 1";
1: 
1:         PreparedStatement space_stmt = prepareStatement(stmt_str);
1:         rs = space_stmt.executeQuery();
1:         return rs;
1:     }
1:     
1:     private void assertSpaceTableOK(String tableName, String[][] expRS, 
1:             boolean trytwice)
1:             throws SQLException, InterruptedException {
1: 
1:         ResultSet rs = doSpaceTableSelect(tableName);
0:             String failString = "";
0:             if (!trytwice)
0:                 JDBC.assertFullResultSet(rs, expRS);
0:             else
0:                 failString = checkSpaceTable(rs, expRS, false);
0:             // if we have a failString, we must have been
0:             // through the checkSpaceTable and had a failure;
0:             // go do it again, but this time we'll send it through the
0:             // JDBC class' version.
0:             if (failString.length() > 0)
1:                 assertSpaceTableOK(tableName, expRS, false);
1:     }
1: 
0:     // this method is needed because in a very few occassions we've seen
0:     // instability in a few rows in this test. 
0:     // In those cases, *if* we see unexpected results, we're going to assume it is
0:     // a time-related issue and we sleep for a bit, then try 
0:     public static String checkSpaceTable(
0:             ResultSet rs,
0:             Object [][] expectedRows,
0:             boolean secondtime)
0:                     throws SQLException
1:     {
0:         String failString="";
0:         int rows;
0:         ResultSetMetaData rsmd = rs.getMetaData();
1: 
0:         // Assert that we have the right number of columns. If we expect an
0:         // empty result set, the expected column count is unknown, so don't
0:         // check.
0:         if (expectedRows.length > 0) {
0:             Assert.assertEquals("Unexpected column count:",
0:                     expectedRows[0].length, rsmd.getColumnCount());
1:         }
1: 
0:         for (rows = 0; rs.next(); rows++)
1:         {
0:             /* If we have more actual rows than expected rows, don't
0:              * try to assert the row.  Instead just keep iterating
0:              * to see exactly how many rows the actual result set has.
1:              */
0:             if (rows < expectedRows.length)
1:             {
0:                 failString = assertRowInResultSet(rs, rows + 1,
0:                         expectedRows[rows]);
1:             }
1:         }
1: 
0:         rs.close();
1: 
0:         // And finally, assert the row count.
0:         Assert.assertEquals("Unexpected row count:", expectedRows.length, rows);
1:         
0:         return failString;
1:     }
1:     
0:     private static String assertRowInResultSet(ResultSet rs, int rowNum,
0:             Object [] expectedRow) throws SQLException
1:     {
0:         String assertString = "";
0:         int cPos = 0;
0:         ResultSetMetaData rsmd = rs.getMetaData();
0:         for (int i = 0; i < expectedRow.length; i++)
1:         {
0:             cPos = i+1; 
0:             Object obj;
0:             // Trim the expected value, if non-null.
0:             if (expectedRow[i] != null)
0:                 expectedRow[i] = ((String)expectedRow[i]).trim();
1: 
0:             obj = rs.getString(cPos);
1: 
0:             // Trim the rs string.
0:             if (obj != null)
0:                 obj = ((String)obj).trim();
1: 
0:             boolean ok = (rs.wasNull() && (expectedRow[i] == null))
0:                     || (!rs.wasNull()
0:                             && (expectedRow[i] != null)
0:                             && (expectedRow[i].equals(obj)
0:                                     || (obj instanceof byte[] // Assumes byte arrays
0:                                             && Arrays.equals((byte[] )obj,
0:                                                     (byte[] )expectedRow[i]))));
0:             if (!ok)
1:             {
0:                 Object expected = expectedRow[i];
0:                 Object found = obj;
0:                 if (!expected.equals(found))
1:                 {
0:                     assertString = "Column value mismatch @ column '" +
0:                             rsmd.getColumnName(cPos) + "', row " + rowNum +
0:                             ":\n    Expected: >" + expected +
0:                             "<\n    Found:    >" + found + "<";
1:                 }
1:             }
1:         }
0:         return assertString;
1:     }
1:     
1:     public void dropFooTables(Statement stmt) throws SQLException {
0:         stmt.executeUpdate("drop table foo_int");
0:         stmt.executeUpdate("drop table foo_char");
0:         stmt.executeUpdate("drop table foo_varchar");
0:         stmt.executeUpdate("drop table foo_longvarchar");
0:         stmt.executeUpdate("drop table foo_longvarbinary");
0:         stmt.executeUpdate("drop table foo_bit");
0:         stmt.executeUpdate("drop table foo_varbinary");
1:     }
1: }
============================================================================